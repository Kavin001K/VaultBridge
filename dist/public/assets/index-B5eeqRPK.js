const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/home-DBivV2ad.js","assets/input-C-pTQCG0.js","assets/RecentActivity-DFToPhMS.js","assets/activity-ZfMOsVM4.js","assets/chevron-up-2c_phMUQ.js","assets/zap-CO9dCU-d.js","assets/triangle-alert-bbypd66C.js","assets/flame-l2a2LcpR.js","assets/timer-CEQm-Smt.js","assets/upload-cE3y_YaH.js","assets/external-link-BLYwroqP.js","assets/file-text-5AMAkaqP.js","assets/mail-CdmXftMJ.js","assets/github-BdpTREdh.js","assets/key-round-Bp5U_d96.js","assets/users-D9Fr2Pz7.js","assets/upload-Di8Jr_bk.js","assets/browser-gjyt7kQ7.js","assets/file-Cx8dJWJZ.js","assets/key-CdShLzp3.js","assets/paperclip-C3XnrEIS.js","assets/chevron-right-DzU99w6m.js","assets/arrow-right-PS2x-sn_.js","assets/access-DLWkLg5b.js","assets/circle-D_JJW63L.js","assets/share-2-CvDakMJ-.js","assets/downloadStream-DsUNh4ar.js","assets/sparkles-Ch7jgGEg.js","assets/shield-check-DgUGgLfn.js","assets/download-CRssWmit.js","assets/success-BlqpmSDc.js","assets/how-it-works-B7OIuHOp.js","assets/terms-BiGkH4JX.js","assets/privacy-BBlWl2bT.js","assets/get-it-mailed-C8WnGYHM.js","assets/security-D5r_9RUv.js","assets/roadmap-CKyOPHLT.js","assets/seo-landing-RoUYaZYW.js","assets/blogs-DDyIGZsB.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
let WF, Ai, Cn, L_, Z4, gg, ii, V_, tx, cc, ae, Me, $P, vI, Rh, mn, ye, zo, Ax, U_, P3, GR, tS, oi, Rx, Ah, R4, nx, xh, uT, eT, lu, qR, ZR, ct, Ve, vF, yF, ac, zn, Ke, vt, D2, Hh, CS, N3, mo, Kh, Kg, A3, bS, R3, T3, xv, cb, kF, lv, B3, V3, F3, z3, LF, W3, bF, PF, SF, $_, xN, ub, C3, I3, $3, U3, ge, pr, j2, Gs, JS, qD, YD, pg, Ue, lc, F_, _h, gF, L3, j3, S, I_, mg, ft, kb, DT, MT, OT, h, IT, wF, UI, _F, Xb, NF, DF, xF;
let __tla = (async () => {
  var _e2, _t2, _a2, _e3, _t3, _n2, _b2, _e4, _t4, _n3, _c2, _e5, _d2, _e6, _t5, _n4, _s2, _r2, _o2, _a3, _ik_instances, i_fn, _e7, _e8, _t6, _n5, _s3, _r3, _o3, _a4, _i2, _m2, _f2, _h2, _u2, _c3, _l2, _p2, _ok_instances, d_fn, g_fn, y_fn, v_fn, w_fn, x_fn, S_fn, b_fn, T_fn, _f3, _e9, _t7, _n6, _s4, _ck_instances, r_fn, _g2, _e10, _t8, _n7, _h3, _e11, _t9, _n8, _s5, _fk_instances, r_fn2, o_fn, _i3, _e12, _j2, _e13, _t10, _n9, _s6, _r4, _o4, _a5, _i4, _k2, _l3, _m3, _n10, _o5, _p3, _q, _r5, _s7, _t11, _u3, _v2, _w2, _x2, _y2, _z, _A2, _B, _C2, _D2, _E2, _F2, _G, _H, _I2, _J, _K, _L2, _M2, _N2, _O2, _P2, _Q, _R2, _S2, _T2, _U, _V2, _W, _X, _Y, _Z, __2, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Da, _Ea, _Fa, _Ga, _Ha, _Ia, _Ja, _Ka, _La, _Ma, _Na, _Oa, _Pa, _Qa, _Ra, _Sa, _Ta, _Ua, _Va, _Wa, _Xa, _Ya, _Za, __a, _$a, _ab, _bb, _cb, _db, _eb, _fb, _gb, _hb, _ib, _jb, _kb, _lb, _mb, _nb, _ob, _pb, _qb, _rb, _sb, _tb, _ub, _vb, _wb, _xb, _yb, _zb, _Ab, _Bb, _Cb, _Db, _Eb, _Fb, _Gb, _Hb, _Ib, _Jb, _Kb, _Lb, _Mb, _Nb, _Ob, _Pb, _Qb, _Rb, _Sb, _Tb, _Ub, _Vb, _Wb, _Xb, _Yb, _Zb, __b, _$b, _ac, _bc, _cc, _dc, _ec, _fc, _gc, _hc, _ic, _jc, _kc, _lc, _mc, _nc, _oc, _pc, _qc, _rc, _sc, _tc, _uc, _vc, _wc, _xc, _yc, _zc, _Ac, _Bc, _Cc, _Dc, _Ec, _Fc;
  function zT(e, t) {
    for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const s in r) if (s !== "default" && !(s in e)) {
          const i = Object.getOwnPropertyDescriptor(r, s);
          i && Object.defineProperty(e, s, i.get ? i : {
            enumerable: true,
            get: () => r[s]
          });
        }
      }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
    new MutationObserver((s) => {
      for (const i of s) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function n(s) {
      const i = {};
      return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
    }
    function r(s) {
      if (s.ep) return;
      s.ep = true;
      const i = n(s);
      fetch(s.href, i);
    }
  })();
  T3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  xv = function(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  };
  var Sv = {
    exports: {}
  }, Wl = {}, bv = {
    exports: {}
  }, ne = {};
  var Oo = Symbol.for("react.element"), BT = Symbol.for("react.portal"), UT = Symbol.for("react.fragment"), $T = Symbol.for("react.strict_mode"), WT = Symbol.for("react.profiler"), HT = Symbol.for("react.provider"), KT = Symbol.for("react.context"), QT = Symbol.for("react.forward_ref"), GT = Symbol.for("react.suspense"), qT = Symbol.for("react.memo"), ZT = Symbol.for("react.lazy"), Mp = Symbol.iterator;
  function YT(e) {
    return e === null || typeof e != "object" ? null : (e = Mp && e[Mp] || e["@@iterator"], typeof e == "function" ? e : null);
  }
  var Tv = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, Cv = Object.assign, Ev = {};
  function ei(e, t, n) {
    this.props = e, this.context = t, this.refs = Ev, this.updater = n || Tv;
  }
  ei.prototype.isReactComponent = {};
  ei.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState");
  };
  ei.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate");
  };
  function Pv() {
  }
  Pv.prototype = ei.prototype;
  function Cf(e, t, n) {
    this.props = e, this.context = t, this.refs = Ev, this.updater = n || Tv;
  }
  var Ef = Cf.prototype = new Pv();
  Ef.constructor = Cf;
  Cv(Ef, ei.prototype);
  Ef.isPureReactComponent = true;
  var Op = Array.isArray, kv = Object.prototype.hasOwnProperty, Pf = {
    current: null
  }, _v = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function Av(e, t, n) {
    var r, s = {}, i = null, o = null;
    if (t != null) for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (i = "" + t.key), t) kv.call(t, r) && !_v.hasOwnProperty(r) && (s[r] = t[r]);
    var a = arguments.length - 2;
    if (a === 1) s.children = n;
    else if (1 < a) {
      for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
      s.children = l;
    }
    if (e && e.defaultProps) for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]);
    return {
      $$typeof: Oo,
      type: e,
      key: i,
      ref: o,
      props: s,
      _owner: Pf.current
    };
  }
  function XT(e, t) {
    return {
      $$typeof: Oo,
      type: e.type,
      key: t,
      ref: e.ref,
      props: e.props,
      _owner: e._owner
    };
  }
  function kf(e) {
    return typeof e == "object" && e !== null && e.$$typeof === Oo;
  }
  function JT(e) {
    var t = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(n) {
      return t[n];
    });
  }
  var Ip = /\/+/g;
  function Nu(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? JT("" + e.key) : t.toString(36);
  }
  function ka(e, t, n, r, s) {
    var i = typeof e;
    (i === "undefined" || i === "boolean") && (e = null);
    var o = false;
    if (e === null) o = true;
    else switch (i) {
      case "string":
      case "number":
        o = true;
        break;
      case "object":
        switch (e.$$typeof) {
          case Oo:
          case BT:
            o = true;
        }
    }
    if (o) return o = e, s = s(o), e = r === "" ? "." + Nu(o, 0) : r, Op(s) ? (n = "", e != null && (n = e.replace(Ip, "$&/") + "/"), ka(s, t, n, "", function(u) {
      return u;
    })) : s != null && (kf(s) && (s = XT(s, n + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(Ip, "$&/") + "/") + e)), t.push(s)), 1;
    if (o = 0, r = r === "" ? "." : r + ":", Op(e)) for (var a = 0; a < e.length; a++) {
      i = e[a];
      var l = r + Nu(i, a);
      o += ka(i, t, n, l, s);
    }
    else if (l = YT(e), typeof l == "function") for (e = l.call(e), a = 0; !(i = e.next()).done; ) i = i.value, l = r + Nu(i, a++), o += ka(i, t, n, l, s);
    else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return o;
  }
  function Zo(e, t, n) {
    if (e == null) return e;
    var r = [], s = 0;
    return ka(e, r, "", "", function(i) {
      return t.call(n, i, s++);
    }), r;
  }
  function eC(e) {
    if (e._status === -1) {
      var t = e._result;
      t = t(), t.then(function(n) {
        (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n);
      }, function(n) {
        (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n);
      }), e._status === -1 && (e._status = 0, e._result = t);
    }
    if (e._status === 1) return e._result.default;
    throw e._result;
  }
  var lt = {
    current: null
  }, _a = {
    transition: null
  }, tC = {
    ReactCurrentDispatcher: lt,
    ReactCurrentBatchConfig: _a,
    ReactCurrentOwner: Pf
  };
  function Rv() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  ne.Children = {
    map: Zo,
    forEach: function(e, t, n) {
      Zo(e, function() {
        t.apply(this, arguments);
      }, n);
    },
    count: function(e) {
      var t = 0;
      return Zo(e, function() {
        t++;
      }), t;
    },
    toArray: function(e) {
      return Zo(e, function(t) {
        return t;
      }) || [];
    },
    only: function(e) {
      if (!kf(e)) throw Error("React.Children.only expected to receive a single React element child.");
      return e;
    }
  };
  ne.Component = ei;
  ne.Fragment = UT;
  ne.Profiler = WT;
  ne.PureComponent = Cf;
  ne.StrictMode = $T;
  ne.Suspense = GT;
  ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tC;
  ne.act = Rv;
  ne.cloneElement = function(e, t, n) {
    if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var r = Cv({}, e.props), s = e.key, i = e.ref, o = e._owner;
    if (t != null) {
      if (t.ref !== void 0 && (i = t.ref, o = Pf.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
      for (l in t) kv.call(t, l) && !_v.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]);
    }
    var l = arguments.length - 2;
    if (l === 1) r.children = n;
    else if (1 < l) {
      a = Array(l);
      for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
      r.children = a;
    }
    return {
      $$typeof: Oo,
      type: e.type,
      key: s,
      ref: i,
      props: r,
      _owner: o
    };
  };
  ne.createContext = function(e) {
    return e = {
      $$typeof: KT,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }, e.Provider = {
      $$typeof: HT,
      _context: e
    }, e.Consumer = e;
  };
  ne.createElement = Av;
  ne.createFactory = function(e) {
    var t = Av.bind(null, e);
    return t.type = e, t;
  };
  ne.createRef = function() {
    return {
      current: null
    };
  };
  ne.forwardRef = function(e) {
    return {
      $$typeof: QT,
      render: e
    };
  };
  ne.isValidElement = kf;
  ne.lazy = function(e) {
    return {
      $$typeof: ZT,
      _payload: {
        _status: -1,
        _result: e
      },
      _init: eC
    };
  };
  ne.memo = function(e, t) {
    return {
      $$typeof: qT,
      type: e,
      compare: t === void 0 ? null : t
    };
  };
  ne.startTransition = function(e) {
    var t = _a.transition;
    _a.transition = {};
    try {
      e();
    } finally {
      _a.transition = t;
    }
  };
  ne.unstable_act = Rv;
  ne.useCallback = function(e, t) {
    return lt.current.useCallback(e, t);
  };
  ne.useContext = function(e) {
    return lt.current.useContext(e);
  };
  ne.useDebugValue = function() {
  };
  ne.useDeferredValue = function(e) {
    return lt.current.useDeferredValue(e);
  };
  ne.useEffect = function(e, t) {
    return lt.current.useEffect(e, t);
  };
  ne.useId = function() {
    return lt.current.useId();
  };
  ne.useImperativeHandle = function(e, t, n) {
    return lt.current.useImperativeHandle(e, t, n);
  };
  ne.useInsertionEffect = function(e, t) {
    return lt.current.useInsertionEffect(e, t);
  };
  ne.useLayoutEffect = function(e, t) {
    return lt.current.useLayoutEffect(e, t);
  };
  ne.useMemo = function(e, t) {
    return lt.current.useMemo(e, t);
  };
  ne.useReducer = function(e, t, n) {
    return lt.current.useReducer(e, t, n);
  };
  ne.useRef = function(e) {
    return lt.current.useRef(e);
  };
  ne.useState = function(e) {
    return lt.current.useState(e);
  };
  ne.useSyncExternalStore = function(e, t, n) {
    return lt.current.useSyncExternalStore(e, t, n);
  };
  ne.useTransition = function() {
    return lt.current.useTransition();
  };
  ne.version = "18.3.1";
  bv.exports = ne;
  h = bv.exports;
  const ce = xv(h), Hl = zT({
    __proto__: null,
    default: ce
  }, [
    h
  ]);
  var nC = h, rC = Symbol.for("react.element"), sC = Symbol.for("react.fragment"), iC = Object.prototype.hasOwnProperty, oC = nC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, aC = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function Nv(e, t, n) {
    var r, s = {}, i = null, o = null;
    n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (o = t.ref);
    for (r in t) iC.call(t, r) && !aC.hasOwnProperty(r) && (s[r] = t[r]);
    if (e && e.defaultProps) for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]);
    return {
      $$typeof: rC,
      type: e,
      key: i,
      ref: o,
      props: s,
      _owner: oC.current
    };
  }
  Wl.Fragment = sC;
  Wl.jsx = Nv;
  Wl.jsxs = Nv;
  Sv.exports = Wl;
  let Dv, At, Mv, Ov;
  S = Sv.exports;
  Dv = {
    exports: {}
  };
  At = {};
  Mv = {
    exports: {}
  };
  Ov = {};
  (function(e) {
    function t(k, O) {
      var I = k.length;
      k.push(O);
      e: for (; 0 < I; ) {
        var $ = I - 1 >>> 1, le = k[$];
        if (0 < s(le, O)) k[$] = O, k[I] = le, I = $;
        else break e;
      }
    }
    function n(k) {
      return k.length === 0 ? null : k[0];
    }
    function r(k) {
      if (k.length === 0) return null;
      var O = k[0], I = k.pop();
      if (I !== O) {
        k[0] = I;
        e: for (var $ = 0, le = k.length, rt = le >>> 1; $ < rt; ) {
          var qe = 2 * ($ + 1) - 1, hi = k[qe], xn = qe + 1, nn = k[xn];
          if (0 > s(hi, I)) xn < le && 0 > s(nn, hi) ? (k[$] = nn, k[xn] = I, $ = xn) : (k[$] = hi, k[qe] = I, $ = qe);
          else if (xn < le && 0 > s(nn, I)) k[$] = nn, k[xn] = I, $ = xn;
          else break e;
        }
      }
      return O;
    }
    function s(k, O) {
      var I = k.sortIndex - O.sortIndex;
      return I !== 0 ? I : k.id - O.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var i = performance;
      e.unstable_now = function() {
        return i.now();
      };
    } else {
      var o = Date, a = o.now();
      e.unstable_now = function() {
        return o.now() - a;
      };
    }
    var l = [], u = [], c = 1, d = null, f = 3, p = false, w = false, g = false, x = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function v(k) {
      for (var O = n(u); O !== null; ) {
        if (O.callback === null) r(u);
        else if (O.startTime <= k) r(u), O.sortIndex = O.expirationTime, t(l, O);
        else break;
        O = n(u);
      }
    }
    function b(k) {
      if (g = false, v(k), !w) if (n(l) !== null) w = true, W(T);
      else {
        var O = n(u);
        O !== null && B(b, O.startTime - k);
      }
    }
    function T(k, O) {
      w = false, g && (g = false, m(P), P = -1), p = true;
      var I = f;
      try {
        for (v(O), d = n(l); d !== null && (!(d.expirationTime > O) || k && !M()); ) {
          var $ = d.callback;
          if (typeof $ == "function") {
            d.callback = null, f = d.priorityLevel;
            var le = $(d.expirationTime <= O);
            O = e.unstable_now(), typeof le == "function" ? d.callback = le : d === n(l) && r(l), v(O);
          } else r(l);
          d = n(l);
        }
        if (d !== null) var rt = true;
        else {
          var qe = n(u);
          qe !== null && B(b, qe.startTime - O), rt = false;
        }
        return rt;
      } finally {
        d = null, f = I, p = false;
      }
    }
    var C = false, E = null, P = -1, D = 5, A = -1;
    function M() {
      return !(e.unstable_now() - A < D);
    }
    function j() {
      if (E !== null) {
        var k = e.unstable_now();
        A = k;
        var O = true;
        try {
          O = E(true, k);
        } finally {
          O ? Q() : (C = false, E = null);
        }
      } else C = false;
    }
    var Q;
    if (typeof y == "function") Q = function() {
      y(j);
    };
    else if (typeof MessageChannel < "u") {
      var L = new MessageChannel(), Z = L.port2;
      L.port1.onmessage = j, Q = function() {
        Z.postMessage(null);
      };
    } else Q = function() {
      x(j, 0);
    };
    function W(k) {
      E = k, C || (C = true, Q());
    }
    function B(k, O) {
      P = x(function() {
        k(e.unstable_now());
      }, O);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(k) {
      k.callback = null;
    }, e.unstable_continueExecution = function() {
      w || p || (w = true, W(T));
    }, e.unstable_forceFrameRate = function(k) {
      0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < k ? Math.floor(1e3 / k) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return f;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(l);
    }, e.unstable_next = function(k) {
      switch (f) {
        case 1:
        case 2:
        case 3:
          var O = 3;
          break;
        default:
          O = f;
      }
      var I = f;
      f = O;
      try {
        return k();
      } finally {
        f = I;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(k, O) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          k = 3;
      }
      var I = f;
      f = k;
      try {
        return O();
      } finally {
        f = I;
      }
    }, e.unstable_scheduleCallback = function(k, O, I) {
      var $ = e.unstable_now();
      switch (typeof I == "object" && I !== null ? (I = I.delay, I = typeof I == "number" && 0 < I ? $ + I : $) : I = $, k) {
        case 1:
          var le = -1;
          break;
        case 2:
          le = 250;
          break;
        case 5:
          le = 1073741823;
          break;
        case 4:
          le = 1e4;
          break;
        default:
          le = 5e3;
      }
      return le = I + le, k = {
        id: c++,
        callback: O,
        priorityLevel: k,
        startTime: I,
        expirationTime: le,
        sortIndex: -1
      }, I > $ ? (k.sortIndex = I, t(u, k), n(l) === null && k === n(u) && (g ? (m(P), P = -1) : g = true, B(b, I - $))) : (k.sortIndex = le, t(l, k), w || p || (w = true, W(T))), k;
    }, e.unstable_shouldYield = M, e.unstable_wrapCallback = function(k) {
      var O = f;
      return function() {
        var I = f;
        f = O;
        try {
          return k.apply(this, arguments);
        } finally {
          f = I;
        }
      };
    };
  })(Ov);
  Mv.exports = Ov;
  var lC = Mv.exports;
  var uC = h, kt = lC;
  function N(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var Iv = /* @__PURE__ */ new Set(), Qi = {};
  function Xr(e, t) {
    Vs(e, t), Vs(e + "Capture", t);
  }
  function Vs(e, t) {
    for (Qi[e] = t, e = 0; e < t.length; e++) Iv.add(t[e]);
  }
  var Mn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Fc = Object.prototype.hasOwnProperty, cC = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Lp = {}, jp = {};
  function dC(e) {
    return Fc.call(jp, e) ? true : Fc.call(Lp, e) ? false : cC.test(e) ? jp[e] = true : (Lp[e] = true, false);
  }
  function fC(e, t, n, r) {
    if (n !== null && n.type === 0) return false;
    switch (typeof t) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        return r ? false : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
      default:
        return false;
    }
  }
  function hC(e, t, n, r) {
    if (t === null || typeof t > "u" || fC(e, t, n, r)) return true;
    if (r) return false;
    if (n !== null) switch (n.type) {
      case 3:
        return !t;
      case 4:
        return t === false;
      case 5:
        return isNaN(t);
      case 6:
        return isNaN(t) || 1 > t;
    }
    return false;
  }
  function ut(e, t, n, r, s, i, o) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = o;
  }
  var Ge = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    Ge[e] = new ut(e, 0, false, e, null, false, false);
  });
  [
    [
      "acceptCharset",
      "accept-charset"
    ],
    [
      "className",
      "class"
    ],
    [
      "htmlFor",
      "for"
    ],
    [
      "httpEquiv",
      "http-equiv"
    ]
  ].forEach(function(e) {
    var t = e[0];
    Ge[t] = new ut(t, 1, false, e[1], null, false, false);
  });
  [
    "contentEditable",
    "draggable",
    "spellCheck",
    "value"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 2, false, e.toLowerCase(), null, false, false);
  });
  [
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 2, false, e, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    Ge[e] = new ut(e, 3, false, e.toLowerCase(), null, false, false);
  });
  [
    "checked",
    "multiple",
    "muted",
    "selected"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 3, true, e, null, false, false);
  });
  [
    "capture",
    "download"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 4, false, e, null, false, false);
  });
  [
    "cols",
    "rows",
    "size",
    "span"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 6, false, e, null, false, false);
  });
  [
    "rowSpan",
    "start"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 5, false, e.toLowerCase(), null, false, false);
  });
  var _f = /[\-:]([a-z])/g;
  function Af(e) {
    return e[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(_f, Af);
    Ge[t] = new ut(t, 1, false, e, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(_f, Af);
    Ge[t] = new ut(t, 1, false, e, "http://www.w3.org/1999/xlink", false, false);
  });
  [
    "xml:base",
    "xml:lang",
    "xml:space"
  ].forEach(function(e) {
    var t = e.replace(_f, Af);
    Ge[t] = new ut(t, 1, false, e, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  [
    "tabIndex",
    "crossOrigin"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 1, false, e.toLowerCase(), null, false, false);
  });
  Ge.xlinkHref = new ut("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  [
    "src",
    "href",
    "action",
    "formAction"
  ].forEach(function(e) {
    Ge[e] = new ut(e, 1, false, e.toLowerCase(), null, true, true);
  });
  function Rf(e, t, n, r) {
    var s = Ge.hasOwnProperty(t) ? Ge[t] : null;
    (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (hC(t, n, s, r) && (n = null), r || s === null ? dC(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? false : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === true ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
  }
  var Un = uC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Yo = Symbol.for("react.element"), os = Symbol.for("react.portal"), as = Symbol.for("react.fragment"), Nf = Symbol.for("react.strict_mode"), zc = Symbol.for("react.profiler"), Lv = Symbol.for("react.provider"), jv = Symbol.for("react.context"), Df = Symbol.for("react.forward_ref"), Bc = Symbol.for("react.suspense"), Uc = Symbol.for("react.suspense_list"), Mf = Symbol.for("react.memo"), qn = Symbol.for("react.lazy"), Vv = Symbol.for("react.offscreen"), Vp = Symbol.iterator;
  function pi(e) {
    return e === null || typeof e != "object" ? null : (e = Vp && e[Vp] || e["@@iterator"], typeof e == "function" ? e : null);
  }
  var Ce = Object.assign, Du;
  function Ei(e) {
    if (Du === void 0) try {
      throw Error();
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      Du = t && t[1] || "";
    }
    return `
` + Du + e;
  }
  var Mu = false;
  function Ou(e, t) {
    if (!e || Mu) return "";
    Mu = true;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (t) if (t = function() {
        throw Error();
      }, Object.defineProperty(t.prototype, "props", {
        set: function() {
          throw Error();
        }
      }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(t, []);
        } catch (u) {
          var r = u;
        }
        Reflect.construct(e, [], t);
      } else {
        try {
          t.call();
        } catch (u) {
          r = u;
        }
        e.call(t.prototype);
      }
      else {
        try {
          throw Error();
        } catch (u) {
          r = u;
        }
        e();
      }
    } catch (u) {
      if (u && r && typeof u.stack == "string") {
        for (var s = u.stack.split(`
`), i = r.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a]; ) a--;
        for (; 1 <= o && 0 <= a; o--, a--) if (s[o] !== i[a]) {
          if (o !== 1 || a !== 1) do
            if (o--, a--, 0 > a || s[o] !== i[a]) {
              var l = `
` + s[o].replace(" at new ", " at ");
              return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l;
            }
          while (1 <= o && 0 <= a);
          break;
        }
      }
    } finally {
      Mu = false, Error.prepareStackTrace = n;
    }
    return (e = e ? e.displayName || e.name : "") ? Ei(e) : "";
  }
  function pC(e) {
    switch (e.tag) {
      case 5:
        return Ei(e.type);
      case 16:
        return Ei("Lazy");
      case 13:
        return Ei("Suspense");
      case 19:
        return Ei("SuspenseList");
      case 0:
      case 2:
      case 15:
        return e = Ou(e.type, false), e;
      case 11:
        return e = Ou(e.type.render, false), e;
      case 1:
        return e = Ou(e.type, true), e;
      default:
        return "";
    }
  }
  function $c(e) {
    if (e == null) return null;
    if (typeof e == "function") return e.displayName || e.name || null;
    if (typeof e == "string") return e;
    switch (e) {
      case as:
        return "Fragment";
      case os:
        return "Portal";
      case zc:
        return "Profiler";
      case Nf:
        return "StrictMode";
      case Bc:
        return "Suspense";
      case Uc:
        return "SuspenseList";
    }
    if (typeof e == "object") switch (e.$$typeof) {
      case jv:
        return (e.displayName || "Context") + ".Consumer";
      case Lv:
        return (e._context.displayName || "Context") + ".Provider";
      case Df:
        var t = e.render;
        return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
      case Mf:
        return t = e.displayName || null, t !== null ? t : $c(e.type) || "Memo";
      case qn:
        t = e._payload, e = e._init;
        try {
          return $c(e(t));
        } catch {
        }
    }
    return null;
  }
  function mC(e) {
    var t = e.type;
    switch (e.tag) {
      case 24:
        return "Cache";
      case 9:
        return (t.displayName || "Context") + ".Consumer";
      case 10:
        return (t._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return t;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return $c(t);
      case 8:
        return t === Nf ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof t == "function") return t.displayName || t.name || null;
        if (typeof t == "string") return t;
    }
    return null;
  }
  function cr(e) {
    switch (typeof e) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return e;
      case "object":
        return e;
      default:
        return "";
    }
  }
  function Fv(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
  }
  function gC(e) {
    var t = Fv(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
      var s = n.get, i = n.set;
      return Object.defineProperty(e, t, {
        configurable: true,
        get: function() {
          return s.call(this);
        },
        set: function(o) {
          r = "" + o, i.call(this, o);
        }
      }), Object.defineProperty(e, t, {
        enumerable: n.enumerable
      }), {
        getValue: function() {
          return r;
        },
        setValue: function(o) {
          r = "" + o;
        },
        stopTracking: function() {
          e._valueTracker = null, delete e[t];
        }
      };
    }
  }
  function Xo(e) {
    e._valueTracker || (e._valueTracker = gC(e));
  }
  function zv(e) {
    if (!e) return false;
    var t = e._valueTracker;
    if (!t) return true;
    var n = t.getValue(), r = "";
    return e && (r = Fv(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), true) : false;
  }
  function Qa(e) {
    if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
    try {
      return e.activeElement || e.body;
    } catch {
      return e.body;
    }
  }
  function Wc(e, t) {
    var n = t.checked;
    return Ce({}, t, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: n ?? e._wrapperState.initialChecked
    });
  }
  function Fp(e, t) {
    var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked;
    n = cr(t.value != null ? t.value : n), e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    };
  }
  function Bv(e, t) {
    t = t.checked, t != null && Rf(e, "checked", t, false);
  }
  function Hc(e, t) {
    Bv(e, t);
    var n = cr(t.value), r = t.type;
    if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if (r === "submit" || r === "reset") {
      e.removeAttribute("value");
      return;
    }
    t.hasOwnProperty("value") ? Kc(e, t.type, n) : t.hasOwnProperty("defaultValue") && Kc(e, t.type, cr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked);
  }
  function zp(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
      var r = t.type;
      if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return;
      t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t;
    }
    n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n);
  }
  function Kc(e, t, n) {
    (t !== "number" || Qa(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
  }
  var Pi = Array.isArray;
  function Es(e, t, n, r) {
    if (e = e.options, t) {
      t = {};
      for (var s = 0; s < n.length; s++) t["$" + n[s]] = true;
      for (n = 0; n < e.length; n++) s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = true);
    } else {
      for (n = "" + cr(n), t = null, s = 0; s < e.length; s++) {
        if (e[s].value === n) {
          e[s].selected = true, r && (e[s].defaultSelected = true);
          return;
        }
        t !== null || e[s].disabled || (t = e[s]);
      }
      t !== null && (t.selected = true);
    }
  }
  function Qc(e, t) {
    if (t.dangerouslySetInnerHTML != null) throw Error(N(91));
    return Ce({}, t, {
      value: void 0,
      defaultValue: void 0,
      children: "" + e._wrapperState.initialValue
    });
  }
  function Bp(e, t) {
    var n = t.value;
    if (n == null) {
      if (n = t.children, t = t.defaultValue, n != null) {
        if (t != null) throw Error(N(92));
        if (Pi(n)) {
          if (1 < n.length) throw Error(N(93));
          n = n[0];
        }
        t = n;
      }
      t == null && (t = ""), n = t;
    }
    e._wrapperState = {
      initialValue: cr(n)
    };
  }
  function Uv(e, t) {
    var n = cr(t.value), r = cr(t.defaultValue);
    n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r);
  }
  function Up(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
  }
  function $v(e) {
    switch (e) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Gc(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? $v(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e;
  }
  var Jo, Wv = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, s) {
      MSApp.execUnsafeLocalFunction(function() {
        return e(t, n, r, s);
      });
    } : e;
  }(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
    else {
      for (Jo = Jo || document.createElement("div"), Jo.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Jo.firstChild; e.firstChild; ) e.removeChild(e.firstChild);
      for (; t.firstChild; ) e.appendChild(t.firstChild);
    }
  });
  function Gi(e, t) {
    if (t) {
      var n = e.firstChild;
      if (n && n === e.lastChild && n.nodeType === 3) {
        n.nodeValue = t;
        return;
      }
    }
    e.textContent = t;
  }
  var Mi = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, yC = [
    "Webkit",
    "ms",
    "Moz",
    "O"
  ];
  Object.keys(Mi).forEach(function(e) {
    yC.forEach(function(t) {
      t = t + e.charAt(0).toUpperCase() + e.substring(1), Mi[t] = Mi[e];
    });
  });
  function Hv(e, t, n) {
    return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Mi.hasOwnProperty(e) && Mi[e] ? ("" + t).trim() : t + "px";
  }
  function Kv(e, t) {
    e = e.style;
    for (var n in t) if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0, s = Hv(n, t[n], r);
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s;
    }
  }
  var vC = Ce({
    menuitem: true
  }, {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  });
  function qc(e, t) {
    if (t) {
      if (vC[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(N(137, e));
      if (t.dangerouslySetInnerHTML != null) {
        if (t.children != null) throw Error(N(60));
        if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(N(61));
      }
      if (t.style != null && typeof t.style != "object") throw Error(N(62));
    }
  }
  function Zc(e, t) {
    if (e.indexOf("-") === -1) return typeof t.is == "string";
    switch (e) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var Yc = null;
  function Of(e) {
    return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
  }
  var Xc = null, Ps = null, ks = null;
  function $p(e) {
    if (e = jo(e)) {
      if (typeof Xc != "function") throw Error(N(280));
      var t = e.stateNode;
      t && (t = Zl(t), Xc(e.stateNode, e.type, t));
    }
  }
  function Qv(e) {
    Ps ? ks ? ks.push(e) : ks = [
      e
    ] : Ps = e;
  }
  function Gv() {
    if (Ps) {
      var e = Ps, t = ks;
      if (ks = Ps = null, $p(e), t) for (e = 0; e < t.length; e++) $p(t[e]);
    }
  }
  function qv(e, t) {
    return e(t);
  }
  function Zv() {
  }
  var Iu = false;
  function Yv(e, t, n) {
    if (Iu) return e(t, n);
    Iu = true;
    try {
      return qv(e, t, n);
    } finally {
      Iu = false, (Ps !== null || ks !== null) && (Zv(), Gv());
    }
  }
  function qi(e, t) {
    var n = e.stateNode;
    if (n === null) return null;
    var r = Zl(n);
    if (r === null) return null;
    n = r[t];
    e: switch (t) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
        break e;
      default:
        e = false;
    }
    if (e) return null;
    if (n && typeof n != "function") throw Error(N(231, t, typeof n));
    return n;
  }
  var Jc = false;
  if (Mn) try {
    var mi = {};
    Object.defineProperty(mi, "passive", {
      get: function() {
        Jc = true;
      }
    }), window.addEventListener("test", mi, mi), window.removeEventListener("test", mi, mi);
  } catch {
    Jc = false;
  }
  function wC(e, t, n, r, s, i, o, a, l) {
    var u = Array.prototype.slice.call(arguments, 3);
    try {
      t.apply(n, u);
    } catch (c) {
      this.onError(c);
    }
  }
  var Oi = false, Ga = null, qa = false, ed = null, xC = {
    onError: function(e) {
      Oi = true, Ga = e;
    }
  };
  function SC(e, t, n, r, s, i, o, a, l) {
    Oi = false, Ga = null, wC.apply(xC, arguments);
  }
  function bC(e, t, n, r, s, i, o, a, l) {
    if (SC.apply(this, arguments), Oi) {
      if (Oi) {
        var u = Ga;
        Oi = false, Ga = null;
      } else throw Error(N(198));
      qa || (qa = true, ed = u);
    }
  }
  function Jr(e) {
    var t = e, n = e;
    if (e.alternate) for (; t.return; ) t = t.return;
    else {
      e = t;
      do
        t = e, t.flags & 4098 && (n = t.return), e = t.return;
      while (e);
    }
    return t.tag === 3 ? n : null;
  }
  function Xv(e) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
    }
    return null;
  }
  function Wp(e) {
    if (Jr(e) !== e) throw Error(N(188));
  }
  function TC(e) {
    var t = e.alternate;
    if (!t) {
      if (t = Jr(e), t === null) throw Error(N(188));
      return t !== e ? null : e;
    }
    for (var n = e, r = t; ; ) {
      var s = n.return;
      if (s === null) break;
      var i = s.alternate;
      if (i === null) {
        if (r = s.return, r !== null) {
          n = r;
          continue;
        }
        break;
      }
      if (s.child === i.child) {
        for (i = s.child; i; ) {
          if (i === n) return Wp(s), e;
          if (i === r) return Wp(s), t;
          i = i.sibling;
        }
        throw Error(N(188));
      }
      if (n.return !== r.return) n = s, r = i;
      else {
        for (var o = false, a = s.child; a; ) {
          if (a === n) {
            o = true, n = s, r = i;
            break;
          }
          if (a === r) {
            o = true, r = s, n = i;
            break;
          }
          a = a.sibling;
        }
        if (!o) {
          for (a = i.child; a; ) {
            if (a === n) {
              o = true, n = i, r = s;
              break;
            }
            if (a === r) {
              o = true, r = i, n = s;
              break;
            }
            a = a.sibling;
          }
          if (!o) throw Error(N(189));
        }
      }
      if (n.alternate !== r) throw Error(N(190));
    }
    if (n.tag !== 3) throw Error(N(188));
    return n.stateNode.current === n ? e : t;
  }
  function Jv(e) {
    return e = TC(e), e !== null ? e0(e) : null;
  }
  function e0(e) {
    if (e.tag === 5 || e.tag === 6) return e;
    for (e = e.child; e !== null; ) {
      var t = e0(e);
      if (t !== null) return t;
      e = e.sibling;
    }
    return null;
  }
  var t0 = kt.unstable_scheduleCallback, Hp = kt.unstable_cancelCallback, CC = kt.unstable_shouldYield, EC = kt.unstable_requestPaint, De = kt.unstable_now, PC = kt.unstable_getCurrentPriorityLevel, If = kt.unstable_ImmediatePriority, n0 = kt.unstable_UserBlockingPriority, Za = kt.unstable_NormalPriority, kC = kt.unstable_LowPriority, r0 = kt.unstable_IdlePriority, Kl = null, un = null;
  function _C(e) {
    if (un && typeof un.onCommitFiberRoot == "function") try {
      un.onCommitFiberRoot(Kl, e, void 0, (e.current.flags & 128) === 128);
    } catch {
    }
  }
  var Gt = Math.clz32 ? Math.clz32 : NC, AC = Math.log, RC = Math.LN2;
  function NC(e) {
    return e >>>= 0, e === 0 ? 32 : 31 - (AC(e) / RC | 0) | 0;
  }
  var ea = 64, ta = 4194304;
  function ki(e) {
    switch (e & -e) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return e & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return e & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return e;
    }
  }
  function Ya(e, t) {
    var n = e.pendingLanes;
    if (n === 0) return 0;
    var r = 0, s = e.suspendedLanes, i = e.pingedLanes, o = n & 268435455;
    if (o !== 0) {
      var a = o & ~s;
      a !== 0 ? r = ki(a) : (i &= o, i !== 0 && (r = ki(i)));
    } else o = n & ~s, o !== 0 ? r = ki(o) : i !== 0 && (r = ki(i));
    if (r === 0) return 0;
    if (t !== 0 && t !== r && !(t & s) && (s = r & -r, i = t & -t, s >= i || s === 16 && (i & 4194240) !== 0)) return t;
    if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t; ) n = 31 - Gt(t), s = 1 << n, r |= e[n], t &= ~s;
    return r;
  }
  function DC(e, t) {
    switch (e) {
      case 1:
      case 2:
      case 4:
        return t + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return t + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function MC(e, t) {
    for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i; ) {
      var o = 31 - Gt(i), a = 1 << o, l = s[o];
      l === -1 ? (!(a & n) || a & r) && (s[o] = DC(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a;
    }
  }
  function td(e) {
    return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;
  }
  function s0() {
    var e = ea;
    return ea <<= 1, !(ea & 4194240) && (ea = 64), e;
  }
  function Lu(e) {
    for (var t = [], n = 0; 31 > n; n++) t.push(e);
    return t;
  }
  function Io(e, t, n) {
    e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Gt(t), e[t] = n;
  }
  function OC(e, t) {
    var n = e.pendingLanes & ~t;
    e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
    var r = e.eventTimes;
    for (e = e.expirationTimes; 0 < n; ) {
      var s = 31 - Gt(n), i = 1 << s;
      t[s] = 0, r[s] = -1, e[s] = -1, n &= ~i;
    }
  }
  function Lf(e, t) {
    var n = e.entangledLanes |= t;
    for (e = e.entanglements; n; ) {
      var r = 31 - Gt(n), s = 1 << r;
      s & t | e[r] & t && (e[r] |= t), n &= ~s;
    }
  }
  var ue = 0;
  function i0(e) {
    return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var o0, jf, a0, l0, u0, nd = false, na = [], tr = null, nr = null, rr = null, Zi = /* @__PURE__ */ new Map(), Yi = /* @__PURE__ */ new Map(), Yn = [], IC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Kp(e, t) {
    switch (e) {
      case "focusin":
      case "focusout":
        tr = null;
        break;
      case "dragenter":
      case "dragleave":
        nr = null;
        break;
      case "mouseover":
      case "mouseout":
        rr = null;
        break;
      case "pointerover":
      case "pointerout":
        Zi.delete(t.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Yi.delete(t.pointerId);
    }
  }
  function gi(e, t, n, r, s, i) {
    return e === null || e.nativeEvent !== i ? (e = {
      blockedOn: t,
      domEventName: n,
      eventSystemFlags: r,
      nativeEvent: i,
      targetContainers: [
        s
      ]
    }, t !== null && (t = jo(t), t !== null && jf(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e);
  }
  function LC(e, t, n, r, s) {
    switch (t) {
      case "focusin":
        return tr = gi(tr, e, t, n, r, s), true;
      case "dragenter":
        return nr = gi(nr, e, t, n, r, s), true;
      case "mouseover":
        return rr = gi(rr, e, t, n, r, s), true;
      case "pointerover":
        var i = s.pointerId;
        return Zi.set(i, gi(Zi.get(i) || null, e, t, n, r, s)), true;
      case "gotpointercapture":
        return i = s.pointerId, Yi.set(i, gi(Yi.get(i) || null, e, t, n, r, s)), true;
    }
    return false;
  }
  function c0(e) {
    var t = Rr(e.target);
    if (t !== null) {
      var n = Jr(t);
      if (n !== null) {
        if (t = n.tag, t === 13) {
          if (t = Xv(n), t !== null) {
            e.blockedOn = t, u0(e.priority, function() {
              a0(n);
            });
            return;
          }
        } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
          e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
          return;
        }
      }
    }
    e.blockedOn = null;
  }
  function Aa(e) {
    if (e.blockedOn !== null) return false;
    for (var t = e.targetContainers; 0 < t.length; ) {
      var n = rd(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
      if (n === null) {
        n = e.nativeEvent;
        var r = new n.constructor(n.type, n);
        Yc = r, n.target.dispatchEvent(r), Yc = null;
      } else return t = jo(n), t !== null && jf(t), e.blockedOn = n, false;
      t.shift();
    }
    return true;
  }
  function Qp(e, t, n) {
    Aa(e) && n.delete(t);
  }
  function jC() {
    nd = false, tr !== null && Aa(tr) && (tr = null), nr !== null && Aa(nr) && (nr = null), rr !== null && Aa(rr) && (rr = null), Zi.forEach(Qp), Yi.forEach(Qp);
  }
  function yi(e, t) {
    e.blockedOn === t && (e.blockedOn = null, nd || (nd = true, kt.unstable_scheduleCallback(kt.unstable_NormalPriority, jC)));
  }
  function Xi(e) {
    function t(s) {
      return yi(s, e);
    }
    if (0 < na.length) {
      yi(na[0], e);
      for (var n = 1; n < na.length; n++) {
        var r = na[n];
        r.blockedOn === e && (r.blockedOn = null);
      }
    }
    for (tr !== null && yi(tr, e), nr !== null && yi(nr, e), rr !== null && yi(rr, e), Zi.forEach(t), Yi.forEach(t), n = 0; n < Yn.length; n++) r = Yn[n], r.blockedOn === e && (r.blockedOn = null);
    for (; 0 < Yn.length && (n = Yn[0], n.blockedOn === null); ) c0(n), n.blockedOn === null && Yn.shift();
  }
  var _s = Un.ReactCurrentBatchConfig, Xa = true;
  function VC(e, t, n, r) {
    var s = ue, i = _s.transition;
    _s.transition = null;
    try {
      ue = 1, Vf(e, t, n, r);
    } finally {
      ue = s, _s.transition = i;
    }
  }
  function FC(e, t, n, r) {
    var s = ue, i = _s.transition;
    _s.transition = null;
    try {
      ue = 4, Vf(e, t, n, r);
    } finally {
      ue = s, _s.transition = i;
    }
  }
  function Vf(e, t, n, r) {
    if (Xa) {
      var s = rd(e, t, n, r);
      if (s === null) Ku(e, t, r, Ja, n), Kp(e, r);
      else if (LC(s, e, t, n, r)) r.stopPropagation();
      else if (Kp(e, r), t & 4 && -1 < IC.indexOf(e)) {
        for (; s !== null; ) {
          var i = jo(s);
          if (i !== null && o0(i), i = rd(e, t, n, r), i === null && Ku(e, t, r, Ja, n), i === s) break;
          s = i;
        }
        s !== null && r.stopPropagation();
      } else Ku(e, t, r, null, n);
    }
  }
  var Ja = null;
  function rd(e, t, n, r) {
    if (Ja = null, e = Of(r), e = Rr(e), e !== null) if (t = Jr(e), t === null) e = null;
    else if (n = t.tag, n === 13) {
      if (e = Xv(t), e !== null) return e;
      e = null;
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
      e = null;
    } else t !== e && (e = null);
    return Ja = e, null;
  }
  function d0(e) {
    switch (e) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (PC()) {
          case If:
            return 1;
          case n0:
            return 4;
          case Za:
          case kC:
            return 16;
          case r0:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Jn = null, Ff = null, Ra = null;
  function f0() {
    if (Ra) return Ra;
    var e, t = Ff, n = t.length, r, s = "value" in Jn ? Jn.value : Jn.textContent, i = s.length;
    for (e = 0; e < n && t[e] === s[e]; e++) ;
    var o = n - e;
    for (r = 1; r <= o && t[n - r] === s[i - r]; r++) ;
    return Ra = s.slice(e, 1 < r ? 1 - r : void 0);
  }
  function Na(e) {
    var t = e.keyCode;
    return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
  }
  function ra() {
    return true;
  }
  function Gp() {
    return false;
  }
  function Rt(e) {
    function t(n, r, s, i, o) {
      this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null;
      for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(i) : i[a]);
      return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === false) ? ra : Gp, this.isPropagationStopped = Gp, this;
    }
    return Ce(t.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var n = this.nativeEvent;
        n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = false), this.isDefaultPrevented = ra);
      },
      stopPropagation: function() {
        var n = this.nativeEvent;
        n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = true), this.isPropagationStopped = ra);
      },
      persist: function() {
      },
      isPersistent: ra
    }), t;
  }
  var ti = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(e) {
      return e.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, zf = Rt(ti), Lo = Ce({}, ti, {
    view: 0,
    detail: 0
  }), zC = Rt(Lo), ju, Vu, vi, Ql = Ce({}, Lo, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Bf,
    button: 0,
    buttons: 0,
    relatedTarget: function(e) {
      return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
    },
    movementX: function(e) {
      return "movementX" in e ? e.movementX : (e !== vi && (vi && e.type === "mousemove" ? (ju = e.screenX - vi.screenX, Vu = e.screenY - vi.screenY) : Vu = ju = 0, vi = e), ju);
    },
    movementY: function(e) {
      return "movementY" in e ? e.movementY : Vu;
    }
  }), qp = Rt(Ql), BC = Ce({}, Ql, {
    dataTransfer: 0
  }), UC = Rt(BC), $C = Ce({}, Lo, {
    relatedTarget: 0
  }), Fu = Rt($C), WC = Ce({}, ti, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), HC = Rt(WC), KC = Ce({}, ti, {
    clipboardData: function(e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData;
    }
  }), QC = Rt(KC), GC = Ce({}, ti, {
    data: 0
  }), Zp = Rt(GC), qC = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ZC = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, YC = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function XC(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = YC[e]) ? !!t[e] : false;
  }
  function Bf() {
    return XC;
  }
  var JC = Ce({}, Lo, {
    key: function(e) {
      if (e.key) {
        var t = qC[e.key] || e.key;
        if (t !== "Unidentified") return t;
      }
      return e.type === "keypress" ? (e = Na(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? ZC[e.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Bf,
    charCode: function(e) {
      return e.type === "keypress" ? Na(e) : 0;
    },
    keyCode: function(e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
    },
    which: function(e) {
      return e.type === "keypress" ? Na(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
    }
  }), eE = Rt(JC), tE = Ce({}, Ql, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Yp = Rt(tE), nE = Ce({}, Lo, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Bf
  }), rE = Rt(nE), sE = Ce({}, ti, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), iE = Rt(sE), oE = Ce({}, Ql, {
    deltaX: function(e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
    },
    deltaY: function(e) {
      return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), aE = Rt(oE), lE = [
    9,
    13,
    27,
    32
  ], Uf = Mn && "CompositionEvent" in window, Ii = null;
  Mn && "documentMode" in document && (Ii = document.documentMode);
  var uE = Mn && "TextEvent" in window && !Ii, h0 = Mn && (!Uf || Ii && 8 < Ii && 11 >= Ii), Xp = " ", Jp = false;
  function p0(e, t) {
    switch (e) {
      case "keyup":
        return lE.indexOf(t.keyCode) !== -1;
      case "keydown":
        return t.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function m0(e) {
    return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
  }
  var ls = false;
  function cE(e, t) {
    switch (e) {
      case "compositionend":
        return m0(t);
      case "keypress":
        return t.which !== 32 ? null : (Jp = true, Xp);
      case "textInput":
        return e = t.data, e === Xp && Jp ? null : e;
      default:
        return null;
    }
  }
  function dE(e, t) {
    if (ls) return e === "compositionend" || !Uf && p0(e, t) ? (e = f0(), Ra = Ff = Jn = null, ls = false, e) : null;
    switch (e) {
      case "paste":
        return null;
      case "keypress":
        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
          if (t.char && 1 < t.char.length) return t.char;
          if (t.which) return String.fromCharCode(t.which);
        }
        return null;
      case "compositionend":
        return h0 && t.locale !== "ko" ? null : t.data;
      default:
        return null;
    }
  }
  var fE = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function em(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!fE[e.type] : t === "textarea";
  }
  function g0(e, t, n, r) {
    Qv(r), t = el(t, "onChange"), 0 < t.length && (n = new zf("onChange", "change", null, n, r), e.push({
      event: n,
      listeners: t
    }));
  }
  var Li = null, Ji = null;
  function hE(e) {
    k0(e, 0);
  }
  function Gl(e) {
    var t = ds(e);
    if (zv(t)) return e;
  }
  function pE(e, t) {
    if (e === "change") return t;
  }
  var y0 = false;
  if (Mn) {
    var zu;
    if (Mn) {
      var Bu = "oninput" in document;
      if (!Bu) {
        var tm = document.createElement("div");
        tm.setAttribute("oninput", "return;"), Bu = typeof tm.oninput == "function";
      }
      zu = Bu;
    } else zu = false;
    y0 = zu && (!document.documentMode || 9 < document.documentMode);
  }
  function nm() {
    Li && (Li.detachEvent("onpropertychange", v0), Ji = Li = null);
  }
  function v0(e) {
    if (e.propertyName === "value" && Gl(Ji)) {
      var t = [];
      g0(t, Ji, e, Of(e)), Yv(hE, t);
    }
  }
  function mE(e, t, n) {
    e === "focusin" ? (nm(), Li = t, Ji = n, Li.attachEvent("onpropertychange", v0)) : e === "focusout" && nm();
  }
  function gE(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown") return Gl(Ji);
  }
  function yE(e, t) {
    if (e === "click") return Gl(t);
  }
  function vE(e, t) {
    if (e === "input" || e === "change") return Gl(t);
  }
  function wE(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
  }
  var Yt = typeof Object.is == "function" ? Object.is : wE;
  function eo(e, t) {
    if (Yt(e, t)) return true;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null) return false;
    var n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return false;
    for (r = 0; r < n.length; r++) {
      var s = n[r];
      if (!Fc.call(t, s) || !Yt(e[s], t[s])) return false;
    }
    return true;
  }
  function rm(e) {
    for (; e && e.firstChild; ) e = e.firstChild;
    return e;
  }
  function sm(e, t) {
    var n = rm(e);
    e = 0;
    for (var r; n; ) {
      if (n.nodeType === 3) {
        if (r = e + n.textContent.length, e <= t && r >= t) return {
          node: n,
          offset: t - e
        };
        e = r;
      }
      e: {
        for (; n; ) {
          if (n.nextSibling) {
            n = n.nextSibling;
            break e;
          }
          n = n.parentNode;
        }
        n = void 0;
      }
      n = rm(n);
    }
  }
  function w0(e, t) {
    return e && t ? e === t ? true : e && e.nodeType === 3 ? false : t && t.nodeType === 3 ? w0(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : false : false;
  }
  function x0() {
    for (var e = window, t = Qa(); t instanceof e.HTMLIFrameElement; ) {
      try {
        var n = typeof t.contentWindow.location.href == "string";
      } catch {
        n = false;
      }
      if (n) e = t.contentWindow;
      else break;
      t = Qa(e.document);
    }
    return t;
  }
  function $f(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
  }
  function xE(e) {
    var t = x0(), n = e.focusedElem, r = e.selectionRange;
    if (t !== n && n && n.ownerDocument && w0(n.ownerDocument.documentElement, n)) {
      if (r !== null && $f(n)) {
        if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
        else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) {
          e = e.getSelection();
          var s = n.textContent.length, i = Math.min(r.start, s);
          r = r.end === void 0 ? i : Math.min(r.end, s), !e.extend && i > r && (s = r, r = i, i = s), s = sm(n, i);
          var o = sm(n, r);
          s && o && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), i > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)));
        }
      }
      for (t = [], e = n; e = e.parentNode; ) e.nodeType === 1 && t.push({
        element: e,
        left: e.scrollLeft,
        top: e.scrollTop
      });
      for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++) e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top;
    }
  }
  var SE = Mn && "documentMode" in document && 11 >= document.documentMode, us = null, sd = null, ji = null, id = false;
  function im(e, t, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    id || us == null || us !== Qa(r) || (r = us, "selectionStart" in r && $f(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
    }), ji && eo(ji, r) || (ji = r, r = el(sd, "onSelect"), 0 < r.length && (t = new zf("onSelect", "select", null, t, n), e.push({
      event: t,
      listeners: r
    }), t.target = us)));
  }
  function sa(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
  }
  var cs = {
    animationend: sa("Animation", "AnimationEnd"),
    animationiteration: sa("Animation", "AnimationIteration"),
    animationstart: sa("Animation", "AnimationStart"),
    transitionend: sa("Transition", "TransitionEnd")
  }, Uu = {}, S0 = {};
  Mn && (S0 = document.createElement("div").style, "AnimationEvent" in window || (delete cs.animationend.animation, delete cs.animationiteration.animation, delete cs.animationstart.animation), "TransitionEvent" in window || delete cs.transitionend.transition);
  function ql(e) {
    if (Uu[e]) return Uu[e];
    if (!cs[e]) return e;
    var t = cs[e], n;
    for (n in t) if (t.hasOwnProperty(n) && n in S0) return Uu[e] = t[n];
    return e;
  }
  var b0 = ql("animationend"), T0 = ql("animationiteration"), C0 = ql("animationstart"), E0 = ql("transitionend"), P0 = /* @__PURE__ */ new Map(), om = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function xr(e, t) {
    P0.set(e, t), Xr(t, [
      e
    ]);
  }
  for (var $u = 0; $u < om.length; $u++) {
    var Wu = om[$u], bE = Wu.toLowerCase(), TE = Wu[0].toUpperCase() + Wu.slice(1);
    xr(bE, "on" + TE);
  }
  xr(b0, "onAnimationEnd");
  xr(T0, "onAnimationIteration");
  xr(C0, "onAnimationStart");
  xr("dblclick", "onDoubleClick");
  xr("focusin", "onFocus");
  xr("focusout", "onBlur");
  xr(E0, "onTransitionEnd");
  Vs("onMouseEnter", [
    "mouseout",
    "mouseover"
  ]);
  Vs("onMouseLeave", [
    "mouseout",
    "mouseover"
  ]);
  Vs("onPointerEnter", [
    "pointerout",
    "pointerover"
  ]);
  Vs("onPointerLeave", [
    "pointerout",
    "pointerover"
  ]);
  Xr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  Xr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  Xr("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  Xr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  Xr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  Xr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var _i = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), CE = new Set("cancel close invalid load scroll toggle".split(" ").concat(_i));
  function am(e, t, n) {
    var r = e.type || "unknown-event";
    e.currentTarget = n, bC(r, t, void 0, e), e.currentTarget = null;
  }
  function k0(e, t) {
    t = (t & 4) !== 0;
    for (var n = 0; n < e.length; n++) {
      var r = e[n], s = r.event;
      r = r.listeners;
      e: {
        var i = void 0;
        if (t) for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o], l = a.instance, u = a.currentTarget;
          if (a = a.listener, l !== i && s.isPropagationStopped()) break e;
          am(s, a, u), i = l;
        }
        else for (o = 0; o < r.length; o++) {
          if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== i && s.isPropagationStopped()) break e;
          am(s, a, u), i = l;
        }
      }
    }
    if (qa) throw e = ed, qa = false, ed = null, e;
  }
  function pe(e, t) {
    var n = t[cd];
    n === void 0 && (n = t[cd] = /* @__PURE__ */ new Set());
    var r = e + "__bubble";
    n.has(r) || (_0(t, e, 2, false), n.add(r));
  }
  function Hu(e, t, n) {
    var r = 0;
    t && (r |= 4), _0(n, e, r, t);
  }
  var ia = "_reactListening" + Math.random().toString(36).slice(2);
  function to(e) {
    if (!e[ia]) {
      e[ia] = true, Iv.forEach(function(n) {
        n !== "selectionchange" && (CE.has(n) || Hu(n, false, e), Hu(n, true, e));
      });
      var t = e.nodeType === 9 ? e : e.ownerDocument;
      t === null || t[ia] || (t[ia] = true, Hu("selectionchange", false, t));
    }
  }
  function _0(e, t, n, r) {
    switch (d0(t)) {
      case 1:
        var s = VC;
        break;
      case 4:
        s = FC;
        break;
      default:
        s = Vf;
    }
    n = s.bind(null, t, n, e), s = void 0, !Jc || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = true), r ? s !== void 0 ? e.addEventListener(t, n, {
      capture: true,
      passive: s
    }) : e.addEventListener(t, n, true) : s !== void 0 ? e.addEventListener(t, n, {
      passive: s
    }) : e.addEventListener(t, n, false);
  }
  function Ku(e, t, n, r, s) {
    var i = r;
    if (!(t & 1) && !(t & 2) && r !== null) e: for (; ; ) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === s || a.nodeType === 8 && a.parentNode === s) break;
        if (o === 4) for (o = r.return; o !== null; ) {
          var l = o.tag;
          if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return;
          o = o.return;
        }
        for (; a !== null; ) {
          if (o = Rr(a), o === null) return;
          if (l = o.tag, l === 5 || l === 6) {
            r = i = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
    Yv(function() {
      var u = i, c = Of(n), d = [];
      e: {
        var f = P0.get(e);
        if (f !== void 0) {
          var p = zf, w = e;
          switch (e) {
            case "keypress":
              if (Na(n) === 0) break e;
            case "keydown":
            case "keyup":
              p = eE;
              break;
            case "focusin":
              w = "focus", p = Fu;
              break;
            case "focusout":
              w = "blur", p = Fu;
              break;
            case "beforeblur":
            case "afterblur":
              p = Fu;
              break;
            case "click":
              if (n.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              p = qp;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              p = UC;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              p = rE;
              break;
            case b0:
            case T0:
            case C0:
              p = HC;
              break;
            case E0:
              p = iE;
              break;
            case "scroll":
              p = zC;
              break;
            case "wheel":
              p = aE;
              break;
            case "copy":
            case "cut":
            case "paste":
              p = QC;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              p = Yp;
          }
          var g = (t & 4) !== 0, x = !g && e === "scroll", m = g ? f !== null ? f + "Capture" : null : f;
          g = [];
          for (var y = u, v; y !== null; ) {
            v = y;
            var b = v.stateNode;
            if (v.tag === 5 && b !== null && (v = b, m !== null && (b = qi(y, m), b != null && g.push(no(y, b, v)))), x) break;
            y = y.return;
          }
          0 < g.length && (f = new p(f, w, null, n, c), d.push({
            event: f,
            listeners: g
          }));
        }
      }
      if (!(t & 7)) {
        e: {
          if (f = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", f && n !== Yc && (w = n.relatedTarget || n.fromElement) && (Rr(w) || w[On])) break e;
          if ((p || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window, p ? (w = n.relatedTarget || n.toElement, p = u, w = w ? Rr(w) : null, w !== null && (x = Jr(w), w !== x || w.tag !== 5 && w.tag !== 6) && (w = null)) : (p = null, w = u), p !== w)) {
            if (g = qp, b = "onMouseLeave", m = "onMouseEnter", y = "mouse", (e === "pointerout" || e === "pointerover") && (g = Yp, b = "onPointerLeave", m = "onPointerEnter", y = "pointer"), x = p == null ? f : ds(p), v = w == null ? f : ds(w), f = new g(b, y + "leave", p, n, c), f.target = x, f.relatedTarget = v, b = null, Rr(c) === u && (g = new g(m, y + "enter", w, n, c), g.target = v, g.relatedTarget = x, b = g), x = b, p && w) t: {
              for (g = p, m = w, y = 0, v = g; v; v = ts(v)) y++;
              for (v = 0, b = m; b; b = ts(b)) v++;
              for (; 0 < y - v; ) g = ts(g), y--;
              for (; 0 < v - y; ) m = ts(m), v--;
              for (; y--; ) {
                if (g === m || m !== null && g === m.alternate) break t;
                g = ts(g), m = ts(m);
              }
              g = null;
            }
            else g = null;
            p !== null && lm(d, f, p, g, false), w !== null && x !== null && lm(d, x, w, g, true);
          }
        }
        e: {
          if (f = u ? ds(u) : window, p = f.nodeName && f.nodeName.toLowerCase(), p === "select" || p === "input" && f.type === "file") var T = pE;
          else if (em(f)) if (y0) T = vE;
          else {
            T = gE;
            var C = mE;
          }
          else (p = f.nodeName) && p.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (T = yE);
          if (T && (T = T(e, u))) {
            g0(d, T, n, c);
            break e;
          }
          C && C(e, f, u), e === "focusout" && (C = f._wrapperState) && C.controlled && f.type === "number" && Kc(f, "number", f.value);
        }
        switch (C = u ? ds(u) : window, e) {
          case "focusin":
            (em(C) || C.contentEditable === "true") && (us = C, sd = u, ji = null);
            break;
          case "focusout":
            ji = sd = us = null;
            break;
          case "mousedown":
            id = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            id = false, im(d, n, c);
            break;
          case "selectionchange":
            if (SE) break;
          case "keydown":
          case "keyup":
            im(d, n, c);
        }
        var E;
        if (Uf) e: {
          switch (e) {
            case "compositionstart":
              var P = "onCompositionStart";
              break e;
            case "compositionend":
              P = "onCompositionEnd";
              break e;
            case "compositionupdate":
              P = "onCompositionUpdate";
              break e;
          }
          P = void 0;
        }
        else ls ? p0(e, n) && (P = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (P = "onCompositionStart");
        P && (h0 && n.locale !== "ko" && (ls || P !== "onCompositionStart" ? P === "onCompositionEnd" && ls && (E = f0()) : (Jn = c, Ff = "value" in Jn ? Jn.value : Jn.textContent, ls = true)), C = el(u, P), 0 < C.length && (P = new Zp(P, e, null, n, c), d.push({
          event: P,
          listeners: C
        }), E ? P.data = E : (E = m0(n), E !== null && (P.data = E)))), (E = uE ? cE(e, n) : dE(e, n)) && (u = el(u, "onBeforeInput"), 0 < u.length && (c = new Zp("onBeforeInput", "beforeinput", null, n, c), d.push({
          event: c,
          listeners: u
        }), c.data = E));
      }
      k0(d, t);
    });
  }
  function no(e, t, n) {
    return {
      instance: e,
      listener: t,
      currentTarget: n
    };
  }
  function el(e, t) {
    for (var n = t + "Capture", r = []; e !== null; ) {
      var s = e, i = s.stateNode;
      s.tag === 5 && i !== null && (s = i, i = qi(e, n), i != null && r.unshift(no(e, i, s)), i = qi(e, t), i != null && r.push(no(e, i, s))), e = e.return;
    }
    return r;
  }
  function ts(e) {
    if (e === null) return null;
    do
      e = e.return;
    while (e && e.tag !== 5);
    return e || null;
  }
  function lm(e, t, n, r, s) {
    for (var i = t._reactName, o = []; n !== null && n !== r; ) {
      var a = n, l = a.alternate, u = a.stateNode;
      if (l !== null && l === r) break;
      a.tag === 5 && u !== null && (a = u, s ? (l = qi(n, i), l != null && o.unshift(no(n, l, a))) : s || (l = qi(n, i), l != null && o.push(no(n, l, a)))), n = n.return;
    }
    o.length !== 0 && e.push({
      event: t,
      listeners: o
    });
  }
  var EE = /\r\n?/g, PE = /\u0000|\uFFFD/g;
  function um(e) {
    return (typeof e == "string" ? e : "" + e).replace(EE, `
`).replace(PE, "");
  }
  function oa(e, t, n) {
    if (t = um(t), um(e) !== t && n) throw Error(N(425));
  }
  function tl() {
  }
  var od = null, ad = null;
  function ld(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
  }
  var ud = typeof setTimeout == "function" ? setTimeout : void 0, kE = typeof clearTimeout == "function" ? clearTimeout : void 0, cm = typeof Promise == "function" ? Promise : void 0, _E = typeof queueMicrotask == "function" ? queueMicrotask : typeof cm < "u" ? function(e) {
    return cm.resolve(null).then(e).catch(AE);
  } : ud;
  function AE(e) {
    setTimeout(function() {
      throw e;
    });
  }
  function Qu(e, t) {
    var n = t, r = 0;
    do {
      var s = n.nextSibling;
      if (e.removeChild(n), s && s.nodeType === 8) if (n = s.data, n === "/$") {
        if (r === 0) {
          e.removeChild(s), Xi(t);
          return;
        }
        r--;
      } else n !== "$" && n !== "$?" && n !== "$!" || r++;
      n = s;
    } while (n);
    Xi(t);
  }
  function sr(e) {
    for (; e != null; e = e.nextSibling) {
      var t = e.nodeType;
      if (t === 1 || t === 3) break;
      if (t === 8) {
        if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
        if (t === "/$") return null;
      }
    }
    return e;
  }
  function dm(e) {
    e = e.previousSibling;
    for (var t = 0; e; ) {
      if (e.nodeType === 8) {
        var n = e.data;
        if (n === "$" || n === "$!" || n === "$?") {
          if (t === 0) return e;
          t--;
        } else n === "/$" && t++;
      }
      e = e.previousSibling;
    }
    return null;
  }
  var ni = Math.random().toString(36).slice(2), on = "__reactFiber$" + ni, ro = "__reactProps$" + ni, On = "__reactContainer$" + ni, cd = "__reactEvents$" + ni, RE = "__reactListeners$" + ni, NE = "__reactHandles$" + ni;
  function Rr(e) {
    var t = e[on];
    if (t) return t;
    for (var n = e.parentNode; n; ) {
      if (t = n[On] || n[on]) {
        if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = dm(e); e !== null; ) {
          if (n = e[on]) return n;
          e = dm(e);
        }
        return t;
      }
      e = n, n = e.parentNode;
    }
    return null;
  }
  function jo(e) {
    return e = e[on] || e[On], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;
  }
  function ds(e) {
    if (e.tag === 5 || e.tag === 6) return e.stateNode;
    throw Error(N(33));
  }
  function Zl(e) {
    return e[ro] || null;
  }
  var dd = [], fs = -1;
  function Sr(e) {
    return {
      current: e
    };
  }
  function me(e) {
    0 > fs || (e.current = dd[fs], dd[fs] = null, fs--);
  }
  function de(e, t) {
    fs++, dd[fs] = e.current, e.current = t;
  }
  var dr = {}, tt = Sr(dr), mt = Sr(false), Fr = dr;
  function Fs(e, t) {
    var n = e.type.contextTypes;
    if (!n) return dr;
    var r = e.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
    var s = {}, i;
    for (i in n) s[i] = t[i];
    return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s;
  }
  function gt(e) {
    return e = e.childContextTypes, e != null;
  }
  function nl() {
    me(mt), me(tt);
  }
  function fm(e, t, n) {
    if (tt.current !== dr) throw Error(N(168));
    de(tt, t), de(mt, n);
  }
  function A0(e, t, n) {
    var r = e.stateNode;
    if (t = t.childContextTypes, typeof r.getChildContext != "function") return n;
    r = r.getChildContext();
    for (var s in r) if (!(s in t)) throw Error(N(108, mC(e) || "Unknown", s));
    return Ce({}, n, r);
  }
  function rl(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || dr, Fr = tt.current, de(tt, e), de(mt, mt.current), true;
  }
  function hm(e, t, n) {
    var r = e.stateNode;
    if (!r) throw Error(N(169));
    n ? (e = A0(e, t, Fr), r.__reactInternalMemoizedMergedChildContext = e, me(mt), me(tt), de(tt, e)) : me(mt), de(mt, n);
  }
  var En = null, Yl = false, Gu = false;
  function R0(e) {
    En === null ? En = [
      e
    ] : En.push(e);
  }
  function DE(e) {
    Yl = true, R0(e);
  }
  function br() {
    if (!Gu && En !== null) {
      Gu = true;
      var e = 0, t = ue;
      try {
        var n = En;
        for (ue = 1; e < n.length; e++) {
          var r = n[e];
          do
            r = r(true);
          while (r !== null);
        }
        En = null, Yl = false;
      } catch (s) {
        throw En !== null && (En = En.slice(e + 1)), t0(If, br), s;
      } finally {
        ue = t, Gu = false;
      }
    }
    return null;
  }
  var hs = [], ps = 0, sl = null, il = 0, Ot = [], It = 0, zr = null, _n = 1, An = "";
  function Pr(e, t) {
    hs[ps++] = il, hs[ps++] = sl, sl = e, il = t;
  }
  function N0(e, t, n) {
    Ot[It++] = _n, Ot[It++] = An, Ot[It++] = zr, zr = e;
    var r = _n;
    e = An;
    var s = 32 - Gt(r) - 1;
    r &= ~(1 << s), n += 1;
    var i = 32 - Gt(t) + s;
    if (30 < i) {
      var o = s - s % 5;
      i = (r & (1 << o) - 1).toString(32), r >>= o, s -= o, _n = 1 << 32 - Gt(t) + s | n << s | r, An = i + e;
    } else _n = 1 << i | n << s | r, An = e;
  }
  function Wf(e) {
    e.return !== null && (Pr(e, 1), N0(e, 1, 0));
  }
  function Hf(e) {
    for (; e === sl; ) sl = hs[--ps], hs[ps] = null, il = hs[--ps], hs[ps] = null;
    for (; e === zr; ) zr = Ot[--It], Ot[It] = null, An = Ot[--It], Ot[It] = null, _n = Ot[--It], Ot[It] = null;
  }
  var Ct = null, Tt = null, ve = false, Kt = null;
  function D0(e, t) {
    var n = Lt(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [
      n
    ], e.flags |= 16) : t.push(n);
  }
  function pm(e, t) {
    switch (e.tag) {
      case 5:
        var n = e.type;
        return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Ct = e, Tt = sr(t.firstChild), true) : false;
      case 6:
        return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Ct = e, Tt = null, true) : false;
      case 13:
        return t = t.nodeType !== 8 ? null : t, t !== null ? (n = zr !== null ? {
          id: _n,
          overflow: An
        } : null, e.memoizedState = {
          dehydrated: t,
          treeContext: n,
          retryLane: 1073741824
        }, n = Lt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Ct = e, Tt = null, true) : false;
      default:
        return false;
    }
  }
  function fd(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
  }
  function hd(e) {
    if (ve) {
      var t = Tt;
      if (t) {
        var n = t;
        if (!pm(e, t)) {
          if (fd(e)) throw Error(N(418));
          t = sr(n.nextSibling);
          var r = Ct;
          t && pm(e, t) ? D0(r, n) : (e.flags = e.flags & -4097 | 2, ve = false, Ct = e);
        }
      } else {
        if (fd(e)) throw Error(N(418));
        e.flags = e.flags & -4097 | 2, ve = false, Ct = e;
      }
    }
  }
  function mm(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return;
    Ct = e;
  }
  function aa(e) {
    if (e !== Ct) return false;
    if (!ve) return mm(e), ve = true, false;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !ld(e.type, e.memoizedProps)), t && (t = Tt)) {
      if (fd(e)) throw M0(), Error(N(418));
      for (; t; ) D0(e, t), t = sr(t.nextSibling);
    }
    if (mm(e), e.tag === 13) {
      if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(N(317));
      e: {
        for (e = e.nextSibling, t = 0; e; ) {
          if (e.nodeType === 8) {
            var n = e.data;
            if (n === "/$") {
              if (t === 0) {
                Tt = sr(e.nextSibling);
                break e;
              }
              t--;
            } else n !== "$" && n !== "$!" && n !== "$?" || t++;
          }
          e = e.nextSibling;
        }
        Tt = null;
      }
    } else Tt = Ct ? sr(e.stateNode.nextSibling) : null;
    return true;
  }
  function M0() {
    for (var e = Tt; e; ) e = sr(e.nextSibling);
  }
  function zs() {
    Tt = Ct = null, ve = false;
  }
  function Kf(e) {
    Kt === null ? Kt = [
      e
    ] : Kt.push(e);
  }
  var ME = Un.ReactCurrentBatchConfig;
  function wi(e, t, n) {
    if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") {
      if (n._owner) {
        if (n = n._owner, n) {
          if (n.tag !== 1) throw Error(N(309));
          var r = n.stateNode;
        }
        if (!r) throw Error(N(147, e));
        var s = r, i = "" + e;
        return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function(o) {
          var a = s.refs;
          o === null ? delete a[i] : a[i] = o;
        }, t._stringRef = i, t);
      }
      if (typeof e != "string") throw Error(N(284));
      if (!n._owner) throw Error(N(290, e));
    }
    return e;
  }
  function la(e, t) {
    throw e = Object.prototype.toString.call(t), Error(N(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
  }
  function gm(e) {
    var t = e._init;
    return t(e._payload);
  }
  function O0(e) {
    function t(m, y) {
      if (e) {
        var v = m.deletions;
        v === null ? (m.deletions = [
          y
        ], m.flags |= 16) : v.push(y);
      }
    }
    function n(m, y) {
      if (!e) return null;
      for (; y !== null; ) t(m, y), y = y.sibling;
      return null;
    }
    function r(m, y) {
      for (m = /* @__PURE__ */ new Map(); y !== null; ) y.key !== null ? m.set(y.key, y) : m.set(y.index, y), y = y.sibling;
      return m;
    }
    function s(m, y) {
      return m = lr(m, y), m.index = 0, m.sibling = null, m;
    }
    function i(m, y, v) {
      return m.index = v, e ? (v = m.alternate, v !== null ? (v = v.index, v < y ? (m.flags |= 2, y) : v) : (m.flags |= 2, y)) : (m.flags |= 1048576, y);
    }
    function o(m) {
      return e && m.alternate === null && (m.flags |= 2), m;
    }
    function a(m, y, v, b) {
      return y === null || y.tag !== 6 ? (y = tc(v, m.mode, b), y.return = m, y) : (y = s(y, v), y.return = m, y);
    }
    function l(m, y, v, b) {
      var T = v.type;
      return T === as ? c(m, y, v.props.children, b, v.key) : y !== null && (y.elementType === T || typeof T == "object" && T !== null && T.$$typeof === qn && gm(T) === y.type) ? (b = s(y, v.props), b.ref = wi(m, y, v), b.return = m, b) : (b = Va(v.type, v.key, v.props, null, m.mode, b), b.ref = wi(m, y, v), b.return = m, b);
    }
    function u(m, y, v, b) {
      return y === null || y.tag !== 4 || y.stateNode.containerInfo !== v.containerInfo || y.stateNode.implementation !== v.implementation ? (y = nc(v, m.mode, b), y.return = m, y) : (y = s(y, v.children || []), y.return = m, y);
    }
    function c(m, y, v, b, T) {
      return y === null || y.tag !== 7 ? (y = Lr(v, m.mode, b, T), y.return = m, y) : (y = s(y, v), y.return = m, y);
    }
    function d(m, y, v) {
      if (typeof y == "string" && y !== "" || typeof y == "number") return y = tc("" + y, m.mode, v), y.return = m, y;
      if (typeof y == "object" && y !== null) {
        switch (y.$$typeof) {
          case Yo:
            return v = Va(y.type, y.key, y.props, null, m.mode, v), v.ref = wi(m, null, y), v.return = m, v;
          case os:
            return y = nc(y, m.mode, v), y.return = m, y;
          case qn:
            var b = y._init;
            return d(m, b(y._payload), v);
        }
        if (Pi(y) || pi(y)) return y = Lr(y, m.mode, v, null), y.return = m, y;
        la(m, y);
      }
      return null;
    }
    function f(m, y, v, b) {
      var T = y !== null ? y.key : null;
      if (typeof v == "string" && v !== "" || typeof v == "number") return T !== null ? null : a(m, y, "" + v, b);
      if (typeof v == "object" && v !== null) {
        switch (v.$$typeof) {
          case Yo:
            return v.key === T ? l(m, y, v, b) : null;
          case os:
            return v.key === T ? u(m, y, v, b) : null;
          case qn:
            return T = v._init, f(m, y, T(v._payload), b);
        }
        if (Pi(v) || pi(v)) return T !== null ? null : c(m, y, v, b, null);
        la(m, v);
      }
      return null;
    }
    function p(m, y, v, b, T) {
      if (typeof b == "string" && b !== "" || typeof b == "number") return m = m.get(v) || null, a(y, m, "" + b, T);
      if (typeof b == "object" && b !== null) {
        switch (b.$$typeof) {
          case Yo:
            return m = m.get(b.key === null ? v : b.key) || null, l(y, m, b, T);
          case os:
            return m = m.get(b.key === null ? v : b.key) || null, u(y, m, b, T);
          case qn:
            var C = b._init;
            return p(m, y, v, C(b._payload), T);
        }
        if (Pi(b) || pi(b)) return m = m.get(v) || null, c(y, m, b, T, null);
        la(y, b);
      }
      return null;
    }
    function w(m, y, v, b) {
      for (var T = null, C = null, E = y, P = y = 0, D = null; E !== null && P < v.length; P++) {
        E.index > P ? (D = E, E = null) : D = E.sibling;
        var A = f(m, E, v[P], b);
        if (A === null) {
          E === null && (E = D);
          break;
        }
        e && E && A.alternate === null && t(m, E), y = i(A, y, P), C === null ? T = A : C.sibling = A, C = A, E = D;
      }
      if (P === v.length) return n(m, E), ve && Pr(m, P), T;
      if (E === null) {
        for (; P < v.length; P++) E = d(m, v[P], b), E !== null && (y = i(E, y, P), C === null ? T = E : C.sibling = E, C = E);
        return ve && Pr(m, P), T;
      }
      for (E = r(m, E); P < v.length; P++) D = p(E, m, P, v[P], b), D !== null && (e && D.alternate !== null && E.delete(D.key === null ? P : D.key), y = i(D, y, P), C === null ? T = D : C.sibling = D, C = D);
      return e && E.forEach(function(M) {
        return t(m, M);
      }), ve && Pr(m, P), T;
    }
    function g(m, y, v, b) {
      var T = pi(v);
      if (typeof T != "function") throw Error(N(150));
      if (v = T.call(v), v == null) throw Error(N(151));
      for (var C = T = null, E = y, P = y = 0, D = null, A = v.next(); E !== null && !A.done; P++, A = v.next()) {
        E.index > P ? (D = E, E = null) : D = E.sibling;
        var M = f(m, E, A.value, b);
        if (M === null) {
          E === null && (E = D);
          break;
        }
        e && E && M.alternate === null && t(m, E), y = i(M, y, P), C === null ? T = M : C.sibling = M, C = M, E = D;
      }
      if (A.done) return n(m, E), ve && Pr(m, P), T;
      if (E === null) {
        for (; !A.done; P++, A = v.next()) A = d(m, A.value, b), A !== null && (y = i(A, y, P), C === null ? T = A : C.sibling = A, C = A);
        return ve && Pr(m, P), T;
      }
      for (E = r(m, E); !A.done; P++, A = v.next()) A = p(E, m, P, A.value, b), A !== null && (e && A.alternate !== null && E.delete(A.key === null ? P : A.key), y = i(A, y, P), C === null ? T = A : C.sibling = A, C = A);
      return e && E.forEach(function(j) {
        return t(m, j);
      }), ve && Pr(m, P), T;
    }
    function x(m, y, v, b) {
      if (typeof v == "object" && v !== null && v.type === as && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) {
        switch (v.$$typeof) {
          case Yo:
            e: {
              for (var T = v.key, C = y; C !== null; ) {
                if (C.key === T) {
                  if (T = v.type, T === as) {
                    if (C.tag === 7) {
                      n(m, C.sibling), y = s(C, v.props.children), y.return = m, m = y;
                      break e;
                    }
                  } else if (C.elementType === T || typeof T == "object" && T !== null && T.$$typeof === qn && gm(T) === C.type) {
                    n(m, C.sibling), y = s(C, v.props), y.ref = wi(m, C, v), y.return = m, m = y;
                    break e;
                  }
                  n(m, C);
                  break;
                } else t(m, C);
                C = C.sibling;
              }
              v.type === as ? (y = Lr(v.props.children, m.mode, b, v.key), y.return = m, m = y) : (b = Va(v.type, v.key, v.props, null, m.mode, b), b.ref = wi(m, y, v), b.return = m, m = b);
            }
            return o(m);
          case os:
            e: {
              for (C = v.key; y !== null; ) {
                if (y.key === C) if (y.tag === 4 && y.stateNode.containerInfo === v.containerInfo && y.stateNode.implementation === v.implementation) {
                  n(m, y.sibling), y = s(y, v.children || []), y.return = m, m = y;
                  break e;
                } else {
                  n(m, y);
                  break;
                }
                else t(m, y);
                y = y.sibling;
              }
              y = nc(v, m.mode, b), y.return = m, m = y;
            }
            return o(m);
          case qn:
            return C = v._init, x(m, y, C(v._payload), b);
        }
        if (Pi(v)) return w(m, y, v, b);
        if (pi(v)) return g(m, y, v, b);
        la(m, v);
      }
      return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, y !== null && y.tag === 6 ? (n(m, y.sibling), y = s(y, v), y.return = m, m = y) : (n(m, y), y = tc(v, m.mode, b), y.return = m, m = y), o(m)) : n(m, y);
    }
    return x;
  }
  var Bs = O0(true), I0 = O0(false), ol = Sr(null), al = null, ms = null, Qf = null;
  function Gf() {
    Qf = ms = al = null;
  }
  function qf(e) {
    var t = ol.current;
    me(ol), e._currentValue = t;
  }
  function pd(e, t, n) {
    for (; e !== null; ) {
      var r = e.alternate;
      if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
      e = e.return;
    }
  }
  function As(e, t) {
    al = e, Qf = ms = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (pt = true), e.firstContext = null);
  }
  function Vt(e) {
    var t = e._currentValue;
    if (Qf !== e) if (e = {
      context: e,
      memoizedValue: t,
      next: null
    }, ms === null) {
      if (al === null) throw Error(N(308));
      ms = e, al.dependencies = {
        lanes: 0,
        firstContext: e
      };
    } else ms = ms.next = e;
    return t;
  }
  var Nr = null;
  function Zf(e) {
    Nr === null ? Nr = [
      e
    ] : Nr.push(e);
  }
  function L0(e, t, n, r) {
    var s = t.interleaved;
    return s === null ? (n.next = n, Zf(t)) : (n.next = s.next, s.next = n), t.interleaved = n, In(e, r);
  }
  function In(e, t) {
    e.lanes |= t;
    var n = e.alternate;
    for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; ) e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var Zn = false;
  function Yf(e) {
    e.updateQueue = {
      baseState: e.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }
  function j0(e, t) {
    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
      baseState: e.baseState,
      firstBaseUpdate: e.firstBaseUpdate,
      lastBaseUpdate: e.lastBaseUpdate,
      shared: e.shared,
      effects: e.effects
    });
  }
  function Rn(e, t) {
    return {
      eventTime: e,
      lane: t,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function ir(e, t, n) {
    var r = e.updateQueue;
    if (r === null) return null;
    if (r = r.shared, ie & 2) {
      var s = r.pending;
      return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, In(e, n);
    }
    return s = r.interleaved, s === null ? (t.next = t, Zf(r)) : (t.next = s.next, s.next = t), r.interleaved = t, In(e, n);
  }
  function Da(e, t, n) {
    if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) {
      var r = t.lanes;
      r &= e.pendingLanes, n |= r, t.lanes = n, Lf(e, n);
    }
  }
  function ym(e, t) {
    var n = e.updateQueue, r = e.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
      var s = null, i = null;
      if (n = n.firstBaseUpdate, n !== null) {
        do {
          var o = {
            eventTime: n.eventTime,
            lane: n.lane,
            tag: n.tag,
            payload: n.payload,
            callback: n.callback,
            next: null
          };
          i === null ? s = i = o : i = i.next = o, n = n.next;
        } while (n !== null);
        i === null ? s = i = t : i = i.next = t;
      } else s = i = t;
      n = {
        baseState: r.baseState,
        firstBaseUpdate: s,
        lastBaseUpdate: i,
        shared: r.shared,
        effects: r.effects
      }, e.updateQueue = n;
      return;
    }
    e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
  }
  function ll(e, t, n, r) {
    var s = e.updateQueue;
    Zn = false;
    var i = s.firstBaseUpdate, o = s.lastBaseUpdate, a = s.shared.pending;
    if (a !== null) {
      s.shared.pending = null;
      var l = a, u = l.next;
      l.next = null, o === null ? i = u : o.next = u, o = l;
      var c = e.alternate;
      c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l));
    }
    if (i !== null) {
      var d = s.baseState;
      o = 0, c = u = l = null, a = i;
      do {
        var f = a.lane, p = a.eventTime;
        if ((r & f) === f) {
          c !== null && (c = c.next = {
            eventTime: p,
            lane: 0,
            tag: a.tag,
            payload: a.payload,
            callback: a.callback,
            next: null
          });
          e: {
            var w = e, g = a;
            switch (f = t, p = n, g.tag) {
              case 1:
                if (w = g.payload, typeof w == "function") {
                  d = w.call(p, d, f);
                  break e;
                }
                d = w;
                break e;
              case 3:
                w.flags = w.flags & -65537 | 128;
              case 0:
                if (w = g.payload, f = typeof w == "function" ? w.call(p, d, f) : w, f == null) break e;
                d = Ce({}, d, f);
                break e;
              case 2:
                Zn = true;
            }
          }
          a.callback !== null && a.lane !== 0 && (e.flags |= 64, f = s.effects, f === null ? s.effects = [
            a
          ] : f.push(a));
        } else p = {
          eventTime: p,
          lane: f,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        }, c === null ? (u = c = p, l = d) : c = c.next = p, o |= f;
        if (a = a.next, a === null) {
          if (a = s.shared.pending, a === null) break;
          f = a, a = f.next, f.next = null, s.lastBaseUpdate = f, s.shared.pending = null;
        }
      } while (true);
      if (c === null && (l = d), s.baseState = l, s.firstBaseUpdate = u, s.lastBaseUpdate = c, t = s.shared.interleaved, t !== null) {
        s = t;
        do
          o |= s.lane, s = s.next;
        while (s !== t);
      } else i === null && (s.shared.lanes = 0);
      Ur |= o, e.lanes = o, e.memoizedState = d;
    }
  }
  function vm(e, t, n) {
    if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) {
      var r = e[t], s = r.callback;
      if (s !== null) {
        if (r.callback = null, r = n, typeof s != "function") throw Error(N(191, s));
        s.call(r);
      }
    }
  }
  var Vo = {}, cn = Sr(Vo), so = Sr(Vo), io = Sr(Vo);
  function Dr(e) {
    if (e === Vo) throw Error(N(174));
    return e;
  }
  function Xf(e, t) {
    switch (de(io, t), de(so, e), de(cn, Vo), e = t.nodeType, e) {
      case 9:
      case 11:
        t = (t = t.documentElement) ? t.namespaceURI : Gc(null, "");
        break;
      default:
        e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Gc(t, e);
    }
    me(cn), de(cn, t);
  }
  function Us() {
    me(cn), me(so), me(io);
  }
  function V0(e) {
    Dr(io.current);
    var t = Dr(cn.current), n = Gc(t, e.type);
    t !== n && (de(so, e), de(cn, n));
  }
  function Jf(e) {
    so.current === e && (me(cn), me(so));
  }
  var Se = Sr(0);
  function ul(e) {
    for (var t = e; t !== null; ) {
      if (t.tag === 13) {
        var n = t.memoizedState;
        if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t;
      } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
        if (t.flags & 128) return t;
      } else if (t.child !== null) {
        t.child.return = t, t = t.child;
        continue;
      }
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return null;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
    return null;
  }
  var qu = [];
  function eh() {
    for (var e = 0; e < qu.length; e++) qu[e]._workInProgressVersionPrimary = null;
    qu.length = 0;
  }
  var Ma = Un.ReactCurrentDispatcher, Zu = Un.ReactCurrentBatchConfig, Br = 0, Te = null, Ie = null, ze = null, cl = false, Vi = false, oo = 0, OE = 0;
  function Ze() {
    throw Error(N(321));
  }
  function th(e, t) {
    if (t === null) return false;
    for (var n = 0; n < t.length && n < e.length; n++) if (!Yt(e[n], t[n])) return false;
    return true;
  }
  function nh(e, t, n, r, s, i) {
    if (Br = i, Te = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Ma.current = e === null || e.memoizedState === null ? VE : FE, e = n(r, s), Vi) {
      i = 0;
      do {
        if (Vi = false, oo = 0, 25 <= i) throw Error(N(301));
        i += 1, ze = Ie = null, t.updateQueue = null, Ma.current = zE, e = n(r, s);
      } while (Vi);
    }
    if (Ma.current = dl, t = Ie !== null && Ie.next !== null, Br = 0, ze = Ie = Te = null, cl = false, t) throw Error(N(300));
    return e;
  }
  function rh() {
    var e = oo !== 0;
    return oo = 0, e;
  }
  function sn() {
    var e = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return ze === null ? Te.memoizedState = ze = e : ze = ze.next = e, ze;
  }
  function Ft() {
    if (Ie === null) {
      var e = Te.alternate;
      e = e !== null ? e.memoizedState : null;
    } else e = Ie.next;
    var t = ze === null ? Te.memoizedState : ze.next;
    if (t !== null) ze = t, Ie = e;
    else {
      if (e === null) throw Error(N(310));
      Ie = e, e = {
        memoizedState: Ie.memoizedState,
        baseState: Ie.baseState,
        baseQueue: Ie.baseQueue,
        queue: Ie.queue,
        next: null
      }, ze === null ? Te.memoizedState = ze = e : ze = ze.next = e;
    }
    return ze;
  }
  function ao(e, t) {
    return typeof t == "function" ? t(e) : t;
  }
  function Yu(e) {
    var t = Ft(), n = t.queue;
    if (n === null) throw Error(N(311));
    n.lastRenderedReducer = e;
    var r = Ie, s = r.baseQueue, i = n.pending;
    if (i !== null) {
      if (s !== null) {
        var o = s.next;
        s.next = i.next, i.next = o;
      }
      r.baseQueue = s = i, n.pending = null;
    }
    if (s !== null) {
      i = s.next, r = r.baseState;
      var a = o = null, l = null, u = i;
      do {
        var c = u.lane;
        if ((Br & c) === c) l !== null && (l = l.next = {
          lane: 0,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null
        }), r = u.hasEagerState ? u.eagerState : e(r, u.action);
        else {
          var d = {
            lane: c,
            action: u.action,
            hasEagerState: u.hasEagerState,
            eagerState: u.eagerState,
            next: null
          };
          l === null ? (a = l = d, o = r) : l = l.next = d, Te.lanes |= c, Ur |= c;
        }
        u = u.next;
      } while (u !== null && u !== i);
      l === null ? o = r : l.next = a, Yt(r, t.memoizedState) || (pt = true), t.memoizedState = r, t.baseState = o, t.baseQueue = l, n.lastRenderedState = r;
    }
    if (e = n.interleaved, e !== null) {
      s = e;
      do
        i = s.lane, Te.lanes |= i, Ur |= i, s = s.next;
      while (s !== e);
    } else s === null && (n.lanes = 0);
    return [
      t.memoizedState,
      n.dispatch
    ];
  }
  function Xu(e) {
    var t = Ft(), n = t.queue;
    if (n === null) throw Error(N(311));
    n.lastRenderedReducer = e;
    var r = n.dispatch, s = n.pending, i = t.memoizedState;
    if (s !== null) {
      n.pending = null;
      var o = s = s.next;
      do
        i = e(i, o.action), o = o.next;
      while (o !== s);
      Yt(i, t.memoizedState) || (pt = true), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i;
    }
    return [
      i,
      r
    ];
  }
  function F0() {
  }
  function z0(e, t) {
    var n = Te, r = Ft(), s = t(), i = !Yt(r.memoizedState, s);
    if (i && (r.memoizedState = s, pt = true), r = r.queue, sh($0.bind(null, n, r, e), [
      e
    ]), r.getSnapshot !== t || i || ze !== null && ze.memoizedState.tag & 1) {
      if (n.flags |= 2048, lo(9, U0.bind(null, n, r, s, t), void 0, null), Be === null) throw Error(N(349));
      Br & 30 || B0(n, t, s);
    }
    return s;
  }
  function B0(e, t, n) {
    e.flags |= 16384, e = {
      getSnapshot: t,
      value: n
    }, t = Te.updateQueue, t === null ? (t = {
      lastEffect: null,
      stores: null
    }, Te.updateQueue = t, t.stores = [
      e
    ]) : (n = t.stores, n === null ? t.stores = [
      e
    ] : n.push(e));
  }
  function U0(e, t, n, r) {
    t.value = n, t.getSnapshot = r, W0(t) && H0(e);
  }
  function $0(e, t, n) {
    return n(function() {
      W0(t) && H0(e);
    });
  }
  function W0(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
      var n = t();
      return !Yt(e, n);
    } catch {
      return true;
    }
  }
  function H0(e) {
    var t = In(e, 1);
    t !== null && qt(t, e, 1, -1);
  }
  function wm(e) {
    var t = sn();
    return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ao,
      lastRenderedState: e
    }, t.queue = e, e = e.dispatch = jE.bind(null, Te, e), [
      t.memoizedState,
      e
    ];
  }
  function lo(e, t, n, r) {
    return e = {
      tag: e,
      create: t,
      destroy: n,
      deps: r,
      next: null
    }, t = Te.updateQueue, t === null ? (t = {
      lastEffect: null,
      stores: null
    }, Te.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e;
  }
  function K0() {
    return Ft().memoizedState;
  }
  function Oa(e, t, n, r) {
    var s = sn();
    Te.flags |= e, s.memoizedState = lo(1 | t, n, void 0, r === void 0 ? null : r);
  }
  function Xl(e, t, n, r) {
    var s = Ft();
    r = r === void 0 ? null : r;
    var i = void 0;
    if (Ie !== null) {
      var o = Ie.memoizedState;
      if (i = o.destroy, r !== null && th(r, o.deps)) {
        s.memoizedState = lo(t, n, i, r);
        return;
      }
    }
    Te.flags |= e, s.memoizedState = lo(1 | t, n, i, r);
  }
  function xm(e, t) {
    return Oa(8390656, 8, e, t);
  }
  function sh(e, t) {
    return Xl(2048, 8, e, t);
  }
  function Q0(e, t) {
    return Xl(4, 2, e, t);
  }
  function G0(e, t) {
    return Xl(4, 4, e, t);
  }
  function q0(e, t) {
    if (typeof t == "function") return e = e(), t(e), function() {
      t(null);
    };
    if (t != null) return e = e(), t.current = e, function() {
      t.current = null;
    };
  }
  function Z0(e, t, n) {
    return n = n != null ? n.concat([
      e
    ]) : null, Xl(4, 4, q0.bind(null, t, e), n);
  }
  function ih() {
  }
  function Y0(e, t) {
    var n = Ft();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && th(t, r[1]) ? r[0] : (n.memoizedState = [
      e,
      t
    ], e);
  }
  function X0(e, t) {
    var n = Ft();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && th(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [
      e,
      t
    ], e);
  }
  function J0(e, t, n) {
    return Br & 21 ? (Yt(n, t) || (n = s0(), Te.lanes |= n, Ur |= n, e.baseState = true), t) : (e.baseState && (e.baseState = false, pt = true), e.memoizedState = n);
  }
  function IE(e, t) {
    var n = ue;
    ue = n !== 0 && 4 > n ? n : 4, e(true);
    var r = Zu.transition;
    Zu.transition = {};
    try {
      e(false), t();
    } finally {
      ue = n, Zu.transition = r;
    }
  }
  function ew() {
    return Ft().memoizedState;
  }
  function LE(e, t, n) {
    var r = ar(e);
    if (n = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    }, tw(e)) nw(t, n);
    else if (n = L0(e, t, n, r), n !== null) {
      var s = ot();
      qt(n, e, r, s), rw(n, t, r);
    }
  }
  function jE(e, t, n) {
    var r = ar(e), s = {
      lane: r,
      action: n,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (tw(e)) nw(t, s);
    else {
      var i = e.alternate;
      if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try {
        var o = t.lastRenderedState, a = i(o, n);
        if (s.hasEagerState = true, s.eagerState = a, Yt(a, o)) {
          var l = t.interleaved;
          l === null ? (s.next = s, Zf(t)) : (s.next = l.next, l.next = s), t.interleaved = s;
          return;
        }
      } catch {
      } finally {
      }
      n = L0(e, t, s, r), n !== null && (s = ot(), qt(n, e, r, s), rw(n, t, r));
    }
  }
  function tw(e) {
    var t = e.alternate;
    return e === Te || t !== null && t === Te;
  }
  function nw(e, t) {
    Vi = cl = true;
    var n = e.pending;
    n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
  }
  function rw(e, t, n) {
    if (n & 4194240) {
      var r = t.lanes;
      r &= e.pendingLanes, n |= r, t.lanes = n, Lf(e, n);
    }
  }
  var dl = {
    readContext: Vt,
    useCallback: Ze,
    useContext: Ze,
    useEffect: Ze,
    useImperativeHandle: Ze,
    useInsertionEffect: Ze,
    useLayoutEffect: Ze,
    useMemo: Ze,
    useReducer: Ze,
    useRef: Ze,
    useState: Ze,
    useDebugValue: Ze,
    useDeferredValue: Ze,
    useTransition: Ze,
    useMutableSource: Ze,
    useSyncExternalStore: Ze,
    useId: Ze,
    unstable_isNewReconciler: false
  }, VE = {
    readContext: Vt,
    useCallback: function(e, t) {
      return sn().memoizedState = [
        e,
        t === void 0 ? null : t
      ], e;
    },
    useContext: Vt,
    useEffect: xm,
    useImperativeHandle: function(e, t, n) {
      return n = n != null ? n.concat([
        e
      ]) : null, Oa(4194308, 4, q0.bind(null, t, e), n);
    },
    useLayoutEffect: function(e, t) {
      return Oa(4194308, 4, e, t);
    },
    useInsertionEffect: function(e, t) {
      return Oa(4, 2, e, t);
    },
    useMemo: function(e, t) {
      var n = sn();
      return t = t === void 0 ? null : t, e = e(), n.memoizedState = [
        e,
        t
      ], e;
    },
    useReducer: function(e, t, n) {
      var r = sn();
      return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: t
      }, r.queue = e, e = e.dispatch = LE.bind(null, Te, e), [
        r.memoizedState,
        e
      ];
    },
    useRef: function(e) {
      var t = sn();
      return e = {
        current: e
      }, t.memoizedState = e;
    },
    useState: wm,
    useDebugValue: ih,
    useDeferredValue: function(e) {
      return sn().memoizedState = e;
    },
    useTransition: function() {
      var e = wm(false), t = e[0];
      return e = IE.bind(null, e[1]), sn().memoizedState = e, [
        t,
        e
      ];
    },
    useMutableSource: function() {
    },
    useSyncExternalStore: function(e, t, n) {
      var r = Te, s = sn();
      if (ve) {
        if (n === void 0) throw Error(N(407));
        n = n();
      } else {
        if (n = t(), Be === null) throw Error(N(349));
        Br & 30 || B0(r, t, n);
      }
      s.memoizedState = n;
      var i = {
        value: n,
        getSnapshot: t
      };
      return s.queue = i, xm($0.bind(null, r, i, e), [
        e
      ]), r.flags |= 2048, lo(9, U0.bind(null, r, i, n, t), void 0, null), n;
    },
    useId: function() {
      var e = sn(), t = Be.identifierPrefix;
      if (ve) {
        var n = An, r = _n;
        n = (r & ~(1 << 32 - Gt(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = oo++, 0 < n && (t += "H" + n.toString(32)), t += ":";
      } else n = OE++, t = ":" + t + "r" + n.toString(32) + ":";
      return e.memoizedState = t;
    },
    unstable_isNewReconciler: false
  }, FE = {
    readContext: Vt,
    useCallback: Y0,
    useContext: Vt,
    useEffect: sh,
    useImperativeHandle: Z0,
    useInsertionEffect: Q0,
    useLayoutEffect: G0,
    useMemo: X0,
    useReducer: Yu,
    useRef: K0,
    useState: function() {
      return Yu(ao);
    },
    useDebugValue: ih,
    useDeferredValue: function(e) {
      var t = Ft();
      return J0(t, Ie.memoizedState, e);
    },
    useTransition: function() {
      var e = Yu(ao)[0], t = Ft().memoizedState;
      return [
        e,
        t
      ];
    },
    useMutableSource: F0,
    useSyncExternalStore: z0,
    useId: ew,
    unstable_isNewReconciler: false
  }, zE = {
    readContext: Vt,
    useCallback: Y0,
    useContext: Vt,
    useEffect: sh,
    useImperativeHandle: Z0,
    useInsertionEffect: Q0,
    useLayoutEffect: G0,
    useMemo: X0,
    useReducer: Xu,
    useRef: K0,
    useState: function() {
      return Xu(ao);
    },
    useDebugValue: ih,
    useDeferredValue: function(e) {
      var t = Ft();
      return Ie === null ? t.memoizedState = e : J0(t, Ie.memoizedState, e);
    },
    useTransition: function() {
      var e = Xu(ao)[0], t = Ft().memoizedState;
      return [
        e,
        t
      ];
    },
    useMutableSource: F0,
    useSyncExternalStore: z0,
    useId: ew,
    unstable_isNewReconciler: false
  };
  function Ut(e, t) {
    if (e && e.defaultProps) {
      t = Ce({}, t), e = e.defaultProps;
      for (var n in e) t[n] === void 0 && (t[n] = e[n]);
      return t;
    }
    return t;
  }
  function md(e, t, n, r) {
    t = e.memoizedState, n = n(r, t), n = n == null ? t : Ce({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n);
  }
  var Jl = {
    isMounted: function(e) {
      return (e = e._reactInternals) ? Jr(e) === e : false;
    },
    enqueueSetState: function(e, t, n) {
      e = e._reactInternals;
      var r = ot(), s = ar(e), i = Rn(r, s);
      i.payload = t, n != null && (i.callback = n), t = ir(e, i, s), t !== null && (qt(t, e, s, r), Da(t, e, s));
    },
    enqueueReplaceState: function(e, t, n) {
      e = e._reactInternals;
      var r = ot(), s = ar(e), i = Rn(r, s);
      i.tag = 1, i.payload = t, n != null && (i.callback = n), t = ir(e, i, s), t !== null && (qt(t, e, s, r), Da(t, e, s));
    },
    enqueueForceUpdate: function(e, t) {
      e = e._reactInternals;
      var n = ot(), r = ar(e), s = Rn(n, r);
      s.tag = 2, t != null && (s.callback = t), t = ir(e, s, r), t !== null && (qt(t, e, r, n), Da(t, e, r));
    }
  };
  function Sm(e, t, n, r, s, i, o) {
    return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !eo(n, r) || !eo(s, i) : true;
  }
  function sw(e, t, n) {
    var r = false, s = dr, i = t.contextType;
    return typeof i == "object" && i !== null ? i = Vt(i) : (s = gt(t) ? Fr : tt.current, r = t.contextTypes, i = (r = r != null) ? Fs(e, s) : dr), t = new t(n, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Jl, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = i), t;
  }
  function bm(e, t, n, r) {
    e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Jl.enqueueReplaceState(t, t.state, null);
  }
  function gd(e, t, n, r) {
    var s = e.stateNode;
    s.props = n, s.state = e.memoizedState, s.refs = {}, Yf(e);
    var i = t.contextType;
    typeof i == "object" && i !== null ? s.context = Vt(i) : (i = gt(t) ? Fr : tt.current, s.context = Fs(e, i)), s.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (md(e, t, i, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && Jl.enqueueReplaceState(s, s.state, null), ll(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308);
  }
  function $s(e, t) {
    try {
      var n = "", r = t;
      do
        n += pC(r), r = r.return;
      while (r);
      var s = n;
    } catch (i) {
      s = `
Error generating stack: ` + i.message + `
` + i.stack;
    }
    return {
      value: e,
      source: t,
      stack: s,
      digest: null
    };
  }
  function Ju(e, t, n) {
    return {
      value: e,
      source: null,
      stack: n ?? null,
      digest: t ?? null
    };
  }
  function yd(e, t) {
    try {
      console.error(t.value);
    } catch (n) {
      setTimeout(function() {
        throw n;
      });
    }
  }
  var BE = typeof WeakMap == "function" ? WeakMap : Map;
  function iw(e, t, n) {
    n = Rn(-1, n), n.tag = 3, n.payload = {
      element: null
    };
    var r = t.value;
    return n.callback = function() {
      hl || (hl = true, kd = r), yd(e, t);
    }, n;
  }
  function ow(e, t, n) {
    n = Rn(-1, n), n.tag = 3;
    var r = e.type.getDerivedStateFromError;
    if (typeof r == "function") {
      var s = t.value;
      n.payload = function() {
        return r(s);
      }, n.callback = function() {
        yd(e, t);
      };
    }
    var i = e.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function() {
      yd(e, t), typeof r != "function" && (or === null ? or = /* @__PURE__ */ new Set([
        this
      ]) : or.add(this));
      var o = t.stack;
      this.componentDidCatch(t.value, {
        componentStack: o !== null ? o : ""
      });
    }), n;
  }
  function Tm(e, t, n) {
    var r = e.pingCache;
    if (r === null) {
      r = e.pingCache = new BE();
      var s = /* @__PURE__ */ new Set();
      r.set(t, s);
    } else s = r.get(t), s === void 0 && (s = /* @__PURE__ */ new Set(), r.set(t, s));
    s.has(n) || (s.add(n), e = tP.bind(null, e, t, n), t.then(e, e));
  }
  function Cm(e) {
    do {
      var t;
      if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : true), t) return e;
      e = e.return;
    } while (e !== null);
    return null;
  }
  function Em(e, t, n, r, s) {
    return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Rn(-1, 1), t.tag = 2, ir(n, t, 1))), n.lanes |= 1), e);
  }
  var UE = Un.ReactCurrentOwner, pt = false;
  function st(e, t, n, r) {
    t.child = e === null ? I0(t, null, n, r) : Bs(t, e.child, n, r);
  }
  function Pm(e, t, n, r, s) {
    n = n.render;
    var i = t.ref;
    return As(t, s), r = nh(e, t, n, r, i, s), n = rh(), e !== null && !pt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, Ln(e, t, s)) : (ve && n && Wf(t), t.flags |= 1, st(e, t, r, s), t.child);
  }
  function km(e, t, n, r, s) {
    if (e === null) {
      var i = n.type;
      return typeof i == "function" && !hh(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = i, aw(e, t, i, r, s)) : (e = Va(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e);
    }
    if (i = e.child, !(e.lanes & s)) {
      var o = i.memoizedProps;
      if (n = n.compare, n = n !== null ? n : eo, n(o, r) && e.ref === t.ref) return Ln(e, t, s);
    }
    return t.flags |= 1, e = lr(i, r), e.ref = t.ref, e.return = t, t.child = e;
  }
  function aw(e, t, n, r, s) {
    if (e !== null) {
      var i = e.memoizedProps;
      if (eo(i, r) && e.ref === t.ref) if (pt = false, t.pendingProps = r = i, (e.lanes & s) !== 0) e.flags & 131072 && (pt = true);
      else return t.lanes = e.lanes, Ln(e, t, s);
    }
    return vd(e, t, n, r, s);
  }
  function lw(e, t, n) {
    var r = t.pendingProps, s = r.children, i = e !== null ? e.memoizedState : null;
    if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, de(ys, wt), wt |= n;
    else {
      if (!(n & 1073741824)) return e = i !== null ? i.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
        baseLanes: e,
        cachePool: null,
        transitions: null
      }, t.updateQueue = null, de(ys, wt), wt |= e, null;
      t.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      }, r = i !== null ? i.baseLanes : n, de(ys, wt), wt |= r;
    }
    else i !== null ? (r = i.baseLanes | n, t.memoizedState = null) : r = n, de(ys, wt), wt |= r;
    return st(e, t, s, n), t.child;
  }
  function uw(e, t) {
    var n = t.ref;
    (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152);
  }
  function vd(e, t, n, r, s) {
    var i = gt(n) ? Fr : tt.current;
    return i = Fs(t, i), As(t, s), n = nh(e, t, n, r, i, s), r = rh(), e !== null && !pt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, Ln(e, t, s)) : (ve && r && Wf(t), t.flags |= 1, st(e, t, n, s), t.child);
  }
  function _m(e, t, n, r, s) {
    if (gt(n)) {
      var i = true;
      rl(t);
    } else i = false;
    if (As(t, s), t.stateNode === null) Ia(e, t), sw(t, n, r), gd(t, n, r, s), r = true;
    else if (e === null) {
      var o = t.stateNode, a = t.memoizedProps;
      o.props = a;
      var l = o.context, u = n.contextType;
      typeof u == "object" && u !== null ? u = Vt(u) : (u = gt(n) ? Fr : tt.current, u = Fs(t, u));
      var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function";
      d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && bm(t, o, r, u), Zn = false;
      var f = t.memoizedState;
      o.state = f, ll(t, r, o, s), l = t.memoizedState, a !== r || f !== l || mt.current || Zn ? (typeof c == "function" && (md(t, n, c, r), l = t.memoizedState), (a = Zn || Sm(t, n, a, r, f, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = false);
    } else {
      o = t.stateNode, j0(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : Ut(t.type, a), o.props = u, d = t.pendingProps, f = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Vt(l) : (l = gt(n) ? Fr : tt.current, l = Fs(t, l));
      var p = n.getDerivedStateFromProps;
      (c = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || f !== l) && bm(t, o, r, l), Zn = false, f = t.memoizedState, o.state = f, ll(t, r, o, s);
      var w = t.memoizedState;
      a !== d || f !== w || mt.current || Zn ? (typeof p == "function" && (md(t, n, p, r), w = t.memoizedState), (u = Zn || Sm(t, n, u, r, f, w, l) || false) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, w, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, w, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = w), o.props = r, o.state = w, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = false);
    }
    return wd(e, t, n, r, i, s);
  }
  function wd(e, t, n, r, s, i) {
    uw(e, t);
    var o = (t.flags & 128) !== 0;
    if (!r && !o) return s && hm(t, n, false), Ln(e, t, i);
    r = t.stateNode, UE.current = t;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return t.flags |= 1, e !== null && o ? (t.child = Bs(t, e.child, null, i), t.child = Bs(t, null, a, i)) : st(e, t, a, i), t.memoizedState = r.state, s && hm(t, n, true), t.child;
  }
  function cw(e) {
    var t = e.stateNode;
    t.pendingContext ? fm(e, t.pendingContext, t.pendingContext !== t.context) : t.context && fm(e, t.context, false), Xf(e, t.containerInfo);
  }
  function Am(e, t, n, r, s) {
    return zs(), Kf(s), t.flags |= 256, st(e, t, n, r), t.child;
  }
  var xd = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
  };
  function Sd(e) {
    return {
      baseLanes: e,
      cachePool: null,
      transitions: null
    };
  }
  function dw(e, t, n) {
    var r = t.pendingProps, s = Se.current, i = false, o = (t.flags & 128) !== 0, a;
    if ((a = o) || (a = e !== null && e.memoizedState === null ? false : (s & 2) !== 0), a ? (i = true, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), de(Se, s & 1), e === null) return hd(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, i ? (r = t.mode, i = t.child, o = {
      mode: "hidden",
      children: o
    }, !(r & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = o) : i = nu(o, r, 0, null), e = Lr(e, r, n, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = Sd(n), t.memoizedState = xd, e) : oh(t, o));
    if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return $E(e, t, o, r, a, s, n);
    if (i) {
      i = r.fallback, o = t.mode, s = e.child, a = s.sibling;
      var l = {
        mode: "hidden",
        children: r.children
      };
      return !(o & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = lr(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? i = lr(a, i) : (i = Lr(i, o, n, null), i.flags |= 2), i.return = t, r.return = t, r.sibling = i, t.child = r, r = i, i = t.child, o = e.child.memoizedState, o = o === null ? Sd(n) : {
        baseLanes: o.baseLanes | n,
        cachePool: null,
        transitions: o.transitions
      }, i.memoizedState = o, i.childLanes = e.childLanes & ~n, t.memoizedState = xd, r;
    }
    return i = e.child, e = i.sibling, r = lr(i, {
      mode: "visible",
      children: r.children
    }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [
      e
    ], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r;
  }
  function oh(e, t) {
    return t = nu({
      mode: "visible",
      children: t
    }, e.mode, 0, null), t.return = e, e.child = t;
  }
  function ua(e, t, n, r) {
    return r !== null && Kf(r), Bs(t, e.child, null, n), e = oh(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
  }
  function $E(e, t, n, r, s, i, o) {
    if (n) return t.flags & 256 ? (t.flags &= -257, r = Ju(Error(N(422))), ua(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = r.fallback, s = t.mode, r = nu({
      mode: "visible",
      children: r.children
    }, s, 0, null), i = Lr(i, s, o, null), i.flags |= 2, r.return = t, i.return = t, r.sibling = i, t.child = r, t.mode & 1 && Bs(t, e.child, null, o), t.child.memoizedState = Sd(o), t.memoizedState = xd, i);
    if (!(t.mode & 1)) return ua(e, t, o, null);
    if (s.data === "$!") {
      if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst;
      return r = a, i = Error(N(419)), r = Ju(i, r, void 0), ua(e, t, o, r);
    }
    if (a = (o & e.childLanes) !== 0, pt || a) {
      if (r = Be, r !== null) {
        switch (o & -o) {
          case 4:
            s = 2;
            break;
          case 16:
            s = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            s = 32;
            break;
          case 536870912:
            s = 268435456;
            break;
          default:
            s = 0;
        }
        s = s & (r.suspendedLanes | o) ? 0 : s, s !== 0 && s !== i.retryLane && (i.retryLane = s, In(e, s), qt(r, e, s, -1));
      }
      return fh(), r = Ju(Error(N(421))), ua(e, t, o, r);
    }
    return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = nP.bind(null, e), s._reactRetry = t, null) : (e = i.treeContext, Tt = sr(s.nextSibling), Ct = t, ve = true, Kt = null, e !== null && (Ot[It++] = _n, Ot[It++] = An, Ot[It++] = zr, _n = e.id, An = e.overflow, zr = t), t = oh(t, r.children), t.flags |= 4096, t);
  }
  function Rm(e, t, n) {
    e.lanes |= t;
    var r = e.alternate;
    r !== null && (r.lanes |= t), pd(e.return, t, n);
  }
  function ec(e, t, n, r, s) {
    var i = e.memoizedState;
    i === null ? e.memoizedState = {
      isBackwards: t,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: n,
      tailMode: s
    } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = n, i.tailMode = s);
  }
  function fw(e, t, n) {
    var r = t.pendingProps, s = r.revealOrder, i = r.tail;
    if (st(e, t, r.children, n), r = Se.current, r & 2) r = r & 1 | 2, t.flags |= 128;
    else {
      if (e !== null && e.flags & 128) e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && Rm(e, n, t);
        else if (e.tag === 19) Rm(e, n, t);
        else if (e.child !== null) {
          e.child.return = e, e = e.child;
          continue;
        }
        if (e === t) break e;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
      r &= 1;
    }
    if (de(Se, r), !(t.mode & 1)) t.memoizedState = null;
    else switch (s) {
      case "forwards":
        for (n = t.child, s = null; n !== null; ) e = n.alternate, e !== null && ul(e) === null && (s = n), n = n.sibling;
        n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), ec(t, false, s, n, i);
        break;
      case "backwards":
        for (n = null, s = t.child, t.child = null; s !== null; ) {
          if (e = s.alternate, e !== null && ul(e) === null) {
            t.child = s;
            break;
          }
          e = s.sibling, s.sibling = n, n = s, s = e;
        }
        ec(t, true, n, null, i);
        break;
      case "together":
        ec(t, false, null, null, void 0);
        break;
      default:
        t.memoizedState = null;
    }
    return t.child;
  }
  function Ia(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2);
  }
  function Ln(e, t, n) {
    if (e !== null && (t.dependencies = e.dependencies), Ur |= t.lanes, !(n & t.childLanes)) return null;
    if (e !== null && t.child !== e.child) throw Error(N(153));
    if (t.child !== null) {
      for (e = t.child, n = lr(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; ) e = e.sibling, n = n.sibling = lr(e, e.pendingProps), n.return = t;
      n.sibling = null;
    }
    return t.child;
  }
  function WE(e, t, n) {
    switch (t.tag) {
      case 3:
        cw(t), zs();
        break;
      case 5:
        V0(t);
        break;
      case 1:
        gt(t.type) && rl(t);
        break;
      case 4:
        Xf(t, t.stateNode.containerInfo);
        break;
      case 10:
        var r = t.type._context, s = t.memoizedProps.value;
        de(ol, r._currentValue), r._currentValue = s;
        break;
      case 13:
        if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (de(Se, Se.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? dw(e, t, n) : (de(Se, Se.current & 1), e = Ln(e, t, n), e !== null ? e.sibling : null);
        de(Se, Se.current & 1);
        break;
      case 19:
        if (r = (n & t.childLanes) !== 0, e.flags & 128) {
          if (r) return fw(e, t, n);
          t.flags |= 128;
        }
        if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), de(Se, Se.current), r) break;
        return null;
      case 22:
      case 23:
        return t.lanes = 0, lw(e, t, n);
    }
    return Ln(e, t, n);
  }
  var hw, bd, pw, mw;
  hw = function(e, t) {
    for (var n = t.child; n !== null; ) {
      if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
      else if (n.tag !== 4 && n.child !== null) {
        n.child.return = n, n = n.child;
        continue;
      }
      if (n === t) break;
      for (; n.sibling === null; ) {
        if (n.return === null || n.return === t) return;
        n = n.return;
      }
      n.sibling.return = n.return, n = n.sibling;
    }
  };
  bd = function() {
  };
  pw = function(e, t, n, r) {
    var s = e.memoizedProps;
    if (s !== r) {
      e = t.stateNode, Dr(cn.current);
      var i = null;
      switch (n) {
        case "input":
          s = Wc(e, s), r = Wc(e, r), i = [];
          break;
        case "select":
          s = Ce({}, s, {
            value: void 0
          }), r = Ce({}, r, {
            value: void 0
          }), i = [];
          break;
        case "textarea":
          s = Qc(e, s), r = Qc(e, r), i = [];
          break;
        default:
          typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = tl);
      }
      qc(n, r);
      var o;
      n = null;
      for (u in s) if (!r.hasOwnProperty(u) && s.hasOwnProperty(u) && s[u] != null) if (u === "style") {
        var a = s[u];
        for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "");
      } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Qi.hasOwnProperty(u) ? i || (i = []) : (i = i || []).push(u, null));
      for (u in r) {
        var l = r[u];
        if (a = s?.[u], r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) {
          for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
          for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]);
        } else n || (i || (i = []), i.push(u, n)), n = l;
        else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Qi.hasOwnProperty(u) ? (l != null && u === "onScroll" && pe("scroll", e), i || a === l || (i = [])) : (i = i || []).push(u, l));
      }
      n && (i = i || []).push("style", n);
      var u = i;
      (t.updateQueue = u) && (t.flags |= 4);
    }
  };
  mw = function(e, t, n, r) {
    n !== r && (t.flags |= 4);
  };
  function xi(e, t) {
    if (!ve) switch (e.tailMode) {
      case "hidden":
        t = e.tail;
        for (var n = null; t !== null; ) t.alternate !== null && (n = t), t = t.sibling;
        n === null ? e.tail = null : n.sibling = null;
        break;
      case "collapsed":
        n = e.tail;
        for (var r = null; n !== null; ) n.alternate !== null && (r = n), n = n.sibling;
        r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null;
    }
  }
  function Ye(e) {
    var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0;
    if (t) for (var s = e.child; s !== null; ) n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling;
    else for (s = e.child; s !== null; ) n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling;
    return e.subtreeFlags |= r, e.childLanes = n, t;
  }
  function HE(e, t, n) {
    var r = t.pendingProps;
    switch (Hf(t), t.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ye(t), null;
      case 1:
        return gt(t.type) && nl(), Ye(t), null;
      case 3:
        return r = t.stateNode, Us(), me(mt), me(tt), eh(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (aa(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Kt !== null && (Rd(Kt), Kt = null))), bd(e, t), Ye(t), null;
      case 5:
        Jf(t);
        var s = Dr(io.current);
        if (n = t.type, e !== null && t.stateNode != null) pw(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
        else {
          if (!r) {
            if (t.stateNode === null) throw Error(N(166));
            return Ye(t), null;
          }
          if (e = Dr(cn.current), aa(t)) {
            r = t.stateNode, n = t.type;
            var i = t.memoizedProps;
            switch (r[on] = t, r[ro] = i, e = (t.mode & 1) !== 0, n) {
              case "dialog":
                pe("cancel", r), pe("close", r);
                break;
              case "iframe":
              case "object":
              case "embed":
                pe("load", r);
                break;
              case "video":
              case "audio":
                for (s = 0; s < _i.length; s++) pe(_i[s], r);
                break;
              case "source":
                pe("error", r);
                break;
              case "img":
              case "image":
              case "link":
                pe("error", r), pe("load", r);
                break;
              case "details":
                pe("toggle", r);
                break;
              case "input":
                Fp(r, i), pe("invalid", r);
                break;
              case "select":
                r._wrapperState = {
                  wasMultiple: !!i.multiple
                }, pe("invalid", r);
                break;
              case "textarea":
                Bp(r, i), pe("invalid", r);
            }
            qc(n, i), s = null;
            for (var o in i) if (i.hasOwnProperty(o)) {
              var a = i[o];
              o === "children" ? typeof a == "string" ? r.textContent !== a && (i.suppressHydrationWarning !== true && oa(r.textContent, a, e), s = [
                "children",
                a
              ]) : typeof a == "number" && r.textContent !== "" + a && (i.suppressHydrationWarning !== true && oa(r.textContent, a, e), s = [
                "children",
                "" + a
              ]) : Qi.hasOwnProperty(o) && a != null && o === "onScroll" && pe("scroll", r);
            }
            switch (n) {
              case "input":
                Xo(r), zp(r, i, true);
                break;
              case "textarea":
                Xo(r), Up(r);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof i.onClick == "function" && (r.onclick = tl);
            }
            r = s, t.updateQueue = r, r !== null && (t.flags |= 4);
          } else {
            o = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = $v(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, {
              is: r.is
            }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = true : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[on] = t, e[ro] = r, hw(e, t, false, false), t.stateNode = e;
            e: {
              switch (o = Zc(n, r), n) {
                case "dialog":
                  pe("cancel", e), pe("close", e), s = r;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  pe("load", e), s = r;
                  break;
                case "video":
                case "audio":
                  for (s = 0; s < _i.length; s++) pe(_i[s], e);
                  s = r;
                  break;
                case "source":
                  pe("error", e), s = r;
                  break;
                case "img":
                case "image":
                case "link":
                  pe("error", e), pe("load", e), s = r;
                  break;
                case "details":
                  pe("toggle", e), s = r;
                  break;
                case "input":
                  Fp(e, r), s = Wc(e, r), pe("invalid", e);
                  break;
                case "option":
                  s = r;
                  break;
                case "select":
                  e._wrapperState = {
                    wasMultiple: !!r.multiple
                  }, s = Ce({}, r, {
                    value: void 0
                  }), pe("invalid", e);
                  break;
                case "textarea":
                  Bp(e, r), s = Qc(e, r), pe("invalid", e);
                  break;
                default:
                  s = r;
              }
              qc(n, s), a = s;
              for (i in a) if (a.hasOwnProperty(i)) {
                var l = a[i];
                i === "style" ? Kv(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Wv(e, l)) : i === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Gi(e, l) : typeof l == "number" && Gi(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (Qi.hasOwnProperty(i) ? l != null && i === "onScroll" && pe("scroll", e) : l != null && Rf(e, i, l, o));
              }
              switch (n) {
                case "input":
                  Xo(e), zp(e, r, false);
                  break;
                case "textarea":
                  Xo(e), Up(e);
                  break;
                case "option":
                  r.value != null && e.setAttribute("value", "" + cr(r.value));
                  break;
                case "select":
                  e.multiple = !!r.multiple, i = r.value, i != null ? Es(e, !!r.multiple, i, false) : r.defaultValue != null && Es(e, !!r.multiple, r.defaultValue, true);
                  break;
                default:
                  typeof s.onClick == "function" && (e.onclick = tl);
              }
              switch (n) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!r.autoFocus;
                  break e;
                case "img":
                  r = true;
                  break e;
                default:
                  r = false;
              }
            }
            r && (t.flags |= 4);
          }
          t.ref !== null && (t.flags |= 512, t.flags |= 2097152);
        }
        return Ye(t), null;
      case 6:
        if (e && t.stateNode != null) mw(e, t, e.memoizedProps, r);
        else {
          if (typeof r != "string" && t.stateNode === null) throw Error(N(166));
          if (n = Dr(io.current), Dr(cn.current), aa(t)) {
            if (r = t.stateNode, n = t.memoizedProps, r[on] = t, (i = r.nodeValue !== n) && (e = Ct, e !== null)) switch (e.tag) {
              case 3:
                oa(r.nodeValue, n, (e.mode & 1) !== 0);
                break;
              case 5:
                e.memoizedProps.suppressHydrationWarning !== true && oa(r.nodeValue, n, (e.mode & 1) !== 0);
            }
            i && (t.flags |= 4);
          } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[on] = t, t.stateNode = r;
        }
        return Ye(t), null;
      case 13:
        if (me(Se), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
          if (ve && Tt !== null && t.mode & 1 && !(t.flags & 128)) M0(), zs(), t.flags |= 98560, i = false;
          else if (i = aa(t), r !== null && r.dehydrated !== null) {
            if (e === null) {
              if (!i) throw Error(N(318));
              if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(N(317));
              i[on] = t;
            } else zs(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
            Ye(t), i = false;
          } else Kt !== null && (Rd(Kt), Kt = null), i = true;
          if (!i) return t.flags & 65536 ? t : null;
        }
        return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Se.current & 1 ? je === 0 && (je = 3) : fh())), t.updateQueue !== null && (t.flags |= 4), Ye(t), null);
      case 4:
        return Us(), bd(e, t), e === null && to(t.stateNode.containerInfo), Ye(t), null;
      case 10:
        return qf(t.type._context), Ye(t), null;
      case 17:
        return gt(t.type) && nl(), Ye(t), null;
      case 19:
        if (me(Se), i = t.memoizedState, i === null) return Ye(t), null;
        if (r = (t.flags & 128) !== 0, o = i.rendering, o === null) if (r) xi(i, false);
        else {
          if (je !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null; ) {
            if (o = ul(e), o !== null) {
              for (t.flags |= 128, xi(i, false), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null; ) i = n, e = r, i.flags &= 14680066, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : {
                lanes: e.lanes,
                firstContext: e.firstContext
              }), n = n.sibling;
              return de(Se, Se.current & 1 | 2), t.child;
            }
            e = e.sibling;
          }
          i.tail !== null && De() > Ws && (t.flags |= 128, r = true, xi(i, false), t.lanes = 4194304);
        }
        else {
          if (!r) if (e = ul(o), e !== null) {
            if (t.flags |= 128, r = true, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), xi(i, true), i.tail === null && i.tailMode === "hidden" && !o.alternate && !ve) return Ye(t), null;
          } else 2 * De() - i.renderingStartTime > Ws && n !== 1073741824 && (t.flags |= 128, r = true, xi(i, false), t.lanes = 4194304);
          i.isBackwards ? (o.sibling = t.child, t.child = o) : (n = i.last, n !== null ? n.sibling = o : t.child = o, i.last = o);
        }
        return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = De(), t.sibling = null, n = Se.current, de(Se, r ? n & 1 | 2 : n & 1), t) : (Ye(t), null);
      case 22:
      case 23:
        return dh(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? wt & 1073741824 && (Ye(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ye(t), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(N(156, t.tag));
  }
  function KE(e, t) {
    switch (Hf(t), t.tag) {
      case 1:
        return gt(t.type) && nl(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
      case 3:
        return Us(), me(mt), me(tt), eh(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
      case 5:
        return Jf(t), null;
      case 13:
        if (me(Se), e = t.memoizedState, e !== null && e.dehydrated !== null) {
          if (t.alternate === null) throw Error(N(340));
          zs();
        }
        return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
      case 19:
        return me(Se), null;
      case 4:
        return Us(), null;
      case 10:
        return qf(t.type._context), null;
      case 22:
      case 23:
        return dh(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ca = false, Je = false, QE = typeof WeakSet == "function" ? WeakSet : Set, z = null;
  function gs(e, t) {
    var n = e.ref;
    if (n !== null) if (typeof n == "function") try {
      n(null);
    } catch (r) {
      _e(e, t, r);
    }
    else n.current = null;
  }
  function Td(e, t, n) {
    try {
      n();
    } catch (r) {
      _e(e, t, r);
    }
  }
  var Nm = false;
  function GE(e, t) {
    if (od = Xa, e = x0(), $f(e)) {
      if ("selectionStart" in e) var n = {
        start: e.selectionStart,
        end: e.selectionEnd
      };
      else e: {
        n = (n = e.ownerDocument) && n.defaultView || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var s = r.anchorOffset, i = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, i.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0, a = -1, l = -1, u = 0, c = 0, d = e, f = null;
          t: for (; ; ) {
            for (var p; d !== n || s !== 0 && d.nodeType !== 3 || (a = o + s), d !== i || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (p = d.firstChild) !== null; ) f = d, d = p;
            for (; ; ) {
              if (d === e) break t;
              if (f === n && ++u === s && (a = o), f === i && ++c === r && (l = o), (p = d.nextSibling) !== null) break;
              d = f, f = d.parentNode;
            }
            d = p;
          }
          n = a === -1 || l === -1 ? null : {
            start: a,
            end: l
          };
        } else n = null;
      }
      n = n || {
        start: 0,
        end: 0
      };
    } else n = null;
    for (ad = {
      focusedElem: e,
      selectionRange: n
    }, Xa = false, z = t; z !== null; ) if (t = z, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, z = e;
    else for (; z !== null; ) {
      t = z;
      try {
        var w = t.alternate;
        if (t.flags & 1024) switch (t.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (w !== null) {
              var g = w.memoizedProps, x = w.memoizedState, m = t.stateNode, y = m.getSnapshotBeforeUpdate(t.elementType === t.type ? g : Ut(t.type, g), x);
              m.__reactInternalSnapshotBeforeUpdate = y;
            }
            break;
          case 3:
            var v = t.stateNode.containerInfo;
            v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(N(163));
        }
      } catch (b) {
        _e(t, t.return, b);
      }
      if (e = t.sibling, e !== null) {
        e.return = t.return, z = e;
        break;
      }
      z = t.return;
    }
    return w = Nm, Nm = false, w;
  }
  function Fi(e, t, n) {
    var r = t.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
      var s = r = r.next;
      do {
        if ((s.tag & e) === e) {
          var i = s.destroy;
          s.destroy = void 0, i !== void 0 && Td(t, n, i);
        }
        s = s.next;
      } while (s !== r);
    }
  }
  function eu(e, t) {
    if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
      var n = t = t.next;
      do {
        if ((n.tag & e) === e) {
          var r = n.create;
          n.destroy = r();
        }
        n = n.next;
      } while (n !== t);
    }
  }
  function Cd(e) {
    var t = e.ref;
    if (t !== null) {
      var n = e.stateNode;
      switch (e.tag) {
        case 5:
          e = n;
          break;
        default:
          e = n;
      }
      typeof t == "function" ? t(e) : t.current = e;
    }
  }
  function gw(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null, gw(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[on], delete t[ro], delete t[cd], delete t[RE], delete t[NE])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
  }
  function yw(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4;
  }
  function Dm(e) {
    e: for (; ; ) {
      for (; e.sibling === null; ) {
        if (e.return === null || yw(e.return)) return null;
        e = e.return;
      }
      for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
        if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
        e.child.return = e, e = e.child;
      }
      if (!(e.flags & 2)) return e.stateNode;
    }
  }
  function Ed(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = tl));
    else if (r !== 4 && (e = e.child, e !== null)) for (Ed(e, t, n), e = e.sibling; e !== null; ) Ed(e, t, n), e = e.sibling;
  }
  function Pd(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
    else if (r !== 4 && (e = e.child, e !== null)) for (Pd(e, t, n), e = e.sibling; e !== null; ) Pd(e, t, n), e = e.sibling;
  }
  var We = null, Wt = false;
  function Wn(e, t, n) {
    for (n = n.child; n !== null; ) vw(e, t, n), n = n.sibling;
  }
  function vw(e, t, n) {
    if (un && typeof un.onCommitFiberUnmount == "function") try {
      un.onCommitFiberUnmount(Kl, n);
    } catch {
    }
    switch (n.tag) {
      case 5:
        Je || gs(n, t);
      case 6:
        var r = We, s = Wt;
        We = null, Wn(e, t, n), We = r, Wt = s, We !== null && (Wt ? (e = We, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : We.removeChild(n.stateNode));
        break;
      case 18:
        We !== null && (Wt ? (e = We, n = n.stateNode, e.nodeType === 8 ? Qu(e.parentNode, n) : e.nodeType === 1 && Qu(e, n), Xi(e)) : Qu(We, n.stateNode));
        break;
      case 4:
        r = We, s = Wt, We = n.stateNode.containerInfo, Wt = true, Wn(e, t, n), We = r, Wt = s;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Je && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
          s = r = r.next;
          do {
            var i = s, o = i.destroy;
            i = i.tag, o !== void 0 && (i & 2 || i & 4) && Td(n, t, o), s = s.next;
          } while (s !== r);
        }
        Wn(e, t, n);
        break;
      case 1:
        if (!Je && (gs(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
          r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount();
        } catch (a) {
          _e(n, t, a);
        }
        Wn(e, t, n);
        break;
      case 21:
        Wn(e, t, n);
        break;
      case 22:
        n.mode & 1 ? (Je = (r = Je) || n.memoizedState !== null, Wn(e, t, n), Je = r) : Wn(e, t, n);
        break;
      default:
        Wn(e, t, n);
    }
  }
  function Mm(e) {
    var t = e.updateQueue;
    if (t !== null) {
      e.updateQueue = null;
      var n = e.stateNode;
      n === null && (n = e.stateNode = new QE()), t.forEach(function(r) {
        var s = rP.bind(null, e, r);
        n.has(r) || (n.add(r), r.then(s, s));
      });
    }
  }
  function zt(e, t) {
    var n = t.deletions;
    if (n !== null) for (var r = 0; r < n.length; r++) {
      var s = n[r];
      try {
        var i = e, o = t, a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              We = a.stateNode, Wt = false;
              break e;
            case 3:
              We = a.stateNode.containerInfo, Wt = true;
              break e;
            case 4:
              We = a.stateNode.containerInfo, Wt = true;
              break e;
          }
          a = a.return;
        }
        if (We === null) throw Error(N(160));
        vw(i, o, s), We = null, Wt = false;
        var l = s.alternate;
        l !== null && (l.return = null), s.return = null;
      } catch (u) {
        _e(s, t, u);
      }
    }
    if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) ww(t, e), t = t.sibling;
  }
  function ww(e, t) {
    var n = e.alternate, r = e.flags;
    switch (e.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (zt(t, e), rn(e), r & 4) {
          try {
            Fi(3, e, e.return), eu(3, e);
          } catch (g) {
            _e(e, e.return, g);
          }
          try {
            Fi(5, e, e.return);
          } catch (g) {
            _e(e, e.return, g);
          }
        }
        break;
      case 1:
        zt(t, e), rn(e), r & 512 && n !== null && gs(n, n.return);
        break;
      case 5:
        if (zt(t, e), rn(e), r & 512 && n !== null && gs(n, n.return), e.flags & 32) {
          var s = e.stateNode;
          try {
            Gi(s, "");
          } catch (g) {
            _e(e, e.return, g);
          }
        }
        if (r & 4 && (s = e.stateNode, s != null)) {
          var i = e.memoizedProps, o = n !== null ? n.memoizedProps : i, a = e.type, l = e.updateQueue;
          if (e.updateQueue = null, l !== null) try {
            a === "input" && i.type === "radio" && i.name != null && Bv(s, i), Zc(a, o);
            var u = Zc(a, i);
            for (o = 0; o < l.length; o += 2) {
              var c = l[o], d = l[o + 1];
              c === "style" ? Kv(s, d) : c === "dangerouslySetInnerHTML" ? Wv(s, d) : c === "children" ? Gi(s, d) : Rf(s, c, d, u);
            }
            switch (a) {
              case "input":
                Hc(s, i);
                break;
              case "textarea":
                Uv(s, i);
                break;
              case "select":
                var f = s._wrapperState.wasMultiple;
                s._wrapperState.wasMultiple = !!i.multiple;
                var p = i.value;
                p != null ? Es(s, !!i.multiple, p, false) : f !== !!i.multiple && (i.defaultValue != null ? Es(s, !!i.multiple, i.defaultValue, true) : Es(s, !!i.multiple, i.multiple ? [] : "", false));
            }
            s[ro] = i;
          } catch (g) {
            _e(e, e.return, g);
          }
        }
        break;
      case 6:
        if (zt(t, e), rn(e), r & 4) {
          if (e.stateNode === null) throw Error(N(162));
          s = e.stateNode, i = e.memoizedProps;
          try {
            s.nodeValue = i;
          } catch (g) {
            _e(e, e.return, g);
          }
        }
        break;
      case 3:
        if (zt(t, e), rn(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
          Xi(t.containerInfo);
        } catch (g) {
          _e(e, e.return, g);
        }
        break;
      case 4:
        zt(t, e), rn(e);
        break;
      case 13:
        zt(t, e), rn(e), s = e.child, s.flags & 8192 && (i = s.memoizedState !== null, s.stateNode.isHidden = i, !i || s.alternate !== null && s.alternate.memoizedState !== null || (uh = De())), r & 4 && Mm(e);
        break;
      case 22:
        if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (Je = (u = Je) || c, zt(t, e), Je = u) : zt(t, e), rn(e), r & 8192) {
          if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (z = e, c = e.child; c !== null; ) {
            for (d = z = c; z !== null; ) {
              switch (f = z, p = f.child, f.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Fi(4, f, f.return);
                  break;
                case 1:
                  gs(f, f.return);
                  var w = f.stateNode;
                  if (typeof w.componentWillUnmount == "function") {
                    r = f, n = f.return;
                    try {
                      t = r, w.props = t.memoizedProps, w.state = t.memoizedState, w.componentWillUnmount();
                    } catch (g) {
                      _e(r, n, g);
                    }
                  }
                  break;
                case 5:
                  gs(f, f.return);
                  break;
                case 22:
                  if (f.memoizedState !== null) {
                    Im(d);
                    continue;
                  }
              }
              p !== null ? (p.return = f, z = p) : Im(d);
            }
            c = c.sibling;
          }
          e: for (c = null, d = e; ; ) {
            if (d.tag === 5) {
              if (c === null) {
                c = d;
                try {
                  s = d.stateNode, u ? (i = s.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Hv("display", o));
                } catch (g) {
                  _e(e, e.return, g);
                }
              }
            } else if (d.tag === 6) {
              if (c === null) try {
                d.stateNode.nodeValue = u ? "" : d.memoizedProps;
              } catch (g) {
                _e(e, e.return, g);
              }
            } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) {
              d.child.return = d, d = d.child;
              continue;
            }
            if (d === e) break e;
            for (; d.sibling === null; ) {
              if (d.return === null || d.return === e) break e;
              c === d && (c = null), d = d.return;
            }
            c === d && (c = null), d.sibling.return = d.return, d = d.sibling;
          }
        }
        break;
      case 19:
        zt(t, e), rn(e), r & 4 && Mm(e);
        break;
      case 21:
        break;
      default:
        zt(t, e), rn(e);
    }
  }
  function rn(e) {
    var t = e.flags;
    if (t & 2) {
      try {
        e: {
          for (var n = e.return; n !== null; ) {
            if (yw(n)) {
              var r = n;
              break e;
            }
            n = n.return;
          }
          throw Error(N(160));
        }
        switch (r.tag) {
          case 5:
            var s = r.stateNode;
            r.flags & 32 && (Gi(s, ""), r.flags &= -33);
            var i = Dm(e);
            Pd(e, i, s);
            break;
          case 3:
          case 4:
            var o = r.stateNode.containerInfo, a = Dm(e);
            Ed(e, a, o);
            break;
          default:
            throw Error(N(161));
        }
      } catch (l) {
        _e(e, e.return, l);
      }
      e.flags &= -3;
    }
    t & 4096 && (e.flags &= -4097);
  }
  function qE(e, t, n) {
    z = e, xw(e);
  }
  function xw(e, t, n) {
    for (var r = (e.mode & 1) !== 0; z !== null; ) {
      var s = z, i = s.child;
      if (s.tag === 22 && r) {
        var o = s.memoizedState !== null || ca;
        if (!o) {
          var a = s.alternate, l = a !== null && a.memoizedState !== null || Je;
          a = ca;
          var u = Je;
          if (ca = o, (Je = l) && !u) for (z = s; z !== null; ) o = z, l = o.child, o.tag === 22 && o.memoizedState !== null ? Lm(s) : l !== null ? (l.return = o, z = l) : Lm(s);
          for (; i !== null; ) z = i, xw(i), i = i.sibling;
          z = s, ca = a, Je = u;
        }
        Om(e);
      } else s.subtreeFlags & 8772 && i !== null ? (i.return = s, z = i) : Om(e);
    }
  }
  function Om(e) {
    for (; z !== null; ) {
      var t = z;
      if (t.flags & 8772) {
        var n = t.alternate;
        try {
          if (t.flags & 8772) switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Je || eu(5, t);
              break;
            case 1:
              var r = t.stateNode;
              if (t.flags & 4 && !Je) if (n === null) r.componentDidMount();
              else {
                var s = t.elementType === t.type ? n.memoizedProps : Ut(t.type, n.memoizedProps);
                r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
              }
              var i = t.updateQueue;
              i !== null && vm(t, i, r);
              break;
            case 3:
              var o = t.updateQueue;
              if (o !== null) {
                if (n = null, t.child !== null) switch (t.child.tag) {
                  case 5:
                    n = t.child.stateNode;
                    break;
                  case 1:
                    n = t.child.stateNode;
                }
                vm(t, o, n);
              }
              break;
            case 5:
              var a = t.stateNode;
              if (n === null && t.flags & 4) {
                n = a;
                var l = t.memoizedProps;
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (t.memoizedState === null) {
                var u = t.alternate;
                if (u !== null) {
                  var c = u.memoizedState;
                  if (c !== null) {
                    var d = c.dehydrated;
                    d !== null && Xi(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(N(163));
          }
          Je || t.flags & 512 && Cd(t);
        } catch (f) {
          _e(t, t.return, f);
        }
      }
      if (t === e) {
        z = null;
        break;
      }
      if (n = t.sibling, n !== null) {
        n.return = t.return, z = n;
        break;
      }
      z = t.return;
    }
  }
  function Im(e) {
    for (; z !== null; ) {
      var t = z;
      if (t === e) {
        z = null;
        break;
      }
      var n = t.sibling;
      if (n !== null) {
        n.return = t.return, z = n;
        break;
      }
      z = t.return;
    }
  }
  function Lm(e) {
    for (; z !== null; ) {
      var t = z;
      try {
        switch (t.tag) {
          case 0:
          case 11:
          case 15:
            var n = t.return;
            try {
              eu(4, t);
            } catch (l) {
              _e(t, n, l);
            }
            break;
          case 1:
            var r = t.stateNode;
            if (typeof r.componentDidMount == "function") {
              var s = t.return;
              try {
                r.componentDidMount();
              } catch (l) {
                _e(t, s, l);
              }
            }
            var i = t.return;
            try {
              Cd(t);
            } catch (l) {
              _e(t, i, l);
            }
            break;
          case 5:
            var o = t.return;
            try {
              Cd(t);
            } catch (l) {
              _e(t, o, l);
            }
        }
      } catch (l) {
        _e(t, t.return, l);
      }
      if (t === e) {
        z = null;
        break;
      }
      var a = t.sibling;
      if (a !== null) {
        a.return = t.return, z = a;
        break;
      }
      z = t.return;
    }
  }
  var ZE = Math.ceil, fl = Un.ReactCurrentDispatcher, ah = Un.ReactCurrentOwner, jt = Un.ReactCurrentBatchConfig, ie = 0, Be = null, Oe = null, Qe = 0, wt = 0, ys = Sr(0), je = 0, uo = null, Ur = 0, tu = 0, lh = 0, zi = null, ht = null, uh = 0, Ws = 1 / 0, Tn = null, hl = false, kd = null, or = null, da = false, er = null, pl = 0, Bi = 0, _d = null, La = -1, ja = 0;
  function ot() {
    return ie & 6 ? De() : La !== -1 ? La : La = De();
  }
  function ar(e) {
    return e.mode & 1 ? ie & 2 && Qe !== 0 ? Qe & -Qe : ME.transition !== null ? (ja === 0 && (ja = s0()), ja) : (e = ue, e !== 0 || (e = window.event, e = e === void 0 ? 16 : d0(e.type)), e) : 1;
  }
  function qt(e, t, n, r) {
    if (50 < Bi) throw Bi = 0, _d = null, Error(N(185));
    Io(e, n, r), (!(ie & 2) || e !== Be) && (e === Be && (!(ie & 2) && (tu |= n), je === 4 && Xn(e, Qe)), yt(e, r), n === 1 && ie === 0 && !(t.mode & 1) && (Ws = De() + 500, Yl && br()));
  }
  function yt(e, t) {
    var n = e.callbackNode;
    MC(e, t);
    var r = Ya(e, e === Be ? Qe : 0);
    if (r === 0) n !== null && Hp(n), e.callbackNode = null, e.callbackPriority = 0;
    else if (t = r & -r, e.callbackPriority !== t) {
      if (n != null && Hp(n), t === 1) e.tag === 0 ? DE(jm.bind(null, e)) : R0(jm.bind(null, e)), _E(function() {
        !(ie & 6) && br();
      }), n = null;
      else {
        switch (i0(r)) {
          case 1:
            n = If;
            break;
          case 4:
            n = n0;
            break;
          case 16:
            n = Za;
            break;
          case 536870912:
            n = r0;
            break;
          default:
            n = Za;
        }
        n = _w(n, Sw.bind(null, e));
      }
      e.callbackPriority = t, e.callbackNode = n;
    }
  }
  function Sw(e, t) {
    if (La = -1, ja = 0, ie & 6) throw Error(N(327));
    var n = e.callbackNode;
    if (Rs() && e.callbackNode !== n) return null;
    var r = Ya(e, e === Be ? Qe : 0);
    if (r === 0) return null;
    if (r & 30 || r & e.expiredLanes || t) t = ml(e, r);
    else {
      t = r;
      var s = ie;
      ie |= 2;
      var i = Tw();
      (Be !== e || Qe !== t) && (Tn = null, Ws = De() + 500, Ir(e, t));
      do
        try {
          JE();
          break;
        } catch (a) {
          bw(e, a);
        }
      while (true);
      Gf(), fl.current = i, ie = s, Oe !== null ? t = 0 : (Be = null, Qe = 0, t = je);
    }
    if (t !== 0) {
      if (t === 2 && (s = td(e), s !== 0 && (r = s, t = Ad(e, s))), t === 1) throw n = uo, Ir(e, 0), Xn(e, r), yt(e, De()), n;
      if (t === 6) Xn(e, r);
      else {
        if (s = e.current.alternate, !(r & 30) && !YE(s) && (t = ml(e, r), t === 2 && (i = td(e), i !== 0 && (r = i, t = Ad(e, i))), t === 1)) throw n = uo, Ir(e, 0), Xn(e, r), yt(e, De()), n;
        switch (e.finishedWork = s, e.finishedLanes = r, t) {
          case 0:
          case 1:
            throw Error(N(345));
          case 2:
            kr(e, ht, Tn);
            break;
          case 3:
            if (Xn(e, r), (r & 130023424) === r && (t = uh + 500 - De(), 10 < t)) {
              if (Ya(e, 0) !== 0) break;
              if (s = e.suspendedLanes, (s & r) !== r) {
                ot(), e.pingedLanes |= e.suspendedLanes & s;
                break;
              }
              e.timeoutHandle = ud(kr.bind(null, e, ht, Tn), t);
              break;
            }
            kr(e, ht, Tn);
            break;
          case 4:
            if (Xn(e, r), (r & 4194240) === r) break;
            for (t = e.eventTimes, s = -1; 0 < r; ) {
              var o = 31 - Gt(r);
              i = 1 << o, o = t[o], o > s && (s = o), r &= ~i;
            }
            if (r = s, r = De() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * ZE(r / 1960)) - r, 10 < r) {
              e.timeoutHandle = ud(kr.bind(null, e, ht, Tn), r);
              break;
            }
            kr(e, ht, Tn);
            break;
          case 5:
            kr(e, ht, Tn);
            break;
          default:
            throw Error(N(329));
        }
      }
    }
    return yt(e, De()), e.callbackNode === n ? Sw.bind(null, e) : null;
  }
  function Ad(e, t) {
    var n = zi;
    return e.current.memoizedState.isDehydrated && (Ir(e, t).flags |= 256), e = ml(e, t), e !== 2 && (t = ht, ht = n, t !== null && Rd(t)), e;
  }
  function Rd(e) {
    ht === null ? ht = e : ht.push.apply(ht, e);
  }
  function YE(e) {
    for (var t = e; ; ) {
      if (t.flags & 16384) {
        var n = t.updateQueue;
        if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) {
          var s = n[r], i = s.getSnapshot;
          s = s.value;
          try {
            if (!Yt(i(), s)) return false;
          } catch {
            return false;
          }
        }
      }
      if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
      else {
        if (t === e) break;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) return true;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
    }
    return true;
  }
  function Xn(e, t) {
    for (t &= ~lh, t &= ~tu, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t; ) {
      var n = 31 - Gt(t), r = 1 << n;
      e[n] = -1, t &= ~r;
    }
  }
  function jm(e) {
    if (ie & 6) throw Error(N(327));
    Rs();
    var t = Ya(e, 0);
    if (!(t & 1)) return yt(e, De()), null;
    var n = ml(e, t);
    if (e.tag !== 0 && n === 2) {
      var r = td(e);
      r !== 0 && (t = r, n = Ad(e, r));
    }
    if (n === 1) throw n = uo, Ir(e, 0), Xn(e, t), yt(e, De()), n;
    if (n === 6) throw Error(N(345));
    return e.finishedWork = e.current.alternate, e.finishedLanes = t, kr(e, ht, Tn), yt(e, De()), null;
  }
  function ch(e, t) {
    var n = ie;
    ie |= 1;
    try {
      return e(t);
    } finally {
      ie = n, ie === 0 && (Ws = De() + 500, Yl && br());
    }
  }
  function $r(e) {
    er !== null && er.tag === 0 && !(ie & 6) && Rs();
    var t = ie;
    ie |= 1;
    var n = jt.transition, r = ue;
    try {
      if (jt.transition = null, ue = 1, e) return e();
    } finally {
      ue = r, jt.transition = n, ie = t, !(ie & 6) && br();
    }
  }
  function dh() {
    wt = ys.current, me(ys);
  }
  function Ir(e, t) {
    e.finishedWork = null, e.finishedLanes = 0;
    var n = e.timeoutHandle;
    if (n !== -1 && (e.timeoutHandle = -1, kE(n)), Oe !== null) for (n = Oe.return; n !== null; ) {
      var r = n;
      switch (Hf(r), r.tag) {
        case 1:
          r = r.type.childContextTypes, r != null && nl();
          break;
        case 3:
          Us(), me(mt), me(tt), eh();
          break;
        case 5:
          Jf(r);
          break;
        case 4:
          Us();
          break;
        case 13:
          me(Se);
          break;
        case 19:
          me(Se);
          break;
        case 10:
          qf(r.type._context);
          break;
        case 22:
        case 23:
          dh();
      }
      n = n.return;
    }
    if (Be = e, Oe = e = lr(e.current, null), Qe = wt = t, je = 0, uo = null, lh = tu = Ur = 0, ht = zi = null, Nr !== null) {
      for (t = 0; t < Nr.length; t++) if (n = Nr[t], r = n.interleaved, r !== null) {
        n.interleaved = null;
        var s = r.next, i = n.pending;
        if (i !== null) {
          var o = i.next;
          i.next = s, r.next = o;
        }
        n.pending = r;
      }
      Nr = null;
    }
    return e;
  }
  function bw(e, t) {
    do {
      var n = Oe;
      try {
        if (Gf(), Ma.current = dl, cl) {
          for (var r = Te.memoizedState; r !== null; ) {
            var s = r.queue;
            s !== null && (s.pending = null), r = r.next;
          }
          cl = false;
        }
        if (Br = 0, ze = Ie = Te = null, Vi = false, oo = 0, ah.current = null, n === null || n.return === null) {
          je = 1, uo = t, Oe = null;
          break;
        }
        e: {
          var i = e, o = n.return, a = n, l = t;
          if (t = Qe, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
            var u = l, c = a, d = c.tag;
            if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
              var f = c.alternate;
              f ? (c.updateQueue = f.updateQueue, c.memoizedState = f.memoizedState, c.lanes = f.lanes) : (c.updateQueue = null, c.memoizedState = null);
            }
            var p = Cm(o);
            if (p !== null) {
              p.flags &= -257, Em(p, o, a, i, t), p.mode & 1 && Tm(i, u, t), t = p, l = u;
              var w = t.updateQueue;
              if (w === null) {
                var g = /* @__PURE__ */ new Set();
                g.add(l), t.updateQueue = g;
              } else w.add(l);
              break e;
            } else {
              if (!(t & 1)) {
                Tm(i, u, t), fh();
                break e;
              }
              l = Error(N(426));
            }
          } else if (ve && a.mode & 1) {
            var x = Cm(o);
            if (x !== null) {
              !(x.flags & 65536) && (x.flags |= 256), Em(x, o, a, i, t), Kf($s(l, a));
              break e;
            }
          }
          i = l = $s(l, a), je !== 4 && (je = 2), zi === null ? zi = [
            i
          ] : zi.push(i), i = o;
          do {
            switch (i.tag) {
              case 3:
                i.flags |= 65536, t &= -t, i.lanes |= t;
                var m = iw(i, l, t);
                ym(i, m);
                break e;
              case 1:
                a = l;
                var y = i.type, v = i.stateNode;
                if (!(i.flags & 128) && (typeof y.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (or === null || !or.has(v)))) {
                  i.flags |= 65536, t &= -t, i.lanes |= t;
                  var b = ow(i, a, t);
                  ym(i, b);
                  break e;
                }
            }
            i = i.return;
          } while (i !== null);
        }
        Ew(n);
      } catch (T) {
        t = T, Oe === n && n !== null && (Oe = n = n.return);
        continue;
      }
      break;
    } while (true);
  }
  function Tw() {
    var e = fl.current;
    return fl.current = dl, e === null ? dl : e;
  }
  function fh() {
    (je === 0 || je === 3 || je === 2) && (je = 4), Be === null || !(Ur & 268435455) && !(tu & 268435455) || Xn(Be, Qe);
  }
  function ml(e, t) {
    var n = ie;
    ie |= 2;
    var r = Tw();
    (Be !== e || Qe !== t) && (Tn = null, Ir(e, t));
    do
      try {
        XE();
        break;
      } catch (s) {
        bw(e, s);
      }
    while (true);
    if (Gf(), ie = n, fl.current = r, Oe !== null) throw Error(N(261));
    return Be = null, Qe = 0, je;
  }
  function XE() {
    for (; Oe !== null; ) Cw(Oe);
  }
  function JE() {
    for (; Oe !== null && !CC(); ) Cw(Oe);
  }
  function Cw(e) {
    var t = kw(e.alternate, e, wt);
    e.memoizedProps = e.pendingProps, t === null ? Ew(e) : Oe = t, ah.current = null;
  }
  function Ew(e) {
    var t = e;
    do {
      var n = t.alternate;
      if (e = t.return, t.flags & 32768) {
        if (n = KE(n, t), n !== null) {
          n.flags &= 32767, Oe = n;
          return;
        }
        if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
        else {
          je = 6, Oe = null;
          return;
        }
      } else if (n = HE(n, t, wt), n !== null) {
        Oe = n;
        return;
      }
      if (t = t.sibling, t !== null) {
        Oe = t;
        return;
      }
      Oe = t = e;
    } while (t !== null);
    je === 0 && (je = 5);
  }
  function kr(e, t, n) {
    var r = ue, s = jt.transition;
    try {
      jt.transition = null, ue = 1, eP(e, t, n, r);
    } finally {
      jt.transition = s, ue = r;
    }
    return null;
  }
  function eP(e, t, n, r) {
    do
      Rs();
    while (er !== null);
    if (ie & 6) throw Error(N(327));
    n = e.finishedWork;
    var s = e.finishedLanes;
    if (n === null) return null;
    if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(N(177));
    e.callbackNode = null, e.callbackPriority = 0;
    var i = n.lanes | n.childLanes;
    if (OC(e, i), e === Be && (Oe = Be = null, Qe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || da || (da = true, _w(Za, function() {
      return Rs(), null;
    })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) {
      i = jt.transition, jt.transition = null;
      var o = ue;
      ue = 1;
      var a = ie;
      ie |= 4, ah.current = null, GE(e, n), ww(n, e), xE(ad), Xa = !!od, ad = od = null, e.current = n, qE(n), EC(), ie = a, ue = o, jt.transition = i;
    } else e.current = n;
    if (da && (da = false, er = e, pl = s), i = e.pendingLanes, i === 0 && (or = null), _C(n.stateNode), yt(e, De()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++) s = t[n], r(s.value, {
      componentStack: s.stack,
      digest: s.digest
    });
    if (hl) throw hl = false, e = kd, kd = null, e;
    return pl & 1 && e.tag !== 0 && Rs(), i = e.pendingLanes, i & 1 ? e === _d ? Bi++ : (Bi = 0, _d = e) : Bi = 0, br(), null;
  }
  function Rs() {
    if (er !== null) {
      var e = i0(pl), t = jt.transition, n = ue;
      try {
        if (jt.transition = null, ue = 16 > e ? 16 : e, er === null) var r = false;
        else {
          if (e = er, er = null, pl = 0, ie & 6) throw Error(N(331));
          var s = ie;
          for (ie |= 4, z = e.current; z !== null; ) {
            var i = z, o = i.child;
            if (z.flags & 16) {
              var a = i.deletions;
              if (a !== null) {
                for (var l = 0; l < a.length; l++) {
                  var u = a[l];
                  for (z = u; z !== null; ) {
                    var c = z;
                    switch (c.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Fi(8, c, i);
                    }
                    var d = c.child;
                    if (d !== null) d.return = c, z = d;
                    else for (; z !== null; ) {
                      c = z;
                      var f = c.sibling, p = c.return;
                      if (gw(c), c === u) {
                        z = null;
                        break;
                      }
                      if (f !== null) {
                        f.return = p, z = f;
                        break;
                      }
                      z = p;
                    }
                  }
                }
                var w = i.alternate;
                if (w !== null) {
                  var g = w.child;
                  if (g !== null) {
                    w.child = null;
                    do {
                      var x = g.sibling;
                      g.sibling = null, g = x;
                    } while (g !== null);
                  }
                }
                z = i;
              }
            }
            if (i.subtreeFlags & 2064 && o !== null) o.return = i, z = o;
            else e: for (; z !== null; ) {
              if (i = z, i.flags & 2048) switch (i.tag) {
                case 0:
                case 11:
                case 15:
                  Fi(9, i, i.return);
              }
              var m = i.sibling;
              if (m !== null) {
                m.return = i.return, z = m;
                break e;
              }
              z = i.return;
            }
          }
          var y = e.current;
          for (z = y; z !== null; ) {
            o = z;
            var v = o.child;
            if (o.subtreeFlags & 2064 && v !== null) v.return = o, z = v;
            else e: for (o = y; z !== null; ) {
              if (a = z, a.flags & 2048) try {
                switch (a.tag) {
                  case 0:
                  case 11:
                  case 15:
                    eu(9, a);
                }
              } catch (T) {
                _e(a, a.return, T);
              }
              if (a === o) {
                z = null;
                break e;
              }
              var b = a.sibling;
              if (b !== null) {
                b.return = a.return, z = b;
                break e;
              }
              z = a.return;
            }
          }
          if (ie = s, br(), un && typeof un.onPostCommitFiberRoot == "function") try {
            un.onPostCommitFiberRoot(Kl, e);
          } catch {
          }
          r = true;
        }
        return r;
      } finally {
        ue = n, jt.transition = t;
      }
    }
    return false;
  }
  function Vm(e, t, n) {
    t = $s(n, t), t = iw(e, t, 1), e = ir(e, t, 1), t = ot(), e !== null && (Io(e, 1, t), yt(e, t));
  }
  function _e(e, t, n) {
    if (e.tag === 3) Vm(e, e, n);
    else for (; t !== null; ) {
      if (t.tag === 3) {
        Vm(t, e, n);
        break;
      } else if (t.tag === 1) {
        var r = t.stateNode;
        if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (or === null || !or.has(r))) {
          e = $s(n, e), e = ow(t, e, 1), t = ir(t, e, 1), e = ot(), t !== null && (Io(t, 1, e), yt(t, e));
          break;
        }
      }
      t = t.return;
    }
  }
  function tP(e, t, n) {
    var r = e.pingCache;
    r !== null && r.delete(t), t = ot(), e.pingedLanes |= e.suspendedLanes & n, Be === e && (Qe & n) === n && (je === 4 || je === 3 && (Qe & 130023424) === Qe && 500 > De() - uh ? Ir(e, 0) : lh |= n), yt(e, t);
  }
  function Pw(e, t) {
    t === 0 && (e.mode & 1 ? (t = ta, ta <<= 1, !(ta & 130023424) && (ta = 4194304)) : t = 1);
    var n = ot();
    e = In(e, t), e !== null && (Io(e, t, n), yt(e, n));
  }
  function nP(e) {
    var t = e.memoizedState, n = 0;
    t !== null && (n = t.retryLane), Pw(e, n);
  }
  function rP(e, t) {
    var n = 0;
    switch (e.tag) {
      case 13:
        var r = e.stateNode, s = e.memoizedState;
        s !== null && (n = s.retryLane);
        break;
      case 19:
        r = e.stateNode;
        break;
      default:
        throw Error(N(314));
    }
    r !== null && r.delete(t), Pw(e, n);
  }
  var kw;
  kw = function(e, t, n) {
    if (e !== null) if (e.memoizedProps !== t.pendingProps || mt.current) pt = true;
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return pt = false, WE(e, t, n);
      pt = !!(e.flags & 131072);
    }
    else pt = false, ve && t.flags & 1048576 && N0(t, il, t.index);
    switch (t.lanes = 0, t.tag) {
      case 2:
        var r = t.type;
        Ia(e, t), e = t.pendingProps;
        var s = Fs(t, tt.current);
        As(t, n), s = nh(null, t, r, e, s, n);
        var i = rh();
        return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, gt(r) ? (i = true, rl(t)) : i = false, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, Yf(t), s.updater = Jl, t.stateNode = s, s._reactInternals = t, gd(t, r, e, n), t = wd(null, t, r, true, i, n)) : (t.tag = 0, ve && i && Wf(t), st(null, t, s, n), t = t.child), t;
      case 16:
        r = t.elementType;
        e: {
          switch (Ia(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = iP(r), e = Ut(r, e), s) {
            case 0:
              t = vd(null, t, r, e, n);
              break e;
            case 1:
              t = _m(null, t, r, e, n);
              break e;
            case 11:
              t = Pm(null, t, r, e, n);
              break e;
            case 14:
              t = km(null, t, r, Ut(r.type, e), n);
              break e;
          }
          throw Error(N(306, r, ""));
        }
        return t;
      case 0:
        return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ut(r, s), vd(e, t, r, s, n);
      case 1:
        return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ut(r, s), _m(e, t, r, s, n);
      case 3:
        e: {
          if (cw(t), e === null) throw Error(N(387));
          r = t.pendingProps, i = t.memoizedState, s = i.element, j0(e, t), ll(t, r, null, n);
          var o = t.memoizedState;
          if (r = o.element, i.isDehydrated) if (i = {
            element: r,
            isDehydrated: false,
            cache: o.cache,
            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
            transitions: o.transitions
          }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) {
            s = $s(Error(N(423)), t), t = Am(e, t, r, n, s);
            break e;
          } else if (r !== s) {
            s = $s(Error(N(424)), t), t = Am(e, t, r, n, s);
            break e;
          } else for (Tt = sr(t.stateNode.containerInfo.firstChild), Ct = t, ve = true, Kt = null, n = I0(t, null, r, n), t.child = n; n; ) n.flags = n.flags & -3 | 4096, n = n.sibling;
          else {
            if (zs(), r === s) {
              t = Ln(e, t, n);
              break e;
            }
            st(e, t, r, n);
          }
          t = t.child;
        }
        return t;
      case 5:
        return V0(t), e === null && hd(t), r = t.type, s = t.pendingProps, i = e !== null ? e.memoizedProps : null, o = s.children, ld(r, s) ? o = null : i !== null && ld(r, i) && (t.flags |= 32), uw(e, t), st(e, t, o, n), t.child;
      case 6:
        return e === null && hd(t), null;
      case 13:
        return dw(e, t, n);
      case 4:
        return Xf(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Bs(t, null, r, n) : st(e, t, r, n), t.child;
      case 11:
        return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ut(r, s), Pm(e, t, r, s, n);
      case 7:
        return st(e, t, t.pendingProps, n), t.child;
      case 8:
        return st(e, t, t.pendingProps.children, n), t.child;
      case 12:
        return st(e, t, t.pendingProps.children, n), t.child;
      case 10:
        e: {
          if (r = t.type._context, s = t.pendingProps, i = t.memoizedProps, o = s.value, de(ol, r._currentValue), r._currentValue = o, i !== null) if (Yt(i.value, o)) {
            if (i.children === s.children && !mt.current) {
              t = Ln(e, t, n);
              break e;
            }
          } else for (i = t.child, i !== null && (i.return = t); i !== null; ) {
            var a = i.dependencies;
            if (a !== null) {
              o = i.child;
              for (var l = a.firstContext; l !== null; ) {
                if (l.context === r) {
                  if (i.tag === 1) {
                    l = Rn(-1, n & -n), l.tag = 2;
                    var u = i.updateQueue;
                    if (u !== null) {
                      u = u.shared;
                      var c = u.pending;
                      c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l;
                    }
                  }
                  i.lanes |= n, l = i.alternate, l !== null && (l.lanes |= n), pd(i.return, n, t), a.lanes |= n;
                  break;
                }
                l = l.next;
              }
            } else if (i.tag === 10) o = i.type === t.type ? null : i.child;
            else if (i.tag === 18) {
              if (o = i.return, o === null) throw Error(N(341));
              o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), pd(o, n, t), o = i.sibling;
            } else o = i.child;
            if (o !== null) o.return = i;
            else for (o = i; o !== null; ) {
              if (o === t) {
                o = null;
                break;
              }
              if (i = o.sibling, i !== null) {
                i.return = o.return, o = i;
                break;
              }
              o = o.return;
            }
            i = o;
          }
          st(e, t, s.children, n), t = t.child;
        }
        return t;
      case 9:
        return s = t.type, r = t.pendingProps.children, As(t, n), s = Vt(s), r = r(s), t.flags |= 1, st(e, t, r, n), t.child;
      case 14:
        return r = t.type, s = Ut(r, t.pendingProps), s = Ut(r.type, s), km(e, t, r, s, n);
      case 15:
        return aw(e, t, t.type, t.pendingProps, n);
      case 17:
        return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ut(r, s), Ia(e, t), t.tag = 1, gt(r) ? (e = true, rl(t)) : e = false, As(t, n), sw(t, r, s), gd(t, r, s, n), wd(null, t, r, true, e, n);
      case 19:
        return fw(e, t, n);
      case 22:
        return lw(e, t, n);
    }
    throw Error(N(156, t.tag));
  };
  function _w(e, t) {
    return t0(e, t);
  }
  function sP(e, t, n, r) {
    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Lt(e, t, n, r) {
    return new sP(e, t, n, r);
  }
  function hh(e) {
    return e = e.prototype, !(!e || !e.isReactComponent);
  }
  function iP(e) {
    if (typeof e == "function") return hh(e) ? 1 : 0;
    if (e != null) {
      if (e = e.$$typeof, e === Df) return 11;
      if (e === Mf) return 14;
    }
    return 2;
  }
  function lr(e, t) {
    var n = e.alternate;
    return n === null ? (n = Lt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
      lanes: t.lanes,
      firstContext: t.firstContext
    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n;
  }
  function Va(e, t, n, r, s, i) {
    var o = 2;
    if (r = e, typeof e == "function") hh(e) && (o = 1);
    else if (typeof e == "string") o = 5;
    else e: switch (e) {
      case as:
        return Lr(n.children, s, i, t);
      case Nf:
        o = 8, s |= 8;
        break;
      case zc:
        return e = Lt(12, n, t, s | 2), e.elementType = zc, e.lanes = i, e;
      case Bc:
        return e = Lt(13, n, t, s), e.elementType = Bc, e.lanes = i, e;
      case Uc:
        return e = Lt(19, n, t, s), e.elementType = Uc, e.lanes = i, e;
      case Vv:
        return nu(n, s, i, t);
      default:
        if (typeof e == "object" && e !== null) switch (e.$$typeof) {
          case Lv:
            o = 10;
            break e;
          case jv:
            o = 9;
            break e;
          case Df:
            o = 11;
            break e;
          case Mf:
            o = 14;
            break e;
          case qn:
            o = 16, r = null;
            break e;
        }
        throw Error(N(130, e == null ? e : typeof e, ""));
    }
    return t = Lt(o, n, t, s), t.elementType = e, t.type = r, t.lanes = i, t;
  }
  function Lr(e, t, n, r) {
    return e = Lt(7, e, r, t), e.lanes = n, e;
  }
  function nu(e, t, n, r) {
    return e = Lt(22, e, r, t), e.elementType = Vv, e.lanes = n, e.stateNode = {
      isHidden: false
    }, e;
  }
  function tc(e, t, n) {
    return e = Lt(6, e, null, t), e.lanes = n, e;
  }
  function nc(e, t, n) {
    return t = Lt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
    }, t;
  }
  function oP(e, t, n, r, s) {
    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Lu(0), this.expirationTimes = Lu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Lu(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null;
  }
  function ph(e, t, n, r, s, i, o, a, l) {
    return e = new oP(e, t, n, a, l), t === 1 ? (t = 1, i === true && (t |= 8)) : t = 0, i = Lt(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }, Yf(i), e;
  }
  function aP(e, t, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: os,
      key: r == null ? null : "" + r,
      children: e,
      containerInfo: t,
      implementation: n
    };
  }
  function Aw(e) {
    if (!e) return dr;
    e = e._reactInternals;
    e: {
      if (Jr(e) !== e || e.tag !== 1) throw Error(N(170));
      var t = e;
      do {
        switch (t.tag) {
          case 3:
            t = t.stateNode.context;
            break e;
          case 1:
            if (gt(t.type)) {
              t = t.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        t = t.return;
      } while (t !== null);
      throw Error(N(171));
    }
    if (e.tag === 1) {
      var n = e.type;
      if (gt(n)) return A0(e, n, t);
    }
    return t;
  }
  function Rw(e, t, n, r, s, i, o, a, l) {
    return e = ph(n, r, true, e, s, i, o, a, l), e.context = Aw(null), n = e.current, r = ot(), s = ar(n), i = Rn(r, s), i.callback = t ?? null, ir(n, i, s), e.current.lanes = s, Io(e, s, r), yt(e, r), e;
  }
  function ru(e, t, n, r) {
    var s = t.current, i = ot(), o = ar(s);
    return n = Aw(n), t.context === null ? t.context = n : t.pendingContext = n, t = Rn(i, o), t.payload = {
      element: e
    }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = ir(s, t, o), e !== null && (qt(e, s, o, i), Da(e, s, o)), o;
  }
  function gl(e) {
    if (e = e.current, !e.child) return null;
    switch (e.child.tag) {
      case 5:
        return e.child.stateNode;
      default:
        return e.child.stateNode;
    }
  }
  function Fm(e, t) {
    if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
      var n = e.retryLane;
      e.retryLane = n !== 0 && n < t ? n : t;
    }
  }
  function mh(e, t) {
    Fm(e, t), (e = e.alternate) && Fm(e, t);
  }
  function lP() {
    return null;
  }
  var Nw = typeof reportError == "function" ? reportError : function(e) {
    console.error(e);
  };
  function gh(e) {
    this._internalRoot = e;
  }
  su.prototype.render = gh.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null) throw Error(N(409));
    ru(e, t, null, null);
  };
  su.prototype.unmount = gh.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
      this._internalRoot = null;
      var t = e.containerInfo;
      $r(function() {
        ru(null, e, null, null);
      }), t[On] = null;
    }
  };
  function su(e) {
    this._internalRoot = e;
  }
  su.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
      var t = l0();
      e = {
        blockedOn: null,
        target: e,
        priority: t
      };
      for (var n = 0; n < Yn.length && t !== 0 && t < Yn[n].priority; n++) ;
      Yn.splice(n, 0, e), n === 0 && c0(e);
    }
  };
  function yh(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
  }
  function iu(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "));
  }
  function zm() {
  }
  function uP(e, t, n, r, s) {
    if (s) {
      if (typeof r == "function") {
        var i = r;
        r = function() {
          var u = gl(o);
          i.call(u);
        };
      }
      var o = Rw(t, r, e, 0, null, false, false, "", zm);
      return e._reactRootContainer = o, e[On] = o.current, to(e.nodeType === 8 ? e.parentNode : e), $r(), o;
    }
    for (; s = e.lastChild; ) e.removeChild(s);
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var u = gl(l);
        a.call(u);
      };
    }
    var l = ph(e, 0, false, null, null, false, false, "", zm);
    return e._reactRootContainer = l, e[On] = l.current, to(e.nodeType === 8 ? e.parentNode : e), $r(function() {
      ru(t, l, n, r);
    }), l;
  }
  function ou(e, t, n, r, s) {
    var i = n._reactRootContainer;
    if (i) {
      var o = i;
      if (typeof s == "function") {
        var a = s;
        s = function() {
          var l = gl(o);
          a.call(l);
        };
      }
      ru(t, o, e, s);
    } else o = uP(n, t, e, s, r);
    return gl(o);
  }
  o0 = function(e) {
    switch (e.tag) {
      case 3:
        var t = e.stateNode;
        if (t.current.memoizedState.isDehydrated) {
          var n = ki(t.pendingLanes);
          n !== 0 && (Lf(t, n | 1), yt(t, De()), !(ie & 6) && (Ws = De() + 500, br()));
        }
        break;
      case 13:
        $r(function() {
          var r = In(e, 1);
          if (r !== null) {
            var s = ot();
            qt(r, e, 1, s);
          }
        }), mh(e, 1);
    }
  };
  jf = function(e) {
    if (e.tag === 13) {
      var t = In(e, 134217728);
      if (t !== null) {
        var n = ot();
        qt(t, e, 134217728, n);
      }
      mh(e, 134217728);
    }
  };
  a0 = function(e) {
    if (e.tag === 13) {
      var t = ar(e), n = In(e, t);
      if (n !== null) {
        var r = ot();
        qt(n, e, t, r);
      }
      mh(e, t);
    }
  };
  l0 = function() {
    return ue;
  };
  u0 = function(e, t) {
    var n = ue;
    try {
      return ue = e, t();
    } finally {
      ue = n;
    }
  };
  Xc = function(e, t, n) {
    switch (t) {
      case "input":
        if (Hc(e, n), t = n.name, n.type === "radio" && t != null) {
          for (n = e; n.parentNode; ) n = n.parentNode;
          for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
            var r = n[t];
            if (r !== e && r.form === e.form) {
              var s = Zl(r);
              if (!s) throw Error(N(90));
              zv(r), Hc(r, s);
            }
          }
        }
        break;
      case "textarea":
        Uv(e, n);
        break;
      case "select":
        t = n.value, t != null && Es(e, !!n.multiple, t, false);
    }
  };
  qv = ch;
  Zv = $r;
  var cP = {
    usingClientEntryPoint: false,
    Events: [
      jo,
      ds,
      Zl,
      Qv,
      Gv,
      ch
    ]
  }, Si = {
    findFiberByHostInstance: Rr,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
  }, dP = {
    bundleType: Si.bundleType,
    version: Si.version,
    rendererPackageName: Si.rendererPackageName,
    rendererConfig: Si.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Un.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(e) {
      return e = Jv(e), e === null ? null : e.stateNode;
    },
    findFiberByHostInstance: Si.findFiberByHostInstance || lP,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var fa = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!fa.isDisabled && fa.supportsFiber) try {
      Kl = fa.inject(dP), un = fa;
    } catch {
    }
  }
  At.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cP;
  At.createPortal = function(e, t) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!yh(t)) throw Error(N(200));
    return aP(e, t, null, n);
  };
  At.createRoot = function(e, t) {
    if (!yh(e)) throw Error(N(299));
    var n = false, r = "", s = Nw;
    return t != null && (t.unstable_strictMode === true && (n = true), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = ph(e, 1, false, null, null, n, false, r, s), e[On] = t.current, to(e.nodeType === 8 ? e.parentNode : e), new gh(t);
  };
  At.findDOMNode = function(e) {
    if (e == null) return null;
    if (e.nodeType === 1) return e;
    var t = e._reactInternals;
    if (t === void 0) throw typeof e.render == "function" ? Error(N(188)) : (e = Object.keys(e).join(","), Error(N(268, e)));
    return e = Jv(t), e = e === null ? null : e.stateNode, e;
  };
  At.flushSync = function(e) {
    return $r(e);
  };
  At.hydrate = function(e, t, n) {
    if (!iu(t)) throw Error(N(200));
    return ou(null, e, t, true, n);
  };
  At.hydrateRoot = function(e, t, n) {
    if (!yh(e)) throw Error(N(405));
    var r = n != null && n.hydratedSources || null, s = false, i = "", o = Nw;
    if (n != null && (n.unstable_strictMode === true && (s = true), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = Rw(t, null, e, 1, n ?? null, s, false, i, o), e[On] = t.current, to(e), r) for (e = 0; e < r.length; e++) n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [
      n,
      s
    ] : t.mutableSourceEagerHydrationData.push(n, s);
    return new su(t);
  };
  At.render = function(e, t, n) {
    if (!iu(t)) throw Error(N(200));
    return ou(null, e, t, false, n);
  };
  At.unmountComponentAtNode = function(e) {
    if (!iu(e)) throw Error(N(40));
    return e._reactRootContainer ? ($r(function() {
      ou(null, null, e, false, function() {
        e._reactRootContainer = null, e[On] = null;
      });
    }), true) : false;
  };
  At.unstable_batchedUpdates = ch;
  At.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
    if (!iu(n)) throw Error(N(200));
    if (e == null || e._reactInternals === void 0) throw Error(N(38));
    return ou(e, t, n, false, r);
  };
  At.version = "18.3.1-next-f1338f8080-20240426";
  function Dw() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Dw);
    } catch (e) {
      console.error(e);
    }
  }
  Dw(), Dv.exports = At;
  var Fo = Dv.exports;
  const fP = xv(Fo);
  var Mw, Bm = Fo;
  Mw = Bm.createRoot, Bm.hydrateRoot;
  let hP, pP, Um;
  hP = "modulepreload";
  pP = function(e) {
    return "/" + e;
  };
  Um = {};
  Ve = function(t, n, r) {
    let s = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"), a = o?.nonce || o?.getAttribute("nonce");
      s = Promise.allSettled(n.map((l) => {
        if (l = pP(l), l in Um) return;
        Um[l] = true;
        const u = l.endsWith(".css"), c = u ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${l}"]${c}`)) return;
        const d = document.createElement("link");
        if (d.rel = u ? "stylesheet" : hP, u || (d.as = "script"), d.crossOrigin = "", d.href = l, a && d.setAttribute("nonce", a), document.head.appendChild(d), u) return new Promise((f, p) => {
          d.addEventListener("load", f), d.addEventListener("error", () => p(new Error(`Unable to preload CSS for ${l}`)));
        });
      }));
    }
    function i(o) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o;
    }
    return s.then((o) => {
      for (const a of o || []) a.status === "rejected" && i(a.reason);
      return t().catch(i);
    });
  };
  function mP(e, t) {
    if (e instanceof RegExp) return {
      keys: false,
      pattern: e
    };
    var n, r, s, i, o = [], a = "", l = e.split("/");
    for (l[0] || l.shift(); s = l.shift(); ) n = s[0], n === "*" ? (o.push(n), a += s[1] === "?" ? "(?:/(.*))?" : "/(.*)") : n === ":" ? (r = s.indexOf("?", 1), i = s.indexOf(".", 1), o.push(s.substring(1, ~r ? r : ~i ? i : s.length)), a += ~r && !~i ? "(?:/([^/]+?))?" : "/([^/]+?)", ~i && (a += (~r ? "?" : "") + "\\" + s.substring(i))) : a += "/" + s;
    return {
      keys: o,
      pattern: new RegExp("^" + a + (t ? "(?=$|/)" : "/?$"), "i")
    };
  }
  var Ow = {
    exports: {}
  }, Iw = {};
  var Hs = h;
  function gP(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
  }
  var yP = typeof Object.is == "function" ? Object.is : gP, vP = Hs.useState, wP = Hs.useEffect, xP = Hs.useLayoutEffect, SP = Hs.useDebugValue;
  function bP(e, t) {
    var n = t(), r = vP({
      inst: {
        value: n,
        getSnapshot: t
      }
    }), s = r[0].inst, i = r[1];
    return xP(function() {
      s.value = n, s.getSnapshot = t, rc(s) && i({
        inst: s
      });
    }, [
      e,
      n,
      t
    ]), wP(function() {
      return rc(s) && i({
        inst: s
      }), e(function() {
        rc(s) && i({
          inst: s
        });
      });
    }, [
      e
    ]), SP(n), n;
  }
  function rc(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
      var n = t();
      return !yP(e, n);
    } catch {
      return true;
    }
  }
  function TP(e, t) {
    return t();
  }
  var CP = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? TP : bP;
  Iw.useSyncExternalStore = Hs.useSyncExternalStore !== void 0 ? Hs.useSyncExternalStore : CP;
  Ow.exports = Iw;
  var EP = Ow.exports;
  const PP = Hl.useInsertionEffect, kP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", _P = kP ? h.useLayoutEffect : h.useEffect, AP = PP || _P, Lw = (e) => {
    const t = h.useRef([
      e,
      (...n) => t[0](...n)
    ]).current;
    return AP(() => {
      t[0] = e;
    }), t[1];
  }, RP = "popstate", vh = "pushState", wh = "replaceState", NP = "hashchange", $m = [
    RP,
    vh,
    wh,
    NP
  ], DP = (e) => {
    for (const t of $m) addEventListener(t, e);
    return () => {
      for (const t of $m) removeEventListener(t, e);
    };
  }, jw = (e, t) => EP.useSyncExternalStore(DP, e, t), Wm = () => location.search, MP = ({ ssrSearch: e } = {}) => jw(Wm, e != null ? () => e : Wm), Hm = () => location.pathname, OP = ({ ssrPath: e } = {}) => jw(Hm, e != null ? () => e : Hm), IP = (e, { replace: t = false, state: n = null } = {}) => history[t ? wh : vh](n, "", e), LP = (e = {}) => [
    OP(e),
    IP
  ], Km = Symbol.for("wouter_v3");
  if (typeof history < "u" && typeof window[Km] > "u") {
    for (const e of [
      vh,
      wh
    ]) {
      const t = history[e];
      history[e] = function() {
        const n = t.apply(this, arguments), r = new Event(e);
        return r.arguments = arguments, dispatchEvent(r), n;
      };
    }
    Object.defineProperty(window, Km, {
      value: true
    });
  }
  let jP, Vw, VP, FP, Qm, Fw, zw, ri, Bw, Uw, zP, au, Sh, BP, Gm, UP, Fe, $w, WP;
  jP = (e, t) => t.toLowerCase().indexOf(e.toLowerCase()) ? "~" + t : t.slice(e.length) || "/";
  Vw = (e = "") => e === "/" ? "" : e;
  VP = (e, t) => e[0] === "~" ? e.slice(1) : Vw(t) + e;
  FP = (e = "", t) => jP(Qm(Vw(e)), Qm(t));
  Qm = (e) => {
    try {
      return decodeURI(e);
    } catch {
      return e;
    }
  };
  Fw = {
    hook: LP,
    searchHook: MP,
    parser: mP,
    base: "",
    ssrPath: void 0,
    ssrSearch: void 0,
    ssrContext: void 0,
    hrefs: (e) => e,
    aroundNav: (e, t, n) => e(t, n)
  };
  zw = h.createContext(Fw);
  ri = () => h.useContext(zw);
  Bw = {};
  Uw = h.createContext(Bw);
  zP = () => h.useContext(Uw);
  au = (e) => {
    const [t, n] = e.hook(e);
    return [
      FP(e.base, t),
      Lw((r, s) => e.aroundNav(n, VP(r, e.base), s))
    ];
  };
  xh = () => au(ri());
  Sh = (e, t, n, r) => {
    const { pattern: s, keys: i } = t instanceof RegExp ? {
      keys: false,
      pattern: t
    } : e(t || "*", r), o = s.exec(n) || [], [a, ...l] = o;
    return a !== void 0 ? [
      true,
      (() => {
        const u = i !== false ? Object.fromEntries(i.map((d, f) => [
          d,
          l[f]
        ])) : o.groups;
        let c = {
          ...l
        };
        return u && Object.assign(c, u), c;
      })(),
      ...r ? [
        a
      ] : []
    ] : [
      false,
      null
    ];
  };
  C3 = (e) => Sh(ri().parser, e, xh()[0]);
  BP = ({ children: e, ...t }) => {
    const n = ri(), r = t.hook ? Fw : n;
    let s = r;
    const [i, o = t.ssrSearch ?? ""] = t.ssrPath?.split("?") ?? [];
    i && (t.ssrSearch = o, t.ssrPath = i), t.hrefs = t.hrefs ?? t.hook?.hrefs, t.searchHook = t.searchHook ?? t.hook?.searchHook;
    let a = h.useRef({}), l = a.current, u = l;
    for (let c in r) {
      const d = c === "base" ? r[c] + (t[c] ?? "") : t[c] ?? r[c];
      l === u && d !== u[c] && (a.current = u = {
        ...u
      }), u[c] = d, (d !== r[c] || d !== s[c]) && (s = u);
    }
    return h.createElement(zw.Provider, {
      value: s,
      children: e
    });
  };
  Gm = ({ children: e, component: t }, n) => t ? h.createElement(t, {
    params: n
  }) : typeof e == "function" ? e(n) : e;
  UP = (e) => {
    let t = h.useRef(Bw);
    const n = t.current;
    return t.current = Object.keys(e).length !== Object.keys(n).length || Object.entries(e).some(([r, s]) => s !== n[r]) ? e : n;
  };
  Fe = ({ path: e, nest: t, match: n, ...r }) => {
    const s = ri(), [i] = au(s), [o, a, l] = n ?? Sh(s.parser, e, i, t), u = UP({
      ...zP(),
      ...a
    });
    if (!o) return null;
    const c = l ? h.createElement(BP, {
      base: l
    }, Gm(r, u)) : Gm(r, u);
    return h.createElement(Uw.Provider, {
      value: u,
      children: c
    });
  };
  $P = h.forwardRef((e, t) => {
    const n = ri(), [r, s] = au(n), { to: i = "", href: o = i, onClick: a, asChild: l, children: u, className: c, replace: d, state: f, transition: p, ...w } = e, g = Lw((m) => {
      m.ctrlKey || m.metaKey || m.altKey || m.shiftKey || m.button !== 0 || (a?.(m), m.defaultPrevented || (m.preventDefault(), s(o, e)));
    }), x = n.hrefs(o[0] === "~" ? o.slice(1) : n.base + o, n);
    return l && h.isValidElement(u) ? h.cloneElement(u, {
      onClick: g,
      href: x
    }) : h.createElement("a", {
      ...w,
      onClick: g,
      href: x,
      className: c?.call ? c(r === o) : c,
      children: u,
      ref: t
    });
  });
  $w = (e) => Array.isArray(e) ? e.flatMap((t) => $w(t && t.type === h.Fragment ? t.props.children : t)) : [
    e
  ];
  WP = ({ children: e, location: t }) => {
    const n = ri(), [r] = au(n);
    for (const s of $w(e)) {
      let i = 0;
      if (h.isValidElement(s) && (i = Sh(n.parser, s.props.path, t || r, s.props.nest))[0]) return h.cloneElement(s, {
        match: i
      });
    }
    return null;
  };
  var si = class {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
    }
    subscribe(e) {
      return this.listeners.add(e), this.onSubscribe(), () => {
        this.listeners.delete(e), this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  }, HP = {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: (e) => clearTimeout(e),
    setInterval: (e, t) => setInterval(e, t),
    clearInterval: (e) => clearInterval(e)
  }, KP = (_a2 = class {
    constructor() {
      __privateAdd(this, _e2, HP);
      __privateAdd(this, _t2, false);
    }
    setTimeoutProvider(e) {
      __privateSet(this, _e2, e);
    }
    setTimeout(e, t) {
      return __privateGet(this, _e2).setTimeout(e, t);
    }
    clearTimeout(e) {
      __privateGet(this, _e2).clearTimeout(e);
    }
    setInterval(e, t) {
      return __privateGet(this, _e2).setInterval(e, t);
    }
    clearInterval(e) {
      __privateGet(this, _e2).clearInterval(e);
    }
  }, _e2 = new WeakMap(), _t2 = new WeakMap(), _a2), Mr = new KP();
  function QP(e) {
    setTimeout(e, 0);
  }
  var Wr = typeof window > "u" || "Deno" in globalThis;
  function it() {
  }
  function GP(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Nd(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0;
  }
  function Ww(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0);
  }
  function ur(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Mt(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function qm(e, t) {
    const { type: n = "all", exact: r, fetchStatus: s, predicate: i, queryKey: o, stale: a } = e;
    if (o) {
      if (r) {
        if (t.queryHash !== bh(o, t.options)) return false;
      } else if (!co(t.queryKey, o)) return false;
    }
    if (n !== "all") {
      const l = t.isActive();
      if (n === "active" && !l || n === "inactive" && l) return false;
    }
    return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || i && !i(t));
  }
  function Zm(e, t) {
    const { exact: n, status: r, predicate: s, mutationKey: i } = e;
    if (i) {
      if (!t.options.mutationKey) return false;
      if (n) {
        if (Hr(t.options.mutationKey) !== Hr(i)) return false;
      } else if (!co(t.options.mutationKey, i)) return false;
    }
    return !(r && t.state.status !== r || s && !s(t));
  }
  function bh(e, t) {
    return (t?.queryKeyHashFn || Hr)(e);
  }
  function Hr(e) {
    return JSON.stringify(e, (t, n) => Dd(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n);
  }
  function co(e, t) {
    return e === t ? true : typeof e != typeof t ? false : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((n) => co(e[n], t[n])) : false;
  }
  var qP = Object.prototype.hasOwnProperty;
  function Hw(e, t, n = 0) {
    if (e === t) return e;
    if (n > 500) return t;
    const r = Ym(e) && Ym(t);
    if (!r && !(Dd(e) && Dd(t))) return t;
    const i = (r ? e : Object.keys(e)).length, o = r ? t : Object.keys(t), a = o.length, l = r ? new Array(a) : {};
    let u = 0;
    for (let c = 0; c < a; c++) {
      const d = r ? c : o[c], f = e[d], p = t[d];
      if (f === p) {
        l[d] = f, (r ? c < i : qP.call(e, d)) && u++;
        continue;
      }
      if (f === null || p === null || typeof f != "object" || typeof p != "object") {
        l[d] = p;
        continue;
      }
      const w = Hw(f, p, n + 1);
      l[d] = w, w === f && u++;
    }
    return i === a && u === i ? e : l;
  }
  function yl(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length) return false;
    for (const n in e) if (e[n] !== t[n]) return false;
    return true;
  }
  function Ym(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length;
  }
  function Dd(e) {
    if (!Xm(e)) return false;
    const t = e.constructor;
    if (t === void 0) return true;
    const n = t.prototype;
    return !(!Xm(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
  }
  function Xm(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  function ZP(e) {
    return new Promise((t) => {
      Mr.setTimeout(t, e);
    });
  }
  function Md(e, t, n) {
    return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== false ? Hw(e, t) : t;
  }
  function YP(e, t, n = 0) {
    const r = [
      ...e,
      t
    ];
    return n && r.length > n ? r.slice(1) : r;
  }
  function XP(e, t, n = 0) {
    const r = [
      t,
      ...e
    ];
    return n && r.length > n ? r.slice(0, -1) : r;
  }
  var Th = Symbol();
  function Kw(e, t) {
    return !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === Th ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
  }
  function Ch(e, t) {
    return typeof e == "function" ? e(...t) : !!e;
  }
  function JP(e, t, n) {
    let r = false, s;
    return Object.defineProperty(e, "signal", {
      enumerable: true,
      get: () => (s ??= t(), r || (r = true, s.aborted ? n() : s.addEventListener("abort", n, {
        once: true
      })), s)
    }), e;
  }
  var ek = (_b2 = class extends si {
    constructor() {
      super();
      __privateAdd(this, _e3);
      __privateAdd(this, _t3);
      __privateAdd(this, _n2);
      __privateSet(this, _n2, (e) => {
        if (!Wr && window.addEventListener) {
          const t = () => e();
          return window.addEventListener("visibilitychange", t, false), () => {
            window.removeEventListener("visibilitychange", t);
          };
        }
      });
    }
    onSubscribe() {
      __privateGet(this, _t3) || this.setEventListener(__privateGet(this, _n2));
    }
    onUnsubscribe() {
      var _a6;
      this.hasListeners() || ((_a6 = __privateGet(this, _t3)) == null ? void 0 : _a6.call(this), __privateSet(this, _t3, void 0));
    }
    setEventListener(e) {
      var _a6;
      __privateSet(this, _n2, e), (_a6 = __privateGet(this, _t3)) == null ? void 0 : _a6.call(this), __privateSet(this, _t3, e((t) => {
        typeof t == "boolean" ? this.setFocused(t) : this.onFocus();
      }));
    }
    setFocused(e) {
      __privateGet(this, _e3) !== e && (__privateSet(this, _e3, e), this.onFocus());
    }
    onFocus() {
      const e = this.isFocused();
      this.listeners.forEach((t) => {
        t(e);
      });
    }
    isFocused() {
      return typeof __privateGet(this, _e3) == "boolean" ? __privateGet(this, _e3) : globalThis.document?.visibilityState !== "hidden";
    }
  }, _e3 = new WeakMap(), _t3 = new WeakMap(), _n2 = new WeakMap(), _b2), Eh = new ek();
  function Od() {
    let e, t;
    const n = new Promise((s, i) => {
      e = s, t = i;
    });
    n.status = "pending", n.catch(() => {
    });
    function r(s) {
      Object.assign(n, s), delete n.resolve, delete n.reject;
    }
    return n.resolve = (s) => {
      r({
        status: "fulfilled",
        value: s
      }), e(s);
    }, n.reject = (s) => {
      r({
        status: "rejected",
        reason: s
      }), t(s);
    }, n;
  }
  var tk = QP;
  function nk() {
    let e = [], t = 0, n = (a) => {
      a();
    }, r = (a) => {
      a();
    }, s = tk;
    const i = (a) => {
      t ? e.push(a) : s(() => {
        n(a);
      });
    }, o = () => {
      const a = e;
      e = [], a.length && s(() => {
        r(() => {
          a.forEach((l) => {
            n(l);
          });
        });
      });
    };
    return {
      batch: (a) => {
        let l;
        t++;
        try {
          l = a();
        } finally {
          t--, t || o();
        }
        return l;
      },
      batchCalls: (a) => (...l) => {
        i(() => {
          a(...l);
        });
      },
      schedule: i,
      setNotifyFunction: (a) => {
        n = a;
      },
      setBatchNotifyFunction: (a) => {
        r = a;
      },
      setScheduler: (a) => {
        s = a;
      }
    };
  }
  var Le = nk(), rk = (_c2 = class extends si {
    constructor() {
      super();
      __privateAdd(this, _e4, true);
      __privateAdd(this, _t4);
      __privateAdd(this, _n3);
      __privateSet(this, _n3, (e) => {
        if (!Wr && window.addEventListener) {
          const t = () => e(true), n = () => e(false);
          return window.addEventListener("online", t, false), window.addEventListener("offline", n, false), () => {
            window.removeEventListener("online", t), window.removeEventListener("offline", n);
          };
        }
      });
    }
    onSubscribe() {
      __privateGet(this, _t4) || this.setEventListener(__privateGet(this, _n3));
    }
    onUnsubscribe() {
      var _a6;
      this.hasListeners() || ((_a6 = __privateGet(this, _t4)) == null ? void 0 : _a6.call(this), __privateSet(this, _t4, void 0));
    }
    setEventListener(e) {
      var _a6;
      __privateSet(this, _n3, e), (_a6 = __privateGet(this, _t4)) == null ? void 0 : _a6.call(this), __privateSet(this, _t4, e(this.setOnline.bind(this)));
    }
    setOnline(e) {
      __privateGet(this, _e4) !== e && (__privateSet(this, _e4, e), this.listeners.forEach((n) => {
        n(e);
      }));
    }
    isOnline() {
      return __privateGet(this, _e4);
    }
  }, _e4 = new WeakMap(), _t4 = new WeakMap(), _n3 = new WeakMap(), _c2), vl = new rk();
  function sk(e) {
    return Math.min(1e3 * 2 ** e, 3e4);
  }
  function Qw(e) {
    return (e ?? "online") === "online" ? vl.isOnline() : true;
  }
  var Id = class extends Error {
    constructor(e) {
      super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent;
    }
  };
  function Gw(e) {
    let t = false, n = 0, r;
    const s = Od(), i = () => s.status !== "pending", o = (g) => {
      if (!i()) {
        const x = new Id(g);
        f(x), e.onCancel?.(x);
      }
    }, a = () => {
      t = true;
    }, l = () => {
      t = false;
    }, u = () => Eh.isFocused() && (e.networkMode === "always" || vl.isOnline()) && e.canRun(), c = () => Qw(e.networkMode) && e.canRun(), d = (g) => {
      i() || (r?.(), s.resolve(g));
    }, f = (g) => {
      i() || (r?.(), s.reject(g));
    }, p = () => new Promise((g) => {
      r = (x) => {
        (i() || u()) && g(x);
      }, e.onPause?.();
    }).then(() => {
      r = void 0, i() || e.onContinue?.();
    }), w = () => {
      if (i()) return;
      let g;
      const x = n === 0 ? e.initialPromise : void 0;
      try {
        g = x ?? e.fn();
      } catch (m) {
        g = Promise.reject(m);
      }
      Promise.resolve(g).then(d).catch((m) => {
        if (i()) return;
        const y = e.retry ?? (Wr ? 0 : 3), v = e.retryDelay ?? sk, b = typeof v == "function" ? v(n, m) : v, T = y === true || typeof y == "number" && n < y || typeof y == "function" && y(n, m);
        if (t || !T) {
          f(m);
          return;
        }
        n++, e.onFail?.(n, m), ZP(b).then(() => u() ? void 0 : p()).then(() => {
          t ? f(m) : w();
        });
      });
    };
    return {
      promise: s,
      status: () => s.status,
      cancel: o,
      continue: () => (r?.(), s),
      cancelRetry: a,
      continueRetry: l,
      canStart: c,
      start: () => (c() ? w() : p().then(w), s)
    };
  }
  var qw = (_d2 = class {
    constructor() {
      __privateAdd(this, _e5);
    }
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout(), Nd(this.gcTime) && __privateSet(this, _e5, Mr.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
    updateGcTime(e) {
      this.gcTime = Math.max(this.gcTime || 0, e ?? (Wr ? 1 / 0 : 5 * 60 * 1e3));
    }
    clearGcTimeout() {
      __privateGet(this, _e5) && (Mr.clearTimeout(__privateGet(this, _e5)), __privateSet(this, _e5, void 0));
    }
  }, _e5 = new WeakMap(), _d2), ik = (_e7 = class extends qw {
    constructor(e) {
      super();
      __privateAdd(this, _ik_instances);
      __privateAdd(this, _e6);
      __privateAdd(this, _t5);
      __privateAdd(this, _n4);
      __privateAdd(this, _s2);
      __privateAdd(this, _r2);
      __privateAdd(this, _o2);
      __privateAdd(this, _a3);
      __privateSet(this, _a3, false), __privateSet(this, _o2, e.defaultOptions), this.setOptions(e.options), this.observers = [], __privateSet(this, _s2, e.client), __privateSet(this, _n4, __privateGet(this, _s2).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, __privateSet(this, _e6, eg(this.options)), this.state = e.state ?? __privateGet(this, _e6), this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      return __privateGet(this, _r2)?.promise;
    }
    setOptions(e) {
      if (this.options = {
        ...__privateGet(this, _o2),
        ...e
      }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
        const t = eg(this.options);
        t.data !== void 0 && (this.setState(Jm(t.data, t.dataUpdatedAt)), __privateSet(this, _e6, t));
      }
    }
    optionalRemove() {
      !this.observers.length && this.state.fetchStatus === "idle" && __privateGet(this, _n4).remove(this);
    }
    setData(e, t) {
      const n = Md(this.state.data, e, this.options);
      return __privateMethod(this, _ik_instances, i_fn).call(this, {
        data: n,
        type: "success",
        dataUpdatedAt: t?.updatedAt,
        manual: t?.manual
      }), n;
    }
    setState(e, t) {
      __privateMethod(this, _ik_instances, i_fn).call(this, {
        type: "setState",
        state: e,
        setStateOptions: t
      });
    }
    cancel(e) {
      const t = __privateGet(this, _r2)?.promise;
      return __privateGet(this, _r2)?.cancel(e), t ? t.then(it).catch(it) : Promise.resolve();
    }
    destroy() {
      super.destroy(), this.cancel({
        silent: true
      });
    }
    reset() {
      this.destroy(), this.setState(__privateGet(this, _e6));
    }
    isActive() {
      return this.observers.some((e) => Mt(e.options.enabled, this) !== false);
    }
    isDisabled() {
      return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Th || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
    }
    isStatic() {
      return this.getObserversCount() > 0 ? this.observers.some((e) => ur(e.options.staleTime, this) === "static") : false;
    }
    isStale() {
      return this.getObserversCount() > 0 ? this.observers.some((e) => e.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated;
    }
    isStaleByTime(e = 0) {
      return this.state.data === void 0 ? true : e === "static" ? false : this.state.isInvalidated ? true : !Ww(this.state.dataUpdatedAt, e);
    }
    onFocus() {
      this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({
        cancelRefetch: false
      }), __privateGet(this, _r2)?.continue();
    }
    onOnline() {
      this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({
        cancelRefetch: false
      }), __privateGet(this, _r2)?.continue();
    }
    addObserver(e) {
      this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), __privateGet(this, _n4).notify({
        type: "observerAdded",
        query: this,
        observer: e
      }));
    }
    removeObserver(e) {
      this.observers.includes(e) && (this.observers = this.observers.filter((t) => t !== e), this.observers.length || (__privateGet(this, _r2) && (__privateGet(this, _a3) ? __privateGet(this, _r2).cancel({
        revert: true
      }) : __privateGet(this, _r2).cancelRetry()), this.scheduleGc()), __privateGet(this, _n4).notify({
        type: "observerRemoved",
        query: this,
        observer: e
      }));
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      this.state.isInvalidated || __privateMethod(this, _ik_instances, i_fn).call(this, {
        type: "invalidate"
      });
    }
    async fetch(e, t) {
      if (this.state.fetchStatus !== "idle" && __privateGet(this, _r2)?.status() !== "rejected") {
        if (this.state.data !== void 0 && t?.cancelRefetch) this.cancel({
          silent: true
        });
        else if (__privateGet(this, _r2)) return __privateGet(this, _r2).continueRetry(), __privateGet(this, _r2).promise;
      }
      if (e && this.setOptions(e), !this.options.queryFn) {
        const a = this.observers.find((l) => l.options.queryFn);
        a && this.setOptions(a.options);
      }
      const n = new AbortController(), r = (a) => {
        Object.defineProperty(a, "signal", {
          enumerable: true,
          get: () => (__privateSet(this, _a3, true), n.signal)
        });
      }, s = () => {
        const a = Kw(this.options, t), u = (() => {
          const c = {
            client: __privateGet(this, _s2),
            queryKey: this.queryKey,
            meta: this.meta
          };
          return r(c), c;
        })();
        return __privateSet(this, _a3, false), this.options.persister ? this.options.persister(a, u, this) : a(u);
      }, o = (() => {
        const a = {
          fetchOptions: t,
          options: this.options,
          queryKey: this.queryKey,
          client: __privateGet(this, _s2),
          state: this.state,
          fetchFn: s
        };
        return r(a), a;
      })();
      this.options.behavior?.onFetch(o, this), __privateSet(this, _t5, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== o.fetchOptions?.meta) && __privateMethod(this, _ik_instances, i_fn).call(this, {
        type: "fetch",
        meta: o.fetchOptions?.meta
      }), __privateSet(this, _r2, Gw({
        initialPromise: t?.initialPromise,
        fn: o.fetchFn,
        onCancel: (a) => {
          a instanceof Id && a.revert && this.setState({
            ...__privateGet(this, _t5),
            fetchStatus: "idle"
          }), n.abort();
        },
        onFail: (a, l) => {
          __privateMethod(this, _ik_instances, i_fn).call(this, {
            type: "failed",
            failureCount: a,
            error: l
          });
        },
        onPause: () => {
          __privateMethod(this, _ik_instances, i_fn).call(this, {
            type: "pause"
          });
        },
        onContinue: () => {
          __privateMethod(this, _ik_instances, i_fn).call(this, {
            type: "continue"
          });
        },
        retry: o.options.retry,
        retryDelay: o.options.retryDelay,
        networkMode: o.options.networkMode,
        canRun: () => true
      }));
      try {
        const a = await __privateGet(this, _r2).start();
        if (a === void 0) throw new Error(`${this.queryHash} data is undefined`);
        return this.setData(a), __privateGet(this, _n4).config.onSuccess?.(a, this), __privateGet(this, _n4).config.onSettled?.(a, this.state.error, this), a;
      } catch (a) {
        if (a instanceof Id) {
          if (a.silent) return __privateGet(this, _r2).promise;
          if (a.revert) {
            if (this.state.data === void 0) throw a;
            return this.state.data;
          }
        }
        throw __privateMethod(this, _ik_instances, i_fn).call(this, {
          type: "error",
          error: a
        }), __privateGet(this, _n4).config.onError?.(a, this), __privateGet(this, _n4).config.onSettled?.(this.state.data, a, this), a;
      } finally {
        this.scheduleGc();
      }
    }
  }, _e6 = new WeakMap(), _t5 = new WeakMap(), _n4 = new WeakMap(), _s2 = new WeakMap(), _r2 = new WeakMap(), _o2 = new WeakMap(), _a3 = new WeakMap(), _ik_instances = new WeakSet(), i_fn = function(e) {
    const t = (n) => {
      switch (e.type) {
        case "failed":
          return {
            ...n,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...n,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...n,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...n,
            ...Zw(n.data, this.options),
            fetchMeta: e.meta ?? null
          };
        case "success":
          const r = {
            ...n,
            ...Jm(e.data, e.dataUpdatedAt),
            dataUpdateCount: n.dataUpdateCount + 1,
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          return __privateSet(this, _t5, e.manual ? r : void 0), r;
        case "error":
          const s = e.error;
          return {
            ...n,
            error: s,
            errorUpdateCount: n.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: n.fetchFailureCount + 1,
            fetchFailureReason: s,
            fetchStatus: "idle",
            status: "error",
            isInvalidated: true
          };
        case "invalidate":
          return {
            ...n,
            isInvalidated: true
          };
        case "setState":
          return {
            ...n,
            ...e.state
          };
      }
    };
    this.state = t(this.state), Le.batch(() => {
      this.observers.forEach((n) => {
        n.onQueryUpdate();
      }), __privateGet(this, _n4).notify({
        query: this,
        type: "updated",
        action: e
      });
    });
  }, _e7);
  function Zw(e, t) {
    return {
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: Qw(t.networkMode) ? "fetching" : "paused",
      ...e === void 0 && {
        error: null,
        status: "pending"
      }
    };
  }
  function Jm(e, t) {
    return {
      data: e,
      dataUpdatedAt: t ?? Date.now(),
      error: null,
      isInvalidated: false,
      status: "success"
    };
  }
  function eg(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
      data: t,
      dataUpdateCount: 0,
      dataUpdatedAt: n ? r ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: n ? "success" : "pending",
      fetchStatus: "idle"
    };
  }
  var ok = (_f3 = class extends si {
    constructor(e, t) {
      super();
      __privateAdd(this, _ok_instances);
      __privateAdd(this, _e8);
      __privateAdd(this, _t6);
      __privateAdd(this, _n5);
      __privateAdd(this, _s3);
      __privateAdd(this, _r3);
      __privateAdd(this, _o3);
      __privateAdd(this, _a4);
      __privateAdd(this, _i2);
      __privateAdd(this, _m2);
      __privateAdd(this, _f2);
      __privateAdd(this, _h2);
      __privateAdd(this, _u2);
      __privateAdd(this, _c3);
      __privateAdd(this, _l2);
      __privateAdd(this, _p2, /* @__PURE__ */ new Set());
      this.options = t, __privateSet(this, _e8, e), __privateSet(this, _i2, null), __privateSet(this, _a4, Od()), this.bindMethods(), this.setOptions(t);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      this.listeners.size === 1 && (__privateGet(this, _t6).addObserver(this), tg(__privateGet(this, _t6), this.options) ? __privateMethod(this, _ok_instances, d_fn).call(this) : this.updateResult(), __privateMethod(this, _ok_instances, w_fn).call(this));
    }
    onUnsubscribe() {
      this.hasListeners() || this.destroy();
    }
    shouldFetchOnReconnect() {
      return Ld(__privateGet(this, _t6), this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
      return Ld(__privateGet(this, _t6), this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set(), __privateMethod(this, _ok_instances, x_fn).call(this), __privateMethod(this, _ok_instances, S_fn).call(this), __privateGet(this, _t6).removeObserver(this);
    }
    setOptions(e) {
      const t = this.options, n = __privateGet(this, _t6);
      if (this.options = __privateGet(this, _e8).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Mt(this.options.enabled, __privateGet(this, _t6)) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
      __privateMethod(this, _ok_instances, b_fn).call(this), __privateGet(this, _t6).setOptions(this.options), t._defaulted && !yl(this.options, t) && __privateGet(this, _e8).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _t6),
        observer: this
      });
      const r = this.hasListeners();
      r && ng(__privateGet(this, _t6), n, this.options, t) && __privateMethod(this, _ok_instances, d_fn).call(this), this.updateResult(), r && (__privateGet(this, _t6) !== n || Mt(this.options.enabled, __privateGet(this, _t6)) !== Mt(t.enabled, __privateGet(this, _t6)) || ur(this.options.staleTime, __privateGet(this, _t6)) !== ur(t.staleTime, __privateGet(this, _t6))) && __privateMethod(this, _ok_instances, g_fn).call(this);
      const s = __privateMethod(this, _ok_instances, y_fn).call(this);
      r && (__privateGet(this, _t6) !== n || Mt(this.options.enabled, __privateGet(this, _t6)) !== Mt(t.enabled, __privateGet(this, _t6)) || s !== __privateGet(this, _l2)) && __privateMethod(this, _ok_instances, v_fn).call(this, s);
    }
    getOptimisticResult(e) {
      const t = __privateGet(this, _e8).getQueryCache().build(__privateGet(this, _e8), e), n = this.createResult(t, e);
      return lk(this, n) && (__privateSet(this, _s3, n), __privateSet(this, _o3, this.options), __privateSet(this, _r3, __privateGet(this, _t6).state)), n;
    }
    getCurrentResult() {
      return __privateGet(this, _s3);
    }
    trackResult(e, t) {
      return new Proxy(e, {
        get: (n, r) => (this.trackProp(r), t?.(r), r === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && __privateGet(this, _a4).status === "pending" && __privateGet(this, _a4).reject(new Error("experimental_prefetchInRender feature flag is not enabled"))), Reflect.get(n, r))
      });
    }
    trackProp(e) {
      __privateGet(this, _p2).add(e);
    }
    getCurrentQuery() {
      return __privateGet(this, _t6);
    }
    refetch({ ...e } = {}) {
      return this.fetch({
        ...e
      });
    }
    fetchOptimistic(e) {
      const t = __privateGet(this, _e8).defaultQueryOptions(e), n = __privateGet(this, _e8).getQueryCache().build(__privateGet(this, _e8), t);
      return n.fetch().then(() => this.createResult(n, t));
    }
    fetch(e) {
      return __privateMethod(this, _ok_instances, d_fn).call(this, {
        ...e,
        cancelRefetch: e.cancelRefetch ?? true
      }).then(() => (this.updateResult(), __privateGet(this, _s3)));
    }
    createResult(e, t) {
      const n = __privateGet(this, _t6), r = this.options, s = __privateGet(this, _s3), i = __privateGet(this, _r3), o = __privateGet(this, _o3), l = e !== n ? e.state : __privateGet(this, _n5), { state: u } = e;
      let c = {
        ...u
      }, d = false, f;
      if (t._optimisticResults) {
        const P = this.hasListeners(), D = !P && tg(e, t), A = P && ng(e, n, t, r);
        (D || A) && (c = {
          ...c,
          ...Zw(u.data, e.options)
        }), t._optimisticResults === "isRestoring" && (c.fetchStatus = "idle");
      }
      let { error: p, errorUpdatedAt: w, status: g } = c;
      f = c.data;
      let x = false;
      if (t.placeholderData !== void 0 && f === void 0 && g === "pending") {
        let P;
        s?.isPlaceholderData && t.placeholderData === o?.placeholderData ? (P = s.data, x = true) : P = typeof t.placeholderData == "function" ? t.placeholderData(__privateGet(this, _h2)?.state.data, __privateGet(this, _h2)) : t.placeholderData, P !== void 0 && (g = "success", f = Md(s?.data, P, t), d = true);
      }
      if (t.select && f !== void 0 && !x) if (s && f === i?.data && t.select === __privateGet(this, _m2)) f = __privateGet(this, _f2);
      else try {
        __privateSet(this, _m2, t.select), f = t.select(f), f = Md(s?.data, f, t), __privateSet(this, _f2, f), __privateSet(this, _i2, null);
      } catch (P) {
        __privateSet(this, _i2, P);
      }
      __privateGet(this, _i2) && (p = __privateGet(this, _i2), f = __privateGet(this, _f2), w = Date.now(), g = "error");
      const m = c.fetchStatus === "fetching", y = g === "pending", v = g === "error", b = y && m, T = f !== void 0, E = {
        status: g,
        fetchStatus: c.fetchStatus,
        isPending: y,
        isSuccess: g === "success",
        isError: v,
        isInitialLoading: b,
        isLoading: b,
        data: f,
        dataUpdatedAt: c.dataUpdatedAt,
        error: p,
        errorUpdatedAt: w,
        failureCount: c.fetchFailureCount,
        failureReason: c.fetchFailureReason,
        errorUpdateCount: c.errorUpdateCount,
        isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
        isFetchedAfterMount: c.dataUpdateCount > l.dataUpdateCount || c.errorUpdateCount > l.errorUpdateCount,
        isFetching: m,
        isRefetching: m && !y,
        isLoadingError: v && !T,
        isPaused: c.fetchStatus === "paused",
        isPlaceholderData: d,
        isRefetchError: v && T,
        isStale: Ph(e, t),
        refetch: this.refetch,
        promise: __privateGet(this, _a4),
        isEnabled: Mt(t.enabled, e) !== false
      };
      if (this.options.experimental_prefetchInRender) {
        const P = E.data !== void 0, D = E.status === "error" && !P, A = (Q) => {
          D ? Q.reject(E.error) : P && Q.resolve(E.data);
        }, M = () => {
          const Q = __privateSet(this, _a4, E.promise = Od());
          A(Q);
        }, j = __privateGet(this, _a4);
        switch (j.status) {
          case "pending":
            e.queryHash === n.queryHash && A(j);
            break;
          case "fulfilled":
            (D || E.data !== j.value) && M();
            break;
          case "rejected":
            (!D || E.error !== j.reason) && M();
            break;
        }
      }
      return E;
    }
    updateResult() {
      const e = __privateGet(this, _s3), t = this.createResult(__privateGet(this, _t6), this.options);
      if (__privateSet(this, _r3, __privateGet(this, _t6).state), __privateSet(this, _o3, this.options), __privateGet(this, _r3).data !== void 0 && __privateSet(this, _h2, __privateGet(this, _t6)), yl(t, e)) return;
      __privateSet(this, _s3, t);
      const n = () => {
        if (!e) return true;
        const { notifyOnChangeProps: r } = this.options, s = typeof r == "function" ? r() : r;
        if (s === "all" || !s && !__privateGet(this, _p2).size) return true;
        const i = new Set(s ?? __privateGet(this, _p2));
        return this.options.throwOnError && i.add("error"), Object.keys(__privateGet(this, _s3)).some((o) => {
          const a = o;
          return __privateGet(this, _s3)[a] !== e[a] && i.has(a);
        });
      };
      __privateMethod(this, _ok_instances, T_fn).call(this, {
        listeners: n()
      });
    }
    onQueryUpdate() {
      this.updateResult(), this.hasListeners() && __privateMethod(this, _ok_instances, w_fn).call(this);
    }
  }, _e8 = new WeakMap(), _t6 = new WeakMap(), _n5 = new WeakMap(), _s3 = new WeakMap(), _r3 = new WeakMap(), _o3 = new WeakMap(), _a4 = new WeakMap(), _i2 = new WeakMap(), _m2 = new WeakMap(), _f2 = new WeakMap(), _h2 = new WeakMap(), _u2 = new WeakMap(), _c3 = new WeakMap(), _l2 = new WeakMap(), _p2 = new WeakMap(), _ok_instances = new WeakSet(), d_fn = function(e) {
    __privateMethod(this, _ok_instances, b_fn).call(this);
    let t = __privateGet(this, _t6).fetch(this.options, e);
    return e?.throwOnError || (t = t.catch(it)), t;
  }, g_fn = function() {
    __privateMethod(this, _ok_instances, x_fn).call(this);
    const e = ur(this.options.staleTime, __privateGet(this, _t6));
    if (Wr || __privateGet(this, _s3).isStale || !Nd(e)) return;
    const n = Ww(__privateGet(this, _s3).dataUpdatedAt, e) + 1;
    __privateSet(this, _u2, Mr.setTimeout(() => {
      __privateGet(this, _s3).isStale || this.updateResult();
    }, n));
  }, y_fn = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(__privateGet(this, _t6)) : this.options.refetchInterval) ?? false;
  }, v_fn = function(e) {
    __privateMethod(this, _ok_instances, S_fn).call(this), __privateSet(this, _l2, e), !(Wr || Mt(this.options.enabled, __privateGet(this, _t6)) === false || !Nd(__privateGet(this, _l2)) || __privateGet(this, _l2) === 0) && __privateSet(this, _c3, Mr.setInterval(() => {
      (this.options.refetchIntervalInBackground || Eh.isFocused()) && __privateMethod(this, _ok_instances, d_fn).call(this);
    }, __privateGet(this, _l2)));
  }, w_fn = function() {
    __privateMethod(this, _ok_instances, g_fn).call(this), __privateMethod(this, _ok_instances, v_fn).call(this, __privateMethod(this, _ok_instances, y_fn).call(this));
  }, x_fn = function() {
    __privateGet(this, _u2) && (Mr.clearTimeout(__privateGet(this, _u2)), __privateSet(this, _u2, void 0));
  }, S_fn = function() {
    __privateGet(this, _c3) && (Mr.clearInterval(__privateGet(this, _c3)), __privateSet(this, _c3, void 0));
  }, b_fn = function() {
    const e = __privateGet(this, _e8).getQueryCache().build(__privateGet(this, _e8), this.options);
    if (e === __privateGet(this, _t6)) return;
    const t = __privateGet(this, _t6);
    __privateSet(this, _t6, e), __privateSet(this, _n5, e.state), this.hasListeners() && (t?.removeObserver(this), e.addObserver(this));
  }, T_fn = function(e) {
    Le.batch(() => {
      e.listeners && this.listeners.forEach((t) => {
        t(__privateGet(this, _s3));
      }), __privateGet(this, _e8).getQueryCache().notify({
        query: __privateGet(this, _t6),
        type: "observerResultsUpdated"
      });
    });
  }, _f3);
  function ak(e, t) {
    return Mt(t.enabled, e) !== false && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === false);
  }
  function tg(e, t) {
    return ak(e, t) || e.state.data !== void 0 && Ld(e, t, t.refetchOnMount);
  }
  function Ld(e, t, n) {
    if (Mt(t.enabled, e) !== false && ur(t.staleTime, e) !== "static") {
      const r = typeof n == "function" ? n(e) : n;
      return r === "always" || r !== false && Ph(e, t);
    }
    return false;
  }
  function ng(e, t, n, r) {
    return (e !== t || Mt(r.enabled, e) === false) && (!n.suspense || e.state.status !== "error") && Ph(e, n);
  }
  function Ph(e, t) {
    return Mt(t.enabled, e) !== false && e.isStaleByTime(ur(t.staleTime, e));
  }
  function lk(e, t) {
    return !yl(e.getCurrentResult(), t);
  }
  function rg(e) {
    return {
      onFetch: (t, n) => {
        const r = t.options, s = t.fetchOptions?.meta?.fetchMore?.direction, i = t.state.data?.pages || [], o = t.state.data?.pageParams || [];
        let a = {
          pages: [],
          pageParams: []
        }, l = 0;
        const u = async () => {
          let c = false;
          const d = (w) => {
            JP(w, () => t.signal, () => c = true);
          }, f = Kw(t.options, t.fetchOptions), p = async (w, g, x) => {
            if (c) return Promise.reject();
            if (g == null && w.pages.length) return Promise.resolve(w);
            const y = (() => {
              const C = {
                client: t.client,
                queryKey: t.queryKey,
                pageParam: g,
                direction: x ? "backward" : "forward",
                meta: t.options.meta
              };
              return d(C), C;
            })(), v = await f(y), { maxPages: b } = t.options, T = x ? XP : YP;
            return {
              pages: T(w.pages, v, b),
              pageParams: T(w.pageParams, g, b)
            };
          };
          if (s && i.length) {
            const w = s === "backward", g = w ? uk : sg, x = {
              pages: i,
              pageParams: o
            }, m = g(r, x);
            a = await p(x, m, w);
          } else {
            const w = e ?? i.length;
            do {
              const g = l === 0 ? o[0] ?? r.initialPageParam : sg(r, a);
              if (l > 0 && g == null) break;
              a = await p(a, g), l++;
            } while (l < w);
          }
          return a;
        };
        t.options.persister ? t.fetchFn = () => t.options.persister?.(u, {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        }, n) : t.fetchFn = u;
      }
    };
  }
  function sg(e, { pages: t, pageParams: n }) {
    const r = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0;
  }
  function uk(e, { pages: t, pageParams: n }) {
    return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0;
  }
  var ck = (_g2 = class extends qw {
    constructor(e) {
      super();
      __privateAdd(this, _ck_instances);
      __privateAdd(this, _e9);
      __privateAdd(this, _t7);
      __privateAdd(this, _n6);
      __privateAdd(this, _s4);
      __privateSet(this, _e9, e.client), this.mutationId = e.mutationId, __privateSet(this, _n6, e.mutationCache), __privateSet(this, _t7, []), this.state = e.state || Yw(), this.setOptions(e.options), this.scheduleGc();
    }
    setOptions(e) {
      this.options = e, this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(e) {
      __privateGet(this, _t7).includes(e) || (__privateGet(this, _t7).push(e), this.clearGcTimeout(), __privateGet(this, _n6).notify({
        type: "observerAdded",
        mutation: this,
        observer: e
      }));
    }
    removeObserver(e) {
      __privateSet(this, _t7, __privateGet(this, _t7).filter((t) => t !== e)), this.scheduleGc(), __privateGet(this, _n6).notify({
        type: "observerRemoved",
        mutation: this,
        observer: e
      });
    }
    optionalRemove() {
      __privateGet(this, _t7).length || (this.state.status === "pending" ? this.scheduleGc() : __privateGet(this, _n6).remove(this));
    }
    continue() {
      return __privateGet(this, _s4)?.continue() ?? this.execute(this.state.variables);
    }
    async execute(e) {
      const t = () => {
        __privateMethod(this, _ck_instances, r_fn).call(this, {
          type: "continue"
        });
      }, n = {
        client: __privateGet(this, _e9),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      __privateSet(this, _s4, Gw({
        fn: () => this.options.mutationFn ? this.options.mutationFn(e, n) : Promise.reject(new Error("No mutationFn found")),
        onFail: (i, o) => {
          __privateMethod(this, _ck_instances, r_fn).call(this, {
            type: "failed",
            failureCount: i,
            error: o
          });
        },
        onPause: () => {
          __privateMethod(this, _ck_instances, r_fn).call(this, {
            type: "pause"
          });
        },
        onContinue: t,
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => __privateGet(this, _n6).canRun(this)
      }));
      const r = this.state.status === "pending", s = !__privateGet(this, _s4).canStart();
      try {
        if (r) t();
        else {
          __privateMethod(this, _ck_instances, r_fn).call(this, {
            type: "pending",
            variables: e,
            isPaused: s
          }), __privateGet(this, _n6).config.onMutate && await __privateGet(this, _n6).config.onMutate(e, this, n);
          const o = await this.options.onMutate?.(e, n);
          o !== this.state.context && __privateMethod(this, _ck_instances, r_fn).call(this, {
            type: "pending",
            context: o,
            variables: e,
            isPaused: s
          });
        }
        const i = await __privateGet(this, _s4).start();
        return await __privateGet(this, _n6).config.onSuccess?.(i, e, this.state.context, this, n), await this.options.onSuccess?.(i, e, this.state.context, n), await __privateGet(this, _n6).config.onSettled?.(i, null, this.state.variables, this.state.context, this, n), await this.options.onSettled?.(i, null, e, this.state.context, n), __privateMethod(this, _ck_instances, r_fn).call(this, {
          type: "success",
          data: i
        }), i;
      } catch (i) {
        try {
          await __privateGet(this, _n6).config.onError?.(i, e, this.state.context, this, n);
        } catch (o) {
          Promise.reject(o);
        }
        try {
          await this.options.onError?.(i, e, this.state.context, n);
        } catch (o) {
          Promise.reject(o);
        }
        try {
          await __privateGet(this, _n6).config.onSettled?.(void 0, i, this.state.variables, this.state.context, this, n);
        } catch (o) {
          Promise.reject(o);
        }
        try {
          await this.options.onSettled?.(void 0, i, e, this.state.context, n);
        } catch (o) {
          Promise.reject(o);
        }
        throw __privateMethod(this, _ck_instances, r_fn).call(this, {
          type: "error",
          error: i
        }), i;
      } finally {
        __privateGet(this, _n6).runNext(this);
      }
    }
  }, _e9 = new WeakMap(), _t7 = new WeakMap(), _n6 = new WeakMap(), _s4 = new WeakMap(), _ck_instances = new WeakSet(), r_fn = function(e) {
    const t = (n) => {
      switch (e.type) {
        case "failed":
          return {
            ...n,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...n,
            isPaused: true
          };
        case "continue":
          return {
            ...n,
            isPaused: false
          };
        case "pending":
          return {
            ...n,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: e.isPaused,
            status: "pending",
            variables: e.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...n,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...n,
            data: void 0,
            error: e.error,
            failureCount: n.failureCount + 1,
            failureReason: e.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = t(this.state), Le.batch(() => {
      __privateGet(this, _t7).forEach((n) => {
        n.onMutationUpdate(e);
      }), __privateGet(this, _n6).notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }, _g2);
  function Yw() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0,
      submittedAt: 0
    };
  }
  var dk = (_h3 = class extends si {
    constructor(e = {}) {
      super();
      __privateAdd(this, _e10);
      __privateAdd(this, _t8);
      __privateAdd(this, _n7);
      this.config = e, __privateSet(this, _e10, /* @__PURE__ */ new Set()), __privateSet(this, _t8, /* @__PURE__ */ new Map()), __privateSet(this, _n7, 0);
    }
    build(e, t, n) {
      const r = new ck({
        client: e,
        mutationCache: this,
        mutationId: ++__privateWrapper(this, _n7)._,
        options: e.defaultMutationOptions(t),
        state: n
      });
      return this.add(r), r;
    }
    add(e) {
      __privateGet(this, _e10).add(e);
      const t = ha(e);
      if (typeof t == "string") {
        const n = __privateGet(this, _t8).get(t);
        n ? n.push(e) : __privateGet(this, _t8).set(t, [
          e
        ]);
      }
      this.notify({
        type: "added",
        mutation: e
      });
    }
    remove(e) {
      if (__privateGet(this, _e10).delete(e)) {
        const t = ha(e);
        if (typeof t == "string") {
          const n = __privateGet(this, _t8).get(t);
          if (n) if (n.length > 1) {
            const r = n.indexOf(e);
            r !== -1 && n.splice(r, 1);
          } else n[0] === e && __privateGet(this, _t8).delete(t);
        }
      }
      this.notify({
        type: "removed",
        mutation: e
      });
    }
    canRun(e) {
      const t = ha(e);
      if (typeof t == "string") {
        const r = __privateGet(this, _t8).get(t)?.find((s) => s.state.status === "pending");
        return !r || r === e;
      } else return true;
    }
    runNext(e) {
      const t = ha(e);
      return typeof t == "string" ? __privateGet(this, _t8).get(t)?.find((r) => r !== e && r.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
    }
    clear() {
      Le.batch(() => {
        __privateGet(this, _e10).forEach((e) => {
          this.notify({
            type: "removed",
            mutation: e
          });
        }), __privateGet(this, _e10).clear(), __privateGet(this, _t8).clear();
      });
    }
    getAll() {
      return Array.from(__privateGet(this, _e10));
    }
    find(e) {
      const t = {
        exact: true,
        ...e
      };
      return this.getAll().find((n) => Zm(t, n));
    }
    findAll(e = {}) {
      return this.getAll().filter((t) => Zm(e, t));
    }
    notify(e) {
      Le.batch(() => {
        this.listeners.forEach((t) => {
          t(e);
        });
      });
    }
    resumePausedMutations() {
      const e = this.getAll().filter((t) => t.state.isPaused);
      return Le.batch(() => Promise.all(e.map((t) => t.continue().catch(it))));
    }
  }, _e10 = new WeakMap(), _t8 = new WeakMap(), _n7 = new WeakMap(), _h3);
  function ha(e) {
    return e.options.scope?.id;
  }
  var fk = (_i3 = class extends si {
    constructor(t, n) {
      super();
      __privateAdd(this, _fk_instances);
      __privateAdd(this, _e11);
      __privateAdd(this, _t9);
      __privateAdd(this, _n8);
      __privateAdd(this, _s5);
      __privateSet(this, _e11, t), this.setOptions(n), this.bindMethods(), __privateMethod(this, _fk_instances, r_fn2).call(this);
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
    }
    setOptions(t) {
      const n = this.options;
      this.options = __privateGet(this, _e11).defaultMutationOptions(t), yl(this.options, n) || __privateGet(this, _e11).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _n8),
        observer: this
      }), n?.mutationKey && this.options.mutationKey && Hr(n.mutationKey) !== Hr(this.options.mutationKey) ? this.reset() : __privateGet(this, _n8)?.state.status === "pending" && __privateGet(this, _n8).setOptions(this.options);
    }
    onUnsubscribe() {
      this.hasListeners() || __privateGet(this, _n8)?.removeObserver(this);
    }
    onMutationUpdate(t) {
      __privateMethod(this, _fk_instances, r_fn2).call(this), __privateMethod(this, _fk_instances, o_fn).call(this, t);
    }
    getCurrentResult() {
      return __privateGet(this, _t9);
    }
    reset() {
      __privateGet(this, _n8)?.removeObserver(this), __privateSet(this, _n8, void 0), __privateMethod(this, _fk_instances, r_fn2).call(this), __privateMethod(this, _fk_instances, o_fn).call(this);
    }
    mutate(t, n) {
      return __privateSet(this, _s5, n), __privateGet(this, _n8)?.removeObserver(this), __privateSet(this, _n8, __privateGet(this, _e11).getMutationCache().build(__privateGet(this, _e11), this.options)), __privateGet(this, _n8).addObserver(this), __privateGet(this, _n8).execute(t);
    }
  }, _e11 = new WeakMap(), _t9 = new WeakMap(), _n8 = new WeakMap(), _s5 = new WeakMap(), _fk_instances = new WeakSet(), r_fn2 = function() {
    const t = __privateGet(this, _n8)?.state ?? Yw();
    __privateSet(this, _t9, {
      ...t,
      isPending: t.status === "pending",
      isSuccess: t.status === "success",
      isError: t.status === "error",
      isIdle: t.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    });
  }, o_fn = function(t) {
    Le.batch(() => {
      if (__privateGet(this, _s5) && this.hasListeners()) {
        const n = __privateGet(this, _t9).variables, r = __privateGet(this, _t9).context, s = {
          client: __privateGet(this, _e11),
          meta: this.options.meta,
          mutationKey: this.options.mutationKey
        };
        if (t?.type === "success") {
          try {
            __privateGet(this, _s5).onSuccess?.(t.data, n, r, s);
          } catch (i) {
            Promise.reject(i);
          }
          try {
            __privateGet(this, _s5).onSettled?.(t.data, null, n, r, s);
          } catch (i) {
            Promise.reject(i);
          }
        } else if (t?.type === "error") {
          try {
            __privateGet(this, _s5).onError?.(t.error, n, r, s);
          } catch (i) {
            Promise.reject(i);
          }
          try {
            __privateGet(this, _s5).onSettled?.(void 0, t.error, n, r, s);
          } catch (i) {
            Promise.reject(i);
          }
        }
      }
      this.listeners.forEach((n) => {
        n(__privateGet(this, _t9));
      });
    });
  }, _i3), hk = (_j2 = class extends si {
    constructor(e = {}) {
      super();
      __privateAdd(this, _e12);
      this.config = e, __privateSet(this, _e12, /* @__PURE__ */ new Map());
    }
    build(e, t, n) {
      const r = t.queryKey, s = t.queryHash ?? bh(r, t);
      let i = this.get(s);
      return i || (i = new ik({
        client: e,
        queryKey: r,
        queryHash: s,
        options: e.defaultQueryOptions(t),
        state: n,
        defaultOptions: e.getQueryDefaults(r)
      }), this.add(i)), i;
    }
    add(e) {
      __privateGet(this, _e12).has(e.queryHash) || (__privateGet(this, _e12).set(e.queryHash, e), this.notify({
        type: "added",
        query: e
      }));
    }
    remove(e) {
      const t = __privateGet(this, _e12).get(e.queryHash);
      t && (e.destroy(), t === e && __privateGet(this, _e12).delete(e.queryHash), this.notify({
        type: "removed",
        query: e
      }));
    }
    clear() {
      Le.batch(() => {
        this.getAll().forEach((e) => {
          this.remove(e);
        });
      });
    }
    get(e) {
      return __privateGet(this, _e12).get(e);
    }
    getAll() {
      return [
        ...__privateGet(this, _e12).values()
      ];
    }
    find(e) {
      const t = {
        exact: true,
        ...e
      };
      return this.getAll().find((n) => qm(t, n));
    }
    findAll(e = {}) {
      const t = this.getAll();
      return Object.keys(e).length > 0 ? t.filter((n) => qm(e, n)) : t;
    }
    notify(e) {
      Le.batch(() => {
        this.listeners.forEach((t) => {
          t(e);
        });
      });
    }
    onFocus() {
      Le.batch(() => {
        this.getAll().forEach((e) => {
          e.onFocus();
        });
      });
    }
    onOnline() {
      Le.batch(() => {
        this.getAll().forEach((e) => {
          e.onOnline();
        });
      });
    }
  }, _e12 = new WeakMap(), _j2), pk = (_k2 = class {
    constructor(e = {}) {
      __privateAdd(this, _e13);
      __privateAdd(this, _t10);
      __privateAdd(this, _n9);
      __privateAdd(this, _s6);
      __privateAdd(this, _r4);
      __privateAdd(this, _o4);
      __privateAdd(this, _a5);
      __privateAdd(this, _i4);
      __privateSet(this, _e13, e.queryCache || new hk()), __privateSet(this, _t10, e.mutationCache || new dk()), __privateSet(this, _n9, e.defaultOptions || {}), __privateSet(this, _s6, /* @__PURE__ */ new Map()), __privateSet(this, _r4, /* @__PURE__ */ new Map()), __privateSet(this, _o4, 0);
    }
    mount() {
      __privateWrapper(this, _o4)._++, __privateGet(this, _o4) === 1 && (__privateSet(this, _a5, Eh.subscribe(async (e) => {
        e && (await this.resumePausedMutations(), __privateGet(this, _e13).onFocus());
      })), __privateSet(this, _i4, vl.subscribe(async (e) => {
        e && (await this.resumePausedMutations(), __privateGet(this, _e13).onOnline());
      })));
    }
    unmount() {
      var _a6, _b3;
      __privateWrapper(this, _o4)._--, __privateGet(this, _o4) === 0 && ((_a6 = __privateGet(this, _a5)) == null ? void 0 : _a6.call(this), __privateSet(this, _a5, void 0), (_b3 = __privateGet(this, _i4)) == null ? void 0 : _b3.call(this), __privateSet(this, _i4, void 0));
    }
    isFetching(e) {
      return __privateGet(this, _e13).findAll({
        ...e,
        fetchStatus: "fetching"
      }).length;
    }
    isMutating(e) {
      return __privateGet(this, _t10).findAll({
        ...e,
        status: "pending"
      }).length;
    }
    getQueryData(e) {
      const t = this.defaultQueryOptions({
        queryKey: e
      });
      return __privateGet(this, _e13).get(t.queryHash)?.state.data;
    }
    ensureQueryData(e) {
      const t = this.defaultQueryOptions(e), n = __privateGet(this, _e13).build(this, t), r = n.state.data;
      return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(ur(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r));
    }
    getQueriesData(e) {
      return __privateGet(this, _e13).findAll(e).map(({ queryKey: t, state: n }) => {
        const r = n.data;
        return [
          t,
          r
        ];
      });
    }
    setQueryData(e, t, n) {
      const r = this.defaultQueryOptions({
        queryKey: e
      }), i = __privateGet(this, _e13).get(r.queryHash)?.state.data, o = GP(t, i);
      if (o !== void 0) return __privateGet(this, _e13).build(this, r).setData(o, {
        ...n,
        manual: true
      });
    }
    setQueriesData(e, t, n) {
      return Le.batch(() => __privateGet(this, _e13).findAll(e).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, t, n)
      ]));
    }
    getQueryState(e) {
      const t = this.defaultQueryOptions({
        queryKey: e
      });
      return __privateGet(this, _e13).get(t.queryHash)?.state;
    }
    removeQueries(e) {
      const t = __privateGet(this, _e13);
      Le.batch(() => {
        t.findAll(e).forEach((n) => {
          t.remove(n);
        });
      });
    }
    resetQueries(e, t) {
      const n = __privateGet(this, _e13);
      return Le.batch(() => (n.findAll(e).forEach((r) => {
        r.reset();
      }), this.refetchQueries({
        type: "active",
        ...e
      }, t)));
    }
    cancelQueries(e, t = {}) {
      const n = {
        revert: true,
        ...t
      }, r = Le.batch(() => __privateGet(this, _e13).findAll(e).map((s) => s.cancel(n)));
      return Promise.all(r).then(it).catch(it);
    }
    invalidateQueries(e, t = {}) {
      return Le.batch(() => (__privateGet(this, _e13).findAll(e).forEach((n) => {
        n.invalidate();
      }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries({
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      }, t)));
    }
    refetchQueries(e, t = {}) {
      const n = {
        ...t,
        cancelRefetch: t.cancelRefetch ?? true
      }, r = Le.batch(() => __privateGet(this, _e13).findAll(e).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let i = s.fetch(void 0, n);
        return n.throwOnError || (i = i.catch(it)), s.state.fetchStatus === "paused" ? Promise.resolve() : i;
      }));
      return Promise.all(r).then(it);
    }
    fetchQuery(e) {
      const t = this.defaultQueryOptions(e);
      t.retry === void 0 && (t.retry = false);
      const n = __privateGet(this, _e13).build(this, t);
      return n.isStaleByTime(ur(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data);
    }
    prefetchQuery(e) {
      return this.fetchQuery(e).then(it).catch(it);
    }
    fetchInfiniteQuery(e) {
      return e.behavior = rg(e.pages), this.fetchQuery(e);
    }
    prefetchInfiniteQuery(e) {
      return this.fetchInfiniteQuery(e).then(it).catch(it);
    }
    ensureInfiniteQueryData(e) {
      return e.behavior = rg(e.pages), this.ensureQueryData(e);
    }
    resumePausedMutations() {
      return vl.isOnline() ? __privateGet(this, _t10).resumePausedMutations() : Promise.resolve();
    }
    getQueryCache() {
      return __privateGet(this, _e13);
    }
    getMutationCache() {
      return __privateGet(this, _t10);
    }
    getDefaultOptions() {
      return __privateGet(this, _n9);
    }
    setDefaultOptions(e) {
      __privateSet(this, _n9, e);
    }
    setQueryDefaults(e, t) {
      __privateGet(this, _s6).set(Hr(e), {
        queryKey: e,
        defaultOptions: t
      });
    }
    getQueryDefaults(e) {
      const t = [
        ...__privateGet(this, _s6).values()
      ], n = {};
      return t.forEach((r) => {
        co(e, r.queryKey) && Object.assign(n, r.defaultOptions);
      }), n;
    }
    setMutationDefaults(e, t) {
      __privateGet(this, _r4).set(Hr(e), {
        mutationKey: e,
        defaultOptions: t
      });
    }
    getMutationDefaults(e) {
      const t = [
        ...__privateGet(this, _r4).values()
      ], n = {};
      return t.forEach((r) => {
        co(e, r.mutationKey) && Object.assign(n, r.defaultOptions);
      }), n;
    }
    defaultQueryOptions(e) {
      if (e._defaulted) return e;
      const t = {
        ...__privateGet(this, _n9).queries,
        ...this.getQueryDefaults(e.queryKey),
        ...e,
        _defaulted: true
      };
      return t.queryHash || (t.queryHash = bh(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === Th && (t.enabled = false), t;
    }
    defaultMutationOptions(e) {
      return e?._defaulted ? e : {
        ...__privateGet(this, _n9).mutations,
        ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
        ...e,
        _defaulted: true
      };
    }
    clear() {
      __privateGet(this, _e13).clear(), __privateGet(this, _t10).clear();
    }
  }, _e13 = new WeakMap(), _t10 = new WeakMap(), _n9 = new WeakMap(), _s6 = new WeakMap(), _r4 = new WeakMap(), _o4 = new WeakMap(), _a5 = new WeakMap(), _i4 = new WeakMap(), _k2), Xw = h.createContext(void 0), kh = (e) => {
    const t = h.useContext(Xw);
    if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t;
  }, mk = ({ client: e, children: t }) => (h.useEffect(() => (e.mount(), () => {
    e.unmount();
  }), [
    e
  ]), S.jsx(Xw.Provider, {
    value: e,
    children: t
  })), Jw = h.createContext(false), gk = () => h.useContext(Jw);
  Jw.Provider;
  function yk() {
    let e = false;
    return {
      clearReset: () => {
        e = false;
      },
      reset: () => {
        e = true;
      },
      isReset: () => e
    };
  }
  var vk = h.createContext(yk()), wk = () => h.useContext(vk), xk = (e, t, n) => {
    const r = n?.state.error && typeof e.throwOnError == "function" ? Ch(e.throwOnError, [
      n.state.error,
      n
    ]) : e.throwOnError;
    (e.suspense || e.experimental_prefetchInRender || r) && (t.isReset() || (e.retryOnMount = false));
  }, Sk = (e) => {
    h.useEffect(() => {
      e.clearReset();
    }, [
      e
    ]);
  }, bk = ({ result: e, errorResetBoundary: t, throwOnError: n, query: r, suspense: s }) => e.isError && !t.isReset() && !e.isFetching && r && (s && e.data === void 0 || Ch(n, [
    e.error,
    r
  ])), Tk = (e) => {
    if (e.suspense) {
      const n = (s) => s === "static" ? s : Math.max(s ?? 1e3, 1e3), r = e.staleTime;
      e.staleTime = typeof r == "function" ? (...s) => n(r(...s)) : n(r), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3));
    }
  }, Ck = (e, t) => e.isLoading && e.isFetching && !t, Ek = (e, t) => e?.suspense && t.isPending, ig = (e, t, n) => t.fetchOptimistic(e).catch(() => {
    n.clearReset();
  });
  function Pk(e, t, n) {
    const r = gk(), s = wk(), i = kh(), o = i.defaultQueryOptions(e);
    i.getDefaultOptions().queries?._experimental_beforeQuery?.(o);
    const a = i.getQueryCache().get(o.queryHash);
    o._optimisticResults = r ? "isRestoring" : "optimistic", Tk(o), xk(o, s, a), Sk(s);
    const l = !i.getQueryCache().get(o.queryHash), [u] = h.useState(() => new t(i, o)), c = u.getOptimisticResult(o), d = !r && e.subscribed !== false;
    if (h.useSyncExternalStore(h.useCallback((f) => {
      const p = d ? u.subscribe(Le.batchCalls(f)) : it;
      return u.updateResult(), p;
    }, [
      u,
      d
    ]), () => u.getCurrentResult(), () => u.getCurrentResult()), h.useEffect(() => {
      u.setOptions(o);
    }, [
      o,
      u
    ]), Ek(o, c)) throw ig(o, u, s);
    if (bk({
      result: c,
      errorResetBoundary: s,
      throwOnError: o.throwOnError,
      query: a,
      suspense: o.suspense
    })) throw c.error;
    return i.getDefaultOptions().queries?._experimental_afterQuery?.(o, c), o.experimental_prefetchInRender && !Wr && Ck(c, r) && (l ? ig(o, u, s) : a?.promise)?.catch(it).finally(() => {
      u.updateResult();
    }), o.notifyOnChangeProps ? c : u.trackResult(c);
  }
  function ex(e, t) {
    return Pk(e, ok);
  }
  function Tr(e, t) {
    const n = kh(), [r] = h.useState(() => new fk(n, e));
    h.useEffect(() => {
      r.setOptions(e);
    }, [
      r,
      e
    ]);
    const s = h.useSyncExternalStore(h.useCallback((o) => r.subscribe(Le.batchCalls(o)), [
      r
    ]), () => r.getCurrentResult(), () => r.getCurrentResult()), i = h.useCallback((o, a) => {
      r.mutate(o, a).catch(it);
    }, [
      r
    ]);
    if (s.error && Ch(r.options.throwOnError, [
      s.error
    ])) throw s.error;
    return {
      ...s,
      mutate: i,
      mutateAsync: s.mutate
    };
  }
  async function kk(e) {
    if (!e.ok) {
      const t = await e.text() || e.statusText;
      throw new Error(`${e.status}: ${t}`);
    }
  }
  const _k = ({ on401: e }) => async ({ queryKey: t }) => {
    const n = await fetch(t.join("/"), {
      credentials: "include"
    });
    return await kk(n), await n.json();
  }, Ak = new pk({
    defaultOptions: {
      queries: {
        queryFn: _k({
          on401: "throw"
        }),
        refetchInterval: false,
        refetchOnWindowFocus: false,
        staleTime: 1 / 0,
        retry: false
      },
      mutations: {
        retry: false
      }
    }
  }), Rk = 1, Nk = 1e6;
  let sc = 0;
  function Dk() {
    return sc = (sc + 1) % Number.MAX_SAFE_INTEGER, sc.toString();
  }
  const ic = /* @__PURE__ */ new Map(), og = (e) => {
    if (ic.has(e)) return;
    const t = setTimeout(() => {
      ic.delete(e), Ui({
        type: "REMOVE_TOAST",
        toastId: e
      });
    }, Nk);
    ic.set(e, t);
  }, Mk = (e, t) => {
    switch (t.type) {
      case "ADD_TOAST":
        return {
          ...e,
          toasts: [
            t.toast,
            ...e.toasts
          ].slice(0, Rk)
        };
      case "UPDATE_TOAST":
        return {
          ...e,
          toasts: e.toasts.map((n) => n.id === t.toast.id ? {
            ...n,
            ...t.toast
          } : n)
        };
      case "DISMISS_TOAST": {
        const { toastId: n } = t;
        return n ? og(n) : e.toasts.forEach((r) => {
          og(r.id);
        }), {
          ...e,
          toasts: e.toasts.map((r) => r.id === n || n === void 0 ? {
            ...r,
            open: false
          } : r)
        };
      }
      case "REMOVE_TOAST":
        return t.toastId === void 0 ? {
          ...e,
          toasts: []
        } : {
          ...e,
          toasts: e.toasts.filter((n) => n.id !== t.toastId)
        };
    }
  }, Fa = [];
  let za = {
    toasts: []
  };
  function Ui(e) {
    za = Mk(za, e), Fa.forEach((t) => {
      t(za);
    });
  }
  function Ok({ ...e }) {
    const t = Dk(), n = (s) => Ui({
      type: "UPDATE_TOAST",
      toast: {
        ...s,
        id: t
      }
    }), r = () => Ui({
      type: "DISMISS_TOAST",
      toastId: t
    });
    return Ui({
      type: "ADD_TOAST",
      toast: {
        ...e,
        id: t,
        open: true,
        onOpenChange: (s) => {
          s || r();
        }
      }
    }), {
      id: t,
      dismiss: r,
      update: n
    };
  }
  _h = function() {
    const [e, t] = h.useState(za);
    return h.useEffect(() => (Fa.push(t), () => {
      const n = Fa.indexOf(t);
      n > -1 && Fa.splice(n, 1);
    }), [
      e
    ]), {
      ...e,
      toast: Ok,
      dismiss: (n) => Ui({
        type: "DISMISS_TOAST",
        toastId: n
      })
    };
  };
  ae = function(e, t, { checkForDefaultPrevented: n = true } = {}) {
    return function(s) {
      if (e?.(s), n === false || !s.defaultPrevented) return t?.(s);
    };
  };
  function ag(e, t) {
    if (typeof e == "function") return e(t);
    e != null && (e.current = t);
  }
  zo = function(...e) {
    return (t) => {
      let n = false;
      const r = e.map((s) => {
        const i = ag(s, t);
        return !n && typeof i == "function" && (n = true), i;
      });
      if (n) return () => {
        for (let s = 0; s < r.length; s++) {
          const i = r[s];
          typeof i == "function" ? i() : ag(e[s], null);
        }
      };
    };
  };
  Me = function(...e) {
    return h.useCallback(zo(...e), e);
  };
  function Ik(e, t) {
    const n = h.createContext(t), r = (i) => {
      const { children: o, ...a } = i, l = h.useMemo(() => a, Object.values(a));
      return S.jsx(n.Provider, {
        value: l,
        children: o
      });
    };
    r.displayName = e + "Provider";
    function s(i) {
      const o = h.useContext(n);
      if (o) return o;
      if (t !== void 0) return t;
      throw new Error(`\`${i}\` must be used within \`${e}\``);
    }
    return [
      r,
      s
    ];
  }
  ii = function(e, t = []) {
    let n = [];
    function r(i, o) {
      const a = h.createContext(o), l = n.length;
      n = [
        ...n,
        o
      ];
      const u = (d) => {
        const { scope: f, children: p, ...w } = d, g = f?.[e]?.[l] || a, x = h.useMemo(() => w, Object.values(w));
        return S.jsx(g.Provider, {
          value: x,
          children: p
        });
      };
      u.displayName = i + "Provider";
      function c(d, f) {
        const p = f?.[e]?.[l] || a, w = h.useContext(p);
        if (w) return w;
        if (o !== void 0) return o;
        throw new Error(`\`${d}\` must be used within \`${i}\``);
      }
      return [
        u,
        c
      ];
    }
    const s = () => {
      const i = n.map((o) => h.createContext(o));
      return function(a) {
        const l = a?.[e] || i;
        return h.useMemo(() => ({
          [`__scope${e}`]: {
            ...a,
            [e]: l
          }
        }), [
          a,
          l
        ]);
      };
    };
    return s.scopeName = e, [
      r,
      Lk(s, ...t)
    ];
  };
  function Lk(...e) {
    const t = e[0];
    if (e.length === 1) return t;
    const n = () => {
      const r = e.map((s) => ({
        useScope: s(),
        scopeName: s.scopeName
      }));
      return function(i) {
        const o = r.reduce((a, { useScope: l, scopeName: u }) => {
          const d = l(i)[`__scope${u}`];
          return {
            ...a,
            ...d
          };
        }, {});
        return h.useMemo(() => ({
          [`__scope${t.scopeName}`]: o
        }), [
          o
        ]);
      };
    };
    return n.scopeName = t.scopeName, n;
  }
  function lg(e) {
    const t = jk(e), n = h.forwardRef((r, s) => {
      const { children: i, ...o } = r, a = h.Children.toArray(i), l = a.find(Fk);
      if (l) {
        const u = l.props.children, c = a.map((d) => d === l ? h.Children.count(u) > 1 ? h.Children.only(null) : h.isValidElement(u) ? u.props.children : null : d);
        return S.jsx(t, {
          ...o,
          ref: s,
          children: h.isValidElement(u) ? h.cloneElement(u, void 0, c) : null
        });
      }
      return S.jsx(t, {
        ...o,
        ref: s,
        children: i
      });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  function jk(e) {
    const t = h.forwardRef((n, r) => {
      const { children: s, ...i } = n;
      if (h.isValidElement(s)) {
        const o = Bk(s), a = zk(i, s.props);
        return s.type !== h.Fragment && (a.ref = r ? zo(r, o) : o), h.cloneElement(s, a);
      }
      return h.Children.count(s) > 1 ? h.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var Vk = Symbol("radix.slottable");
  function Fk(e) {
    return h.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Vk;
  }
  function zk(e, t) {
    const n = {
      ...t
    };
    for (const r in t) {
      const s = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
        const l = i(...a);
        return s(...a), l;
      } : s && (n[r] = s) : r === "style" ? n[r] = {
        ...s,
        ...i
      } : r === "className" && (n[r] = [
        s,
        i
      ].filter(Boolean).join(" "));
    }
    return {
      ...e,
      ...n
    };
  }
  function Bk(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  tx = function(e) {
    const t = e + "CollectionProvider", [n, r] = ii(t), [s, i] = n(t, {
      collectionRef: {
        current: null
      },
      itemMap: /* @__PURE__ */ new Map()
    }), o = (g) => {
      const { scope: x, children: m } = g, y = ce.useRef(null), v = ce.useRef(/* @__PURE__ */ new Map()).current;
      return S.jsx(s, {
        scope: x,
        itemMap: v,
        collectionRef: y,
        children: m
      });
    };
    o.displayName = t;
    const a = e + "CollectionSlot", l = lg(a), u = ce.forwardRef((g, x) => {
      const { scope: m, children: y } = g, v = i(a, m), b = Me(x, v.collectionRef);
      return S.jsx(l, {
        ref: b,
        children: y
      });
    });
    u.displayName = a;
    const c = e + "CollectionItemSlot", d = "data-radix-collection-item", f = lg(c), p = ce.forwardRef((g, x) => {
      const { scope: m, children: y, ...v } = g, b = ce.useRef(null), T = Me(x, b), C = i(c, m);
      return ce.useEffect(() => (C.itemMap.set(b, {
        ref: b,
        ...v
      }), () => void C.itemMap.delete(b))), S.jsx(f, {
        [d]: "",
        ref: T,
        children: y
      });
    });
    p.displayName = c;
    function w(g) {
      const x = i(e + "CollectionConsumer", g);
      return ce.useCallback(() => {
        const y = x.collectionRef.current;
        if (!y) return [];
        const v = Array.from(y.querySelectorAll(`[${d}]`));
        return Array.from(x.itemMap.values()).sort((C, E) => v.indexOf(C.ref.current) - v.indexOf(E.ref.current));
      }, [
        x.collectionRef,
        x.itemMap
      ]);
    }
    return [
      {
        Provider: o,
        Slot: u,
        ItemSlot: p
      },
      w,
      r
    ];
  };
  function Uk(e) {
    const t = $k(e), n = h.forwardRef((r, s) => {
      const { children: i, ...o } = r, a = h.Children.toArray(i), l = a.find(Hk);
      if (l) {
        const u = l.props.children, c = a.map((d) => d === l ? h.Children.count(u) > 1 ? h.Children.only(null) : h.isValidElement(u) ? u.props.children : null : d);
        return S.jsx(t, {
          ...o,
          ref: s,
          children: h.isValidElement(u) ? h.cloneElement(u, void 0, c) : null
        });
      }
      return S.jsx(t, {
        ...o,
        ref: s,
        children: i
      });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  function $k(e) {
    const t = h.forwardRef((n, r) => {
      const { children: s, ...i } = n;
      if (h.isValidElement(s)) {
        const o = Qk(s), a = Kk(i, s.props);
        return s.type !== h.Fragment && (a.ref = r ? zo(r, o) : o), h.cloneElement(s, a);
      }
      return h.Children.count(s) > 1 ? h.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var Wk = Symbol("radix.slottable");
  function Hk(e) {
    return h.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Wk;
  }
  function Kk(e, t) {
    const n = {
      ...t
    };
    for (const r in t) {
      const s = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
        const l = i(...a);
        return s(...a), l;
      } : s && (n[r] = s) : r === "style" ? n[r] = {
        ...s,
        ...i
      } : r === "className" && (n[r] = [
        s,
        i
      ].filter(Boolean).join(" "));
    }
    return {
      ...e,
      ...n
    };
  }
  function Qk(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  let Gk;
  Gk = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ];
  ye = Gk.reduce((e, t) => {
    const n = Uk(`Primitive.${t}`), r = h.forwardRef((s, i) => {
      const { asChild: o, ...a } = s, l = o ? n : t;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = true), S.jsx(l, {
        ...a,
        ref: i
      });
    });
    return r.displayName = `Primitive.${t}`, {
      ...e,
      [t]: r
    };
  }, {});
  nx = function(e, t) {
    e && Fo.flushSync(() => e.dispatchEvent(t));
  };
  mn = function(e) {
    const t = h.useRef(e);
    return h.useEffect(() => {
      t.current = e;
    }), h.useMemo(() => (...n) => t.current?.(...n), []);
  };
  function qk(e, t = globalThis?.document) {
    const n = mn(e);
    h.useEffect(() => {
      const r = (s) => {
        s.key === "Escape" && n(s);
      };
      return t.addEventListener("keydown", r, {
        capture: true
      }), () => t.removeEventListener("keydown", r, {
        capture: true
      });
    }, [
      n,
      t
    ]);
  }
  let Zk, jd, Yk, Xk, ug, rx;
  Zk = "DismissableLayer";
  jd = "dismissableLayer.update";
  Yk = "dismissableLayer.pointerDownOutside";
  Xk = "dismissableLayer.focusOutside";
  rx = h.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  lu = h.forwardRef((e, t) => {
    const { disableOutsidePointerEvents: n = false, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l } = e, u = h.useContext(rx), [c, d] = h.useState(null), f = c?.ownerDocument ?? globalThis?.document, [, p] = h.useState({}), w = Me(t, (E) => d(E)), g = Array.from(u.layers), [x] = [
      ...u.layersWithOutsidePointerEventsDisabled
    ].slice(-1), m = g.indexOf(x), y = c ? g.indexOf(c) : -1, v = u.layersWithOutsidePointerEventsDisabled.size > 0, b = y >= m, T = e_((E) => {
      const P = E.target, D = [
        ...u.branches
      ].some((A) => A.contains(P));
      !b || D || (s?.(E), o?.(E), E.defaultPrevented || a?.());
    }, f), C = t_((E) => {
      const P = E.target;
      [
        ...u.branches
      ].some((A) => A.contains(P)) || (i?.(E), o?.(E), E.defaultPrevented || a?.());
    }, f);
    return qk((E) => {
      y === u.layers.size - 1 && (r?.(E), !E.defaultPrevented && a && (E.preventDefault(), a()));
    }, f), h.useEffect(() => {
      if (c) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (ug = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), cg(), () => {
        n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = ug);
      };
    }, [
      c,
      f,
      n,
      u
    ]), h.useEffect(() => () => {
      c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), cg());
    }, [
      c,
      u
    ]), h.useEffect(() => {
      const E = () => p({});
      return document.addEventListener(jd, E), () => document.removeEventListener(jd, E);
    }, []), S.jsx(ye.div, {
      ...l,
      ref: w,
      style: {
        pointerEvents: v ? b ? "auto" : "none" : void 0,
        ...e.style
      },
      onFocusCapture: ae(e.onFocusCapture, C.onFocusCapture),
      onBlurCapture: ae(e.onBlurCapture, C.onBlurCapture),
      onPointerDownCapture: ae(e.onPointerDownCapture, T.onPointerDownCapture)
    });
  });
  lu.displayName = Zk;
  var Jk = "DismissableLayerBranch", sx = h.forwardRef((e, t) => {
    const n = h.useContext(rx), r = h.useRef(null), s = Me(t, r);
    return h.useEffect(() => {
      const i = r.current;
      if (i) return n.branches.add(i), () => {
        n.branches.delete(i);
      };
    }, [
      n.branches
    ]), S.jsx(ye.div, {
      ...e,
      ref: s
    });
  });
  sx.displayName = Jk;
  function e_(e, t = globalThis?.document) {
    const n = mn(e), r = h.useRef(false), s = h.useRef(() => {
    });
    return h.useEffect(() => {
      const i = (a) => {
        if (a.target && !r.current) {
          let l = function() {
            ix(Yk, n, u, {
              discrete: true
            });
          };
          const u = {
            originalEvent: a
          };
          a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, {
            once: true
          })) : l();
        } else t.removeEventListener("click", s.current);
        r.current = false;
      }, o = window.setTimeout(() => {
        t.addEventListener("pointerdown", i);
      }, 0);
      return () => {
        window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", s.current);
      };
    }, [
      t,
      n
    ]), {
      onPointerDownCapture: () => r.current = true
    };
  }
  function t_(e, t = globalThis?.document) {
    const n = mn(e), r = h.useRef(false);
    return h.useEffect(() => {
      const s = (i) => {
        i.target && !r.current && ix(Xk, n, {
          originalEvent: i
        }, {
          discrete: false
        });
      };
      return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s);
    }, [
      t,
      n
    ]), {
      onFocusCapture: () => r.current = true,
      onBlurCapture: () => r.current = false
    };
  }
  function cg() {
    const e = new CustomEvent(jd);
    document.dispatchEvent(e);
  }
  function ix(e, t, n, { discrete: r }) {
    const s = n.originalEvent.target, i = new CustomEvent(e, {
      bubbles: false,
      cancelable: true,
      detail: n
    });
    t && s.addEventListener(e, t, {
      once: true
    }), r ? nx(s, i) : s.dispatchEvent(i);
  }
  let n_, r_, jn, s_;
  n_ = lu;
  r_ = sx;
  jn = globalThis?.document ? h.useLayoutEffect : () => {
  };
  s_ = "Portal";
  Ah = h.forwardRef((e, t) => {
    const { container: n, ...r } = e, [s, i] = h.useState(false);
    jn(() => i(true), []);
    const o = n || s && globalThis?.document?.body;
    return o ? fP.createPortal(S.jsx(ye.div, {
      ...r,
      ref: t
    }), o) : null;
  });
  Ah.displayName = s_;
  function i_(e, t) {
    return h.useReducer((n, r) => t[n][r] ?? n, e);
  }
  oi = (e) => {
    const { present: t, children: n } = e, r = o_(t), s = typeof n == "function" ? n({
      present: r.isPresent
    }) : h.Children.only(n), i = Me(r.ref, a_(s));
    return typeof n == "function" || r.isPresent ? h.cloneElement(s, {
      ref: i
    }) : null;
  };
  oi.displayName = "Presence";
  function o_(e) {
    const [t, n] = h.useState(), r = h.useRef(null), s = h.useRef(e), i = h.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = i_(o, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return h.useEffect(() => {
      const u = pa(r.current);
      i.current = a === "mounted" ? u : "none";
    }, [
      a
    ]), jn(() => {
      const u = r.current, c = s.current;
      if (c !== e) {
        const f = i.current, p = pa(u);
        e ? l("MOUNT") : p === "none" || u?.display === "none" ? l("UNMOUNT") : l(c && f !== p ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e;
      }
    }, [
      e,
      l
    ]), jn(() => {
      if (t) {
        let u;
        const c = t.ownerDocument.defaultView ?? window, d = (p) => {
          const g = pa(r.current).includes(CSS.escape(p.animationName));
          if (p.target === t && g && (l("ANIMATION_END"), !s.current)) {
            const x = t.style.animationFillMode;
            t.style.animationFillMode = "forwards", u = c.setTimeout(() => {
              t.style.animationFillMode === "forwards" && (t.style.animationFillMode = x);
            });
          }
        }, f = (p) => {
          p.target === t && (i.current = pa(r.current));
        };
        return t.addEventListener("animationstart", f), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
          c.clearTimeout(u), t.removeEventListener("animationstart", f), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
        };
      } else l("ANIMATION_END");
    }, [
      t,
      l
    ]), {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(a),
      ref: h.useCallback((u) => {
        r.current = u ? getComputedStyle(u) : null, n(u);
      }, [])
    };
  }
  function pa(e) {
    return e?.animationName || "none";
  }
  function a_(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var l_ = Hl[" useInsertionEffect ".trim().toString()] || jn;
  Rh = function({ prop: e, defaultProp: t, onChange: n = () => {
  }, caller: r }) {
    const [s, i, o] = u_({
      defaultProp: t,
      onChange: n
    }), a = e !== void 0, l = a ? e : s;
    {
      const c = h.useRef(e !== void 0);
      h.useEffect(() => {
        const d = c.current;
        d !== a && console.warn(`${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), c.current = a;
      }, [
        a,
        r
      ]);
    }
    const u = h.useCallback((c) => {
      if (a) {
        const d = c_(c) ? c(e) : c;
        d !== e && o.current?.(d);
      } else i(c);
    }, [
      a,
      e,
      i,
      o
    ]);
    return [
      l,
      u
    ];
  };
  function u_({ defaultProp: e, onChange: t }) {
    const [n, r] = h.useState(e), s = h.useRef(n), i = h.useRef(t);
    return l_(() => {
      i.current = t;
    }, [
      t
    ]), h.useEffect(() => {
      s.current !== n && (i.current?.(n), s.current = n);
    }, [
      n,
      s
    ]), [
      n,
      r,
      i
    ];
  }
  function c_(e) {
    return typeof e == "function";
  }
  var d_ = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  }), f_ = "VisuallyHidden", uu = h.forwardRef((e, t) => S.jsx(ye.span, {
    ...e,
    ref: t,
    style: {
      ...d_,
      ...e.style
    }
  }));
  uu.displayName = f_;
  var h_ = uu, Nh = "ToastProvider", [Dh, p_, m_] = tx("Toast"), [ox] = ii("Toast", [
    m_
  ]), [g_, cu] = ox(Nh), ax = (e) => {
    const { __scopeToast: t, label: n = "Notification", duration: r = 5e3, swipeDirection: s = "right", swipeThreshold: i = 50, children: o } = e, [a, l] = h.useState(null), [u, c] = h.useState(0), d = h.useRef(false), f = h.useRef(false);
    return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${Nh}\`. Expected non-empty \`string\`.`), S.jsx(Dh.Provider, {
      scope: t,
      children: S.jsx(g_, {
        scope: t,
        label: n,
        duration: r,
        swipeDirection: s,
        swipeThreshold: i,
        toastCount: u,
        viewport: a,
        onViewportChange: l,
        onToastAdd: h.useCallback(() => c((p) => p + 1), []),
        onToastRemove: h.useCallback(() => c((p) => p - 1), []),
        isFocusedToastEscapeKeyDownRef: d,
        isClosePausedRef: f,
        children: o
      })
    });
  };
  ax.displayName = Nh;
  var lx = "ToastViewport", y_ = [
    "F8"
  ], Vd = "toast.viewportPause", Fd = "toast.viewportResume", ux = h.forwardRef((e, t) => {
    const { __scopeToast: n, hotkey: r = y_, label: s = "Notifications ({hotkey})", ...i } = e, o = cu(lx, n), a = p_(n), l = h.useRef(null), u = h.useRef(null), c = h.useRef(null), d = h.useRef(null), f = Me(t, d, o.onViewportChange), p = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = o.toastCount > 0;
    h.useEffect(() => {
      const x = (m) => {
        r.length !== 0 && r.every((v) => m[v] || m.code === v) && d.current?.focus();
      };
      return document.addEventListener("keydown", x), () => document.removeEventListener("keydown", x);
    }, [
      r
    ]), h.useEffect(() => {
      const x = l.current, m = d.current;
      if (w && x && m) {
        const y = () => {
          if (!o.isClosePausedRef.current) {
            const C = new CustomEvent(Vd);
            m.dispatchEvent(C), o.isClosePausedRef.current = true;
          }
        }, v = () => {
          if (o.isClosePausedRef.current) {
            const C = new CustomEvent(Fd);
            m.dispatchEvent(C), o.isClosePausedRef.current = false;
          }
        }, b = (C) => {
          !x.contains(C.relatedTarget) && v();
        }, T = () => {
          x.contains(document.activeElement) || v();
        };
        return x.addEventListener("focusin", y), x.addEventListener("focusout", b), x.addEventListener("pointermove", y), x.addEventListener("pointerleave", T), window.addEventListener("blur", y), window.addEventListener("focus", v), () => {
          x.removeEventListener("focusin", y), x.removeEventListener("focusout", b), x.removeEventListener("pointermove", y), x.removeEventListener("pointerleave", T), window.removeEventListener("blur", y), window.removeEventListener("focus", v);
        };
      }
    }, [
      w,
      o.isClosePausedRef
    ]);
    const g = h.useCallback(({ tabbingDirection: x }) => {
      const y = a().map((v) => {
        const b = v.ref.current, T = [
          b,
          ...R_(b)
        ];
        return x === "forwards" ? T : T.reverse();
      });
      return (x === "forwards" ? y.reverse() : y).flat();
    }, [
      a
    ]);
    return h.useEffect(() => {
      const x = d.current;
      if (x) {
        const m = (y) => {
          const v = y.altKey || y.ctrlKey || y.metaKey;
          if (y.key === "Tab" && !v) {
            const T = document.activeElement, C = y.shiftKey;
            if (y.target === x && C) {
              u.current?.focus();
              return;
            }
            const D = g({
              tabbingDirection: C ? "backwards" : "forwards"
            }), A = D.findIndex((M) => M === T);
            oc(D.slice(A + 1)) ? y.preventDefault() : C ? u.current?.focus() : c.current?.focus();
          }
        };
        return x.addEventListener("keydown", m), () => x.removeEventListener("keydown", m);
      }
    }, [
      a,
      g
    ]), S.jsxs(r_, {
      ref: l,
      role: "region",
      "aria-label": s.replace("{hotkey}", p),
      tabIndex: -1,
      style: {
        pointerEvents: w ? void 0 : "none"
      },
      children: [
        w && S.jsx(zd, {
          ref: u,
          onFocusFromOutsideViewport: () => {
            const x = g({
              tabbingDirection: "forwards"
            });
            oc(x);
          }
        }),
        S.jsx(Dh.Slot, {
          scope: n,
          children: S.jsx(ye.ol, {
            tabIndex: -1,
            ...i,
            ref: f
          })
        }),
        w && S.jsx(zd, {
          ref: c,
          onFocusFromOutsideViewport: () => {
            const x = g({
              tabbingDirection: "backwards"
            });
            oc(x);
          }
        })
      ]
    });
  });
  ux.displayName = lx;
  var cx = "ToastFocusProxy", zd = h.forwardRef((e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = e, i = cu(cx, n);
    return S.jsx(uu, {
      tabIndex: 0,
      ...s,
      ref: t,
      style: {
        position: "fixed"
      },
      onFocus: (o) => {
        const a = o.relatedTarget;
        !i.viewport?.contains(a) && r();
      }
    });
  });
  zd.displayName = cx;
  var Bo = "Toast", v_ = "toast.swipeStart", w_ = "toast.swipeMove", x_ = "toast.swipeCancel", S_ = "toast.swipeEnd", dx = h.forwardRef((e, t) => {
    const { forceMount: n, open: r, defaultOpen: s, onOpenChange: i, ...o } = e, [a, l] = Rh({
      prop: r,
      defaultProp: s ?? true,
      onChange: i,
      caller: Bo
    });
    return S.jsx(oi, {
      present: n || a,
      children: S.jsx(C_, {
        open: a,
        ...o,
        ref: t,
        onClose: () => l(false),
        onPause: mn(e.onPause),
        onResume: mn(e.onResume),
        onSwipeStart: ae(e.onSwipeStart, (u) => {
          u.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: ae(e.onSwipeMove, (u) => {
          const { x: c, y: d } = u.detail.delta;
          u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`);
        }),
        onSwipeCancel: ae(e.onSwipeCancel, (u) => {
          u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: ae(e.onSwipeEnd, (u) => {
          const { x: c, y: d } = u.detail.delta;
          u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), l(false);
        })
      })
    });
  });
  dx.displayName = Bo;
  var [b_, T_] = ox(Bo, {
    onClose() {
    }
  }), C_ = h.forwardRef((e, t) => {
    const { __scopeToast: n, type: r = "foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: u, onSwipeStart: c, onSwipeMove: d, onSwipeCancel: f, onSwipeEnd: p, ...w } = e, g = cu(Bo, n), [x, m] = h.useState(null), y = Me(t, (L) => m(L)), v = h.useRef(null), b = h.useRef(null), T = s || g.duration, C = h.useRef(0), E = h.useRef(T), P = h.useRef(0), { onToastAdd: D, onToastRemove: A } = g, M = mn(() => {
      x?.contains(document.activeElement) && g.viewport?.focus(), o();
    }), j = h.useCallback((L) => {
      !L || L === 1 / 0 || (window.clearTimeout(P.current), C.current = (/* @__PURE__ */ new Date()).getTime(), P.current = window.setTimeout(M, L));
    }, [
      M
    ]);
    h.useEffect(() => {
      const L = g.viewport;
      if (L) {
        const Z = () => {
          j(E.current), u?.();
        }, W = () => {
          const B = (/* @__PURE__ */ new Date()).getTime() - C.current;
          E.current = E.current - B, window.clearTimeout(P.current), l?.();
        };
        return L.addEventListener(Vd, W), L.addEventListener(Fd, Z), () => {
          L.removeEventListener(Vd, W), L.removeEventListener(Fd, Z);
        };
      }
    }, [
      g.viewport,
      T,
      l,
      u,
      j
    ]), h.useEffect(() => {
      i && !g.isClosePausedRef.current && j(T);
    }, [
      i,
      T,
      g.isClosePausedRef,
      j
    ]), h.useEffect(() => (D(), () => A()), [
      D,
      A
    ]);
    const Q = h.useMemo(() => x ? vx(x) : null, [
      x
    ]);
    return g.viewport ? S.jsxs(S.Fragment, {
      children: [
        Q && S.jsx(E_, {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          children: Q
        }),
        S.jsx(b_, {
          scope: n,
          onClose: M,
          children: Fo.createPortal(S.jsx(Dh.ItemSlot, {
            scope: n,
            children: S.jsx(n_, {
              asChild: true,
              onEscapeKeyDown: ae(a, () => {
                g.isFocusedToastEscapeKeyDownRef.current || M(), g.isFocusedToastEscapeKeyDownRef.current = false;
              }),
              children: S.jsx(ye.li, {
                tabIndex: 0,
                "data-state": i ? "open" : "closed",
                "data-swipe-direction": g.swipeDirection,
                ...w,
                ref: y,
                style: {
                  userSelect: "none",
                  touchAction: "none",
                  ...e.style
                },
                onKeyDown: ae(e.onKeyDown, (L) => {
                  L.key === "Escape" && (a?.(L.nativeEvent), L.nativeEvent.defaultPrevented || (g.isFocusedToastEscapeKeyDownRef.current = true, M()));
                }),
                onPointerDown: ae(e.onPointerDown, (L) => {
                  L.button === 0 && (v.current = {
                    x: L.clientX,
                    y: L.clientY
                  });
                }),
                onPointerMove: ae(e.onPointerMove, (L) => {
                  if (!v.current) return;
                  const Z = L.clientX - v.current.x, W = L.clientY - v.current.y, B = !!b.current, k = [
                    "left",
                    "right"
                  ].includes(g.swipeDirection), O = [
                    "left",
                    "up"
                  ].includes(g.swipeDirection) ? Math.min : Math.max, I = k ? O(0, Z) : 0, $ = k ? 0 : O(0, W), le = L.pointerType === "touch" ? 10 : 2, rt = {
                    x: I,
                    y: $
                  }, qe = {
                    originalEvent: L,
                    delta: rt
                  };
                  B ? (b.current = rt, ma(w_, d, qe, {
                    discrete: false
                  })) : dg(rt, g.swipeDirection, le) ? (b.current = rt, ma(v_, c, qe, {
                    discrete: false
                  }), L.target.setPointerCapture(L.pointerId)) : (Math.abs(Z) > le || Math.abs(W) > le) && (v.current = null);
                }),
                onPointerUp: ae(e.onPointerUp, (L) => {
                  const Z = b.current, W = L.target;
                  if (W.hasPointerCapture(L.pointerId) && W.releasePointerCapture(L.pointerId), b.current = null, v.current = null, Z) {
                    const B = L.currentTarget, k = {
                      originalEvent: L,
                      delta: Z
                    };
                    dg(Z, g.swipeDirection, g.swipeThreshold) ? ma(S_, p, k, {
                      discrete: true
                    }) : ma(x_, f, k, {
                      discrete: true
                    }), B.addEventListener("click", (O) => O.preventDefault(), {
                      once: true
                    });
                  }
                })
              })
            })
          }), g.viewport)
        })
      ]
    }) : null;
  }), E_ = (e) => {
    const { __scopeToast: t, children: n, ...r } = e, s = cu(Bo, t), [i, o] = h.useState(false), [a, l] = h.useState(false);
    return __(() => o(true)), h.useEffect(() => {
      const u = window.setTimeout(() => l(true), 1e3);
      return () => window.clearTimeout(u);
    }, []), a ? null : S.jsx(Ah, {
      asChild: true,
      children: S.jsx(uu, {
        ...r,
        children: i && S.jsxs(S.Fragment, {
          children: [
            s.label,
            " ",
            n
          ]
        })
      })
    });
  }, P_ = "ToastTitle", fx = h.forwardRef((e, t) => {
    const { __scopeToast: n, ...r } = e;
    return S.jsx(ye.div, {
      ...r,
      ref: t
    });
  });
  fx.displayName = P_;
  var k_ = "ToastDescription", hx = h.forwardRef((e, t) => {
    const { __scopeToast: n, ...r } = e;
    return S.jsx(ye.div, {
      ...r,
      ref: t
    });
  });
  hx.displayName = k_;
  var px = "ToastAction", mx = h.forwardRef((e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? S.jsx(yx, {
      altText: n,
      asChild: true,
      children: S.jsx(Mh, {
        ...r,
        ref: t
      })
    }) : (console.error(`Invalid prop \`altText\` supplied to \`${px}\`. Expected non-empty \`string\`.`), null);
  });
  mx.displayName = px;
  var gx = "ToastClose", Mh = h.forwardRef((e, t) => {
    const { __scopeToast: n, ...r } = e, s = T_(gx, n);
    return S.jsx(yx, {
      asChild: true,
      children: S.jsx(ye.button, {
        type: "button",
        ...r,
        ref: t,
        onClick: ae(e.onClick, s.onClose)
      })
    });
  });
  Mh.displayName = gx;
  var yx = h.forwardRef((e, t) => {
    const { __scopeToast: n, altText: r, ...s } = e;
    return S.jsx(ye.div, {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...s,
      ref: t
    });
  });
  function vx(e) {
    const t = [];
    return Array.from(e.childNodes).forEach((r) => {
      if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), A_(r)) {
        const s = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === "";
        if (!s) if (i) {
          const o = r.dataset.radixToastAnnounceAlt;
          o && t.push(o);
        } else t.push(...vx(r));
      }
    }), t;
  }
  function ma(e, t, n, { discrete: r }) {
    const s = n.originalEvent.currentTarget, i = new CustomEvent(e, {
      bubbles: true,
      cancelable: true,
      detail: n
    });
    t && s.addEventListener(e, t, {
      once: true
    }), r ? nx(s, i) : s.dispatchEvent(i);
  }
  var dg = (e, t, n = 0) => {
    const r = Math.abs(e.x), s = Math.abs(e.y), i = r > s;
    return t === "left" || t === "right" ? i && r > n : !i && s > n;
  };
  function __(e = () => {
  }) {
    const t = mn(e);
    jn(() => {
      let n = 0, r = 0;
      return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
        window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
      };
    }, [
      t
    ]);
  }
  function A_(e) {
    return e.nodeType === e.ELEMENT_NODE;
  }
  function R_(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const s = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function oc(e) {
    const t = document.activeElement;
    return e.some((n) => n === t ? true : (n.focus(), document.activeElement !== t));
  }
  var N_ = ax, wx = ux, xx = dx, Sx = fx, bx = hx, Tx = mx, Cx = Mh;
  function Ex(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number") r += e;
    else if (typeof e == "object") if (Array.isArray(e)) {
      var s = e.length;
      for (t = 0; t < s; t++) e[t] && (n = Ex(e[t])) && (r && (r += " "), r += n);
    } else for (n in e) e[n] && (r && (r += " "), r += n);
    return r;
  }
  function Px() {
    for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++) (e = arguments[n]) && (t = Ex(e)) && (r && (r += " "), r += t);
    return r;
  }
  const fg = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, hg = Px, kx = (e, t) => (n) => {
    var r;
    if (t?.variants == null) return hg(e, n?.class, n?.className);
    const { variants: s, defaultVariants: i } = t, o = Object.keys(s).map((u) => {
      const c = n?.[u], d = i?.[u];
      if (c === null) return null;
      const f = fg(c) || fg(d);
      return s[u][f];
    }), a = n && Object.entries(n).reduce((u, c) => {
      let [d, f] = c;
      return f === void 0 || (u[d] = f), u;
    }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => {
      let { class: d, className: f, ...p } = c;
      return Object.entries(p).every((w) => {
        let [g, x] = w;
        return Array.isArray(x) ? x.includes({
          ...i,
          ...a
        }[g]) : {
          ...i,
          ...a
        }[g] === x;
      }) ? [
        ...u,
        d,
        f
      ] : u;
    }, []);
    return hg(e, o, l, n?.class, n?.className);
  };
  const D_ = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), _x = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");
  var M_ = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };
  const O_ = h.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: s = "", children: i, iconNode: o, ...a }, l) => h.createElement("svg", {
    ref: l,
    ...M_,
    width: t,
    height: t,
    stroke: e,
    strokeWidth: r ? Number(n) * 24 / Number(t) : n,
    className: _x("lucide", s),
    ...a
  }, [
    ...o.map(([u, c]) => h.createElement(u, c)),
    ...Array.isArray(i) ? i : [
      i
    ]
  ]));
  Ue = (e, t) => {
    const n = h.forwardRef(({ className: r, ...s }, i) => h.createElement(O_, {
      ref: i,
      iconNode: t,
      className: _x(`lucide-${D_(e)}`, r),
      ...s
    }));
    return n.displayName = `${e}`, n;
  };
  I_ = Ue("ArrowLeft", [
    [
      "path",
      {
        d: "m12 19-7-7 7-7",
        key: "1l729n"
      }
    ],
    [
      "path",
      {
        d: "M19 12H5",
        key: "x3x0zl"
      }
    ]
  ]);
  L_ = Ue("CircleAlert", [
    [
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "10",
        key: "1mglay"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12",
        y1: "8",
        y2: "12",
        key: "1pkeuh"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12.01",
        y1: "16",
        y2: "16",
        key: "4dfq90"
      }
    ]
  ]);
  pg = Ue("CircleCheck", [
    [
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "10",
        key: "1mglay"
      }
    ],
    [
      "path",
      {
        d: "m9 12 2 2 4-4",
        key: "dzmm74"
      }
    ]
  ]);
  mg = Ue("Clock", [
    [
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "10",
        key: "1mglay"
      }
    ],
    [
      "polyline",
      {
        points: "12 6 12 12 16 14",
        key: "68esgv"
      }
    ]
  ]);
  ac = Ue("Copy", [
    [
      "rect",
      {
        width: "14",
        height: "14",
        x: "8",
        y: "8",
        rx: "2",
        ry: "2",
        key: "17jyea"
      }
    ],
    [
      "path",
      {
        d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
        key: "zix9uf"
      }
    ]
  ]);
  const j_ = Ue("EyeOff", [
    [
      "path",
      {
        d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
        key: "ct8e1f"
      }
    ],
    [
      "path",
      {
        d: "M14.084 14.158a3 3 0 0 1-4.242-4.242",
        key: "151rxh"
      }
    ],
    [
      "path",
      {
        d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
        key: "13bj9a"
      }
    ],
    [
      "path",
      {
        d: "m2 2 20 20",
        key: "1ooewy"
      }
    ]
  ]);
  gg = Ue("Eye", [
    [
      "path",
      {
        d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
        key: "1nclc0"
      }
    ],
    [
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "3",
        key: "1v7zrd"
      }
    ]
  ]);
  V_ = Ue("Globe", [
    [
      "circle",
      {
        cx: "12",
        cy: "12",
        r: "10",
        key: "1mglay"
      }
    ],
    [
      "path",
      {
        d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
        key: "13o1zl"
      }
    ],
    [
      "path",
      {
        d: "M2 12h20",
        key: "9i4pu4"
      }
    ]
  ]);
  F_ = Ue("LoaderCircle", [
    [
      "path",
      {
        d: "M21 12a9 9 0 1 1-6.219-8.56",
        key: "13zald"
      }
    ]
  ]);
  lc = Ue("Lock", [
    [
      "rect",
      {
        width: "18",
        height: "11",
        x: "3",
        y: "11",
        rx: "2",
        ry: "2",
        key: "1w4ew1"
      }
    ],
    [
      "path",
      {
        d: "M7 11V7a5 5 0 0 1 10 0v4",
        key: "fwvmzm"
      }
    ]
  ]);
  const z_ = Ue("Power", [
    [
      "path",
      {
        d: "M12 2v10",
        key: "mnfbl"
      }
    ],
    [
      "path",
      {
        d: "M18.4 6.6a9 9 0 1 1-12.77.04",
        key: "obofu9"
      }
    ]
  ]);
  const B_ = Ue("QrCode", [
    [
      "rect",
      {
        width: "5",
        height: "5",
        x: "3",
        y: "3",
        rx: "1",
        key: "1tu5fj"
      }
    ],
    [
      "rect",
      {
        width: "5",
        height: "5",
        x: "16",
        y: "3",
        rx: "1",
        key: "1v8r4q"
      }
    ],
    [
      "rect",
      {
        width: "5",
        height: "5",
        x: "3",
        y: "16",
        rx: "1",
        key: "1x03jg"
      }
    ],
    [
      "path",
      {
        d: "M21 16h-3a2 2 0 0 0-2 2v3",
        key: "177gqh"
      }
    ],
    [
      "path",
      {
        d: "M21 21v.01",
        key: "ents32"
      }
    ],
    [
      "path",
      {
        d: "M12 7v3a2 2 0 0 1-2 2H7",
        key: "8crl2c"
      }
    ],
    [
      "path",
      {
        d: "M3 12h.01",
        key: "nlz23k"
      }
    ],
    [
      "path",
      {
        d: "M12 3h.01",
        key: "n36tog"
      }
    ],
    [
      "path",
      {
        d: "M12 16v.01",
        key: "133mhm"
      }
    ],
    [
      "path",
      {
        d: "M16 12h1",
        key: "1slzba"
      }
    ],
    [
      "path",
      {
        d: "M21 12v.01",
        key: "1lwtk9"
      }
    ],
    [
      "path",
      {
        d: "M12 21v-1",
        key: "1880an"
      }
    ]
  ]);
  Ax = Ue("RefreshCw", [
    [
      "path",
      {
        d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
        key: "v9h5vc"
      }
    ],
    [
      "path",
      {
        d: "M21 3v5h-5",
        key: "1q7to0"
      }
    ],
    [
      "path",
      {
        d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
        key: "3uifl3"
      }
    ],
    [
      "path",
      {
        d: "M8 16H3v5",
        key: "1cv678"
      }
    ]
  ]);
  U_ = Ue("Shield", [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
        key: "oel41y"
      }
    ]
  ]);
  const yg = Ue("Terminal", [
    [
      "polyline",
      {
        points: "4 17 10 11 4 5",
        key: "akl6gq"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "20",
        y1: "19",
        y2: "19",
        key: "q2wloq"
      }
    ]
  ]);
  $_ = Ue("Trash2", [
    [
      "path",
      {
        d: "M3 6h18",
        key: "d0wm0j"
      }
    ],
    [
      "path",
      {
        d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
        key: "4alrt4"
      }
    ],
    [
      "path",
      {
        d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
        key: "v07s0e"
      }
    ],
    [
      "line",
      {
        x1: "10",
        x2: "10",
        y1: "11",
        y2: "17",
        key: "1uufr5"
      }
    ],
    [
      "line",
      {
        x1: "14",
        x2: "14",
        y1: "11",
        y2: "17",
        key: "xtxkd"
      }
    ]
  ]);
  const W_ = Ue("Wifi", [
    [
      "path",
      {
        d: "M12 20h.01",
        key: "zekei9"
      }
    ],
    [
      "path",
      {
        d: "M2 8.82a15 15 0 0 1 20 0",
        key: "dnpr2z"
      }
    ],
    [
      "path",
      {
        d: "M5 12.859a10 10 0 0 1 14 0",
        key: "1x1e6c"
      }
    ],
    [
      "path",
      {
        d: "M8.5 16.429a5 5 0 0 1 7 0",
        key: "1bycff"
      }
    ]
  ]);
  let Oh, H_, Nx, vg, K_, Q_, Bd, wg, G_, q_, Z_, Dx, Y_, X_, J_, eA, tA;
  Rx = Ue("X", [
    [
      "path",
      {
        d: "M18 6 6 18",
        key: "1bl5f8"
      }
    ],
    [
      "path",
      {
        d: "m6 6 12 12",
        key: "d8bk6v"
      }
    ]
  ]);
  Oh = "-";
  H_ = (e) => {
    const t = Q_(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e;
    return {
      getClassGroupId: (o) => {
        const a = o.split(Oh);
        return a[0] === "" && a.length !== 1 && a.shift(), Nx(a, t) || K_(o);
      },
      getConflictingClassGroupIds: (o, a) => {
        const l = n[o] || [];
        return a && r[o] ? [
          ...l,
          ...r[o]
        ] : l;
      }
    };
  };
  Nx = (e, t) => {
    if (e.length === 0) return t.classGroupId;
    const n = e[0], r = t.nextPart.get(n), s = r ? Nx(e.slice(1), r) : void 0;
    if (s) return s;
    if (t.validators.length === 0) return;
    const i = e.join(Oh);
    return t.validators.find(({ validator: o }) => o(i))?.classGroupId;
  };
  vg = /^\[(.+)\]$/;
  K_ = (e) => {
    if (vg.test(e)) {
      const t = vg.exec(e)[1], n = t?.substring(0, t.indexOf(":"));
      if (n) return "arbitrary.." + n;
    }
  };
  Q_ = (e) => {
    const { theme: t, prefix: n } = e, r = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    return q_(Object.entries(e.classGroups), n).forEach(([i, o]) => {
      Bd(o, r, i, t);
    }), r;
  };
  Bd = (e, t, n, r) => {
    e.forEach((s) => {
      if (typeof s == "string") {
        const i = s === "" ? t : wg(t, s);
        i.classGroupId = n;
        return;
      }
      if (typeof s == "function") {
        if (G_(s)) {
          Bd(s(r), t, n, r);
          return;
        }
        t.validators.push({
          validator: s,
          classGroupId: n
        });
        return;
      }
      Object.entries(s).forEach(([i, o]) => {
        Bd(o, wg(t, i), n, r);
      });
    });
  };
  wg = (e, t) => {
    let n = e;
    return t.split(Oh).forEach((r) => {
      n.nextPart.has(r) || n.nextPart.set(r, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      }), n = n.nextPart.get(r);
    }), n;
  };
  G_ = (e) => e.isThemeGetter;
  q_ = (e, t) => t ? e.map(([n, r]) => {
    const s = r.map((i) => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [
      t + o,
      a
    ])) : i);
    return [
      n,
      s
    ];
  }) : e;
  Z_ = (e) => {
    if (e < 1) return {
      get: () => {
      },
      set: () => {
      }
    };
    let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
    const s = (i, o) => {
      n.set(i, o), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());
    };
    return {
      get(i) {
        let o = n.get(i);
        if (o !== void 0) return o;
        if ((o = r.get(i)) !== void 0) return s(i, o), o;
      },
      set(i, o) {
        n.has(i) ? n.set(i, o) : s(i, o);
      }
    };
  };
  Dx = "!";
  Y_ = (e) => {
    const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, s = t[0], i = t.length, o = (a) => {
      const l = [];
      let u = 0, c = 0, d;
      for (let x = 0; x < a.length; x++) {
        let m = a[x];
        if (u === 0) {
          if (m === s && (r || a.slice(x, x + i) === t)) {
            l.push(a.slice(c, x)), c = x + i;
            continue;
          }
          if (m === "/") {
            d = x;
            continue;
          }
        }
        m === "[" ? u++ : m === "]" && u--;
      }
      const f = l.length === 0 ? a : a.substring(c), p = f.startsWith(Dx), w = p ? f.substring(1) : f, g = d && d > c ? d - c : void 0;
      return {
        modifiers: l,
        hasImportantModifier: p,
        baseClassName: w,
        maybePostfixModifierPosition: g
      };
    };
    return n ? (a) => n({
      className: a,
      parseClassName: o
    }) : o;
  };
  X_ = (e) => {
    if (e.length <= 1) return e;
    const t = [];
    let n = [];
    return e.forEach((r) => {
      r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r);
    }), t.push(...n.sort()), t;
  };
  J_ = (e) => ({
    cache: Z_(e.cacheSize),
    parseClassName: Y_(e),
    ...H_(e)
  });
  eA = /\s+/;
  tA = (e, t) => {
    const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s } = t, i = [], o = e.trim().split(eA);
    let a = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const u = o[l], { modifiers: c, hasImportantModifier: d, baseClassName: f, maybePostfixModifierPosition: p } = n(u);
      let w = !!p, g = r(w ? f.substring(0, p) : f);
      if (!g) {
        if (!w) {
          a = u + (a.length > 0 ? " " + a : a);
          continue;
        }
        if (g = r(f), !g) {
          a = u + (a.length > 0 ? " " + a : a);
          continue;
        }
        w = false;
      }
      const x = X_(c).join(":"), m = d ? x + Dx : x, y = m + g;
      if (i.includes(y)) continue;
      i.push(y);
      const v = s(g, w);
      for (let b = 0; b < v.length; ++b) {
        const T = v[b];
        i.push(m + T);
      }
      a = u + (a.length > 0 ? " " + a : a);
    }
    return a;
  };
  function nA() {
    let e = 0, t, n, r = "";
    for (; e < arguments.length; ) (t = arguments[e++]) && (n = Mx(t)) && (r && (r += " "), r += n);
    return r;
  }
  const Mx = (e) => {
    if (typeof e == "string") return e;
    let t, n = "";
    for (let r = 0; r < e.length; r++) e[r] && (t = Mx(e[r])) && (n && (n += " "), n += t);
    return n;
  };
  function rA(e, ...t) {
    let n, r, s, i = o;
    function o(l) {
      const u = t.reduce((c, d) => d(c), e());
      return n = J_(u), r = n.cache.get, s = n.cache.set, i = a, a(l);
    }
    function a(l) {
      const u = r(l);
      if (u) return u;
      const c = tA(l, n);
      return s(l, c), c;
    }
    return function() {
      return i(nA.apply(null, arguments));
    };
  }
  const he = (e) => {
    const t = (n) => n[e] || [];
    return t.isThemeGetter = true, t;
  }, Ox = /^\[(?:([a-z-]+):)?(.+)\]$/i, sA = /^\d+\/\d+$/, iA = /* @__PURE__ */ new Set([
    "px",
    "full",
    "screen"
  ]), oA = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, aA = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, lA = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, uA = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, cA = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Sn = (e) => Ns(e) || iA.has(e) || sA.test(e), Hn = (e) => ai(e, "length", vA), Ns = (e) => !!e && !Number.isNaN(Number(e)), uc = (e) => ai(e, "number", Ns), bi = (e) => !!e && Number.isInteger(Number(e)), dA = (e) => e.endsWith("%") && Ns(e.slice(0, -1)), X = (e) => Ox.test(e), Kn = (e) => oA.test(e), fA = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]), hA = (e) => ai(e, fA, Ix), pA = (e) => ai(e, "position", Ix), mA = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]), gA = (e) => ai(e, mA, xA), yA = (e) => ai(e, "", wA), Ti = () => true, ai = (e, t, n) => {
    const r = Ox.exec(e);
    return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : false;
  }, vA = (e) => aA.test(e) && !lA.test(e), Ix = () => false, wA = (e) => uA.test(e), xA = (e) => cA.test(e), SA = () => {
    const e = he("colors"), t = he("spacing"), n = he("blur"), r = he("brightness"), s = he("borderColor"), i = he("borderRadius"), o = he("borderSpacing"), a = he("borderWidth"), l = he("contrast"), u = he("grayscale"), c = he("hueRotate"), d = he("invert"), f = he("gap"), p = he("gradientColorStops"), w = he("gradientColorStopPositions"), g = he("inset"), x = he("margin"), m = he("opacity"), y = he("padding"), v = he("saturate"), b = he("scale"), T = he("sepia"), C = he("skew"), E = he("space"), P = he("translate"), D = () => [
      "auto",
      "contain",
      "none"
    ], A = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ], M = () => [
      "auto",
      X,
      t
    ], j = () => [
      X,
      t
    ], Q = () => [
      "",
      Sn,
      Hn
    ], L = () => [
      "auto",
      Ns,
      X
    ], Z = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ], W = () => [
      "solid",
      "dashed",
      "dotted",
      "double",
      "none"
    ], B = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ], k = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch"
    ], O = () => [
      "",
      "0",
      X
    ], I = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ], $ = () => [
      Ns,
      X
    ];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [
          Ti
        ],
        spacing: [
          Sn,
          Hn
        ],
        blur: [
          "none",
          "",
          Kn,
          X
        ],
        brightness: $(),
        borderColor: [
          e
        ],
        borderRadius: [
          "none",
          "",
          "full",
          Kn,
          X
        ],
        borderSpacing: j(),
        borderWidth: Q(),
        contrast: $(),
        grayscale: O(),
        hueRotate: $(),
        invert: O(),
        gap: j(),
        gradientColorStops: [
          e
        ],
        gradientColorStopPositions: [
          dA,
          Hn
        ],
        inset: M(),
        margin: M(),
        opacity: $(),
        padding: j(),
        saturate: $(),
        scale: $(),
        sepia: O(),
        skew: $(),
        space: j(),
        translate: j()
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              "video",
              X
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              Kn
            ]
          }
        ],
        "break-after": [
          {
            "break-after": I()
          }
        ],
        "break-before": [
          {
            "break-before": I()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ...Z(),
              X
            ]
          }
        ],
        overflow: [
          {
            overflow: A()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": A()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": A()
          }
        ],
        overscroll: [
          {
            overscroll: D()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": D()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": D()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: [
              g
            ]
          }
        ],
        "inset-x": [
          {
            "inset-x": [
              g
            ]
          }
        ],
        "inset-y": [
          {
            "inset-y": [
              g
            ]
          }
        ],
        start: [
          {
            start: [
              g
            ]
          }
        ],
        end: [
          {
            end: [
              g
            ]
          }
        ],
        top: [
          {
            top: [
              g
            ]
          }
        ],
        right: [
          {
            right: [
              g
            ]
          }
        ],
        bottom: [
          {
            bottom: [
              g
            ]
          }
        ],
        left: [
          {
            left: [
              g
            ]
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              "auto",
              bi,
              X
            ]
          }
        ],
        basis: [
          {
            basis: M()
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "wrap",
              "wrap-reverse",
              "nowrap"
            ]
          }
        ],
        flex: [
          {
            flex: [
              "1",
              "auto",
              "initial",
              "none",
              X
            ]
          }
        ],
        grow: [
          {
            grow: O()
          }
        ],
        shrink: [
          {
            shrink: O()
          }
        ],
        order: [
          {
            order: [
              "first",
              "last",
              "none",
              bi,
              X
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": [
              Ti
            ]
          }
        ],
        "col-start-end": [
          {
            col: [
              "auto",
              {
                span: [
                  "full",
                  bi,
                  X
                ]
              },
              X
            ]
          }
        ],
        "col-start": [
          {
            "col-start": L()
          }
        ],
        "col-end": [
          {
            "col-end": L()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": [
              Ti
            ]
          }
        ],
        "row-start-end": [
          {
            row: [
              "auto",
              {
                span: [
                  bi,
                  X
                ]
              },
              X
            ]
          }
        ],
        "row-start": [
          {
            "row-start": L()
          }
        ],
        "row-end": [
          {
            "row-end": L()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": [
              "auto",
              "min",
              "max",
              "fr",
              X
            ]
          }
        ],
        "auto-rows": [
          {
            "auto-rows": [
              "auto",
              "min",
              "max",
              "fr",
              X
            ]
          }
        ],
        gap: [
          {
            gap: [
              f
            ]
          }
        ],
        "gap-x": [
          {
            "gap-x": [
              f
            ]
          }
        ],
        "gap-y": [
          {
            "gap-y": [
              f
            ]
          }
        ],
        "justify-content": [
          {
            justify: [
              "normal",
              ...k()
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...k(),
              "baseline"
            ]
          }
        ],
        "align-items": [
          {
            items: [
              "start",
              "end",
              "center",
              "baseline",
              "stretch"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              "start",
              "end",
              "center",
              "stretch",
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": [
              ...k(),
              "baseline"
            ]
          }
        ],
        "place-items": [
          {
            "place-items": [
              "start",
              "end",
              "center",
              "baseline",
              "stretch"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        p: [
          {
            p: [
              y
            ]
          }
        ],
        px: [
          {
            px: [
              y
            ]
          }
        ],
        py: [
          {
            py: [
              y
            ]
          }
        ],
        ps: [
          {
            ps: [
              y
            ]
          }
        ],
        pe: [
          {
            pe: [
              y
            ]
          }
        ],
        pt: [
          {
            pt: [
              y
            ]
          }
        ],
        pr: [
          {
            pr: [
              y
            ]
          }
        ],
        pb: [
          {
            pb: [
              y
            ]
          }
        ],
        pl: [
          {
            pl: [
              y
            ]
          }
        ],
        m: [
          {
            m: [
              x
            ]
          }
        ],
        mx: [
          {
            mx: [
              x
            ]
          }
        ],
        my: [
          {
            my: [
              x
            ]
          }
        ],
        ms: [
          {
            ms: [
              x
            ]
          }
        ],
        me: [
          {
            me: [
              x
            ]
          }
        ],
        mt: [
          {
            mt: [
              x
            ]
          }
        ],
        mr: [
          {
            mr: [
              x
            ]
          }
        ],
        mb: [
          {
            mb: [
              x
            ]
          }
        ],
        ml: [
          {
            ml: [
              x
            ]
          }
        ],
        "space-x": [
          {
            "space-x": [
              E
            ]
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": [
              E
            ]
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        w: [
          {
            w: [
              "auto",
              "min",
              "max",
              "fit",
              "svw",
              "lvw",
              "dvw",
              X,
              t
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              X,
              t,
              "min",
              "max",
              "fit"
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              X,
              t,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              {
                screen: [
                  Kn
                ]
              },
              Kn
            ]
          }
        ],
        h: [
          {
            h: [
              X,
              t,
              "auto",
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              X,
              t,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              X,
              t,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        size: [
          {
            size: [
              X,
              t,
              "auto",
              "min",
              "max",
              "fit"
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              Kn,
              Hn
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              uc
            ]
          }
        ],
        "font-family": [
          {
            font: [
              Ti
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractions"
        ],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              X
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              "none",
              Ns,
              uc
            ]
          }
        ],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              Sn,
              X
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              X
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "none",
              "disc",
              "decimal",
              X
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: [
              e
            ]
          }
        ],
        "placeholder-opacity": [
          {
            "placeholder-opacity": [
              m
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "text-color": [
          {
            text: [
              e
            ]
          }
        ],
        "text-opacity": [
          {
            "text-opacity": [
              m
            ]
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...W(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              "auto",
              "from-font",
              Sn,
              Hn
            ]
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              "auto",
              Sn,
              X
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: [
              e
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: j()
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              X
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              X
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-opacity": [
          {
            "bg-opacity": [
              m
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ...Z(),
              pA
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "round",
                  "space"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              hA
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                "gradient-to": [
                  "t",
                  "tr",
                  "r",
                  "br",
                  "b",
                  "bl",
                  "l",
                  "tl"
                ]
              },
              gA
            ]
          }
        ],
        "bg-color": [
          {
            bg: [
              e
            ]
          }
        ],
        "gradient-from-pos": [
          {
            from: [
              w
            ]
          }
        ],
        "gradient-via-pos": [
          {
            via: [
              w
            ]
          }
        ],
        "gradient-to-pos": [
          {
            to: [
              w
            ]
          }
        ],
        "gradient-from": [
          {
            from: [
              p
            ]
          }
        ],
        "gradient-via": [
          {
            via: [
              p
            ]
          }
        ],
        "gradient-to": [
          {
            to: [
              p
            ]
          }
        ],
        rounded: [
          {
            rounded: [
              i
            ]
          }
        ],
        "rounded-s": [
          {
            "rounded-s": [
              i
            ]
          }
        ],
        "rounded-e": [
          {
            "rounded-e": [
              i
            ]
          }
        ],
        "rounded-t": [
          {
            "rounded-t": [
              i
            ]
          }
        ],
        "rounded-r": [
          {
            "rounded-r": [
              i
            ]
          }
        ],
        "rounded-b": [
          {
            "rounded-b": [
              i
            ]
          }
        ],
        "rounded-l": [
          {
            "rounded-l": [
              i
            ]
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": [
              i
            ]
          }
        ],
        "rounded-se": [
          {
            "rounded-se": [
              i
            ]
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": [
              i
            ]
          }
        ],
        "rounded-es": [
          {
            "rounded-es": [
              i
            ]
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": [
              i
            ]
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": [
              i
            ]
          }
        ],
        "rounded-br": [
          {
            "rounded-br": [
              i
            ]
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": [
              i
            ]
          }
        ],
        "border-w": [
          {
            border: [
              a
            ]
          }
        ],
        "border-w-x": [
          {
            "border-x": [
              a
            ]
          }
        ],
        "border-w-y": [
          {
            "border-y": [
              a
            ]
          }
        ],
        "border-w-s": [
          {
            "border-s": [
              a
            ]
          }
        ],
        "border-w-e": [
          {
            "border-e": [
              a
            ]
          }
        ],
        "border-w-t": [
          {
            "border-t": [
              a
            ]
          }
        ],
        "border-w-r": [
          {
            "border-r": [
              a
            ]
          }
        ],
        "border-w-b": [
          {
            "border-b": [
              a
            ]
          }
        ],
        "border-w-l": [
          {
            "border-l": [
              a
            ]
          }
        ],
        "border-opacity": [
          {
            "border-opacity": [
              m
            ]
          }
        ],
        "border-style": [
          {
            border: [
              ...W(),
              "hidden"
            ]
          }
        ],
        "divide-x": [
          {
            "divide-x": [
              a
            ]
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": [
              a
            ]
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "divide-opacity": [
          {
            "divide-opacity": [
              m
            ]
          }
        ],
        "divide-style": [
          {
            divide: W()
          }
        ],
        "border-color": [
          {
            border: [
              s
            ]
          }
        ],
        "border-color-x": [
          {
            "border-x": [
              s
            ]
          }
        ],
        "border-color-y": [
          {
            "border-y": [
              s
            ]
          }
        ],
        "border-color-s": [
          {
            "border-s": [
              s
            ]
          }
        ],
        "border-color-e": [
          {
            "border-e": [
              s
            ]
          }
        ],
        "border-color-t": [
          {
            "border-t": [
              s
            ]
          }
        ],
        "border-color-r": [
          {
            "border-r": [
              s
            ]
          }
        ],
        "border-color-b": [
          {
            "border-b": [
              s
            ]
          }
        ],
        "border-color-l": [
          {
            "border-l": [
              s
            ]
          }
        ],
        "divide-color": [
          {
            divide: [
              s
            ]
          }
        ],
        "outline-style": [
          {
            outline: [
              "",
              ...W()
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              Sn,
              X
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              Sn,
              Hn
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              e
            ]
          }
        ],
        "ring-w": [
          {
            ring: Q()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: [
              e
            ]
          }
        ],
        "ring-opacity": [
          {
            "ring-opacity": [
              m
            ]
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              Sn,
              Hn
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": [
              e
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "inner",
              "none",
              Kn,
              yA
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: [
              Ti
            ]
          }
        ],
        opacity: [
          {
            opacity: [
              m
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...B(),
              "plus-lighter",
              "plus-darker"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": B()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none"
            ]
          }
        ],
        blur: [
          {
            blur: [
              n
            ]
          }
        ],
        brightness: [
          {
            brightness: [
              r
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              l
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              Kn,
              X
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              u
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              c
            ]
          }
        ],
        invert: [
          {
            invert: [
              d
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              v
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              T
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none"
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": [
              n
            ]
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              r
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              l
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              u
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              c
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              d
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              m
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              v
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              T
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": [
              o
            ]
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": [
              o
            ]
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": [
              o
            ]
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              X
            ]
          }
        ],
        duration: [
          {
            duration: $()
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "in",
              "out",
              "in-out",
              X
            ]
          }
        ],
        delay: [
          {
            delay: $()
          }
        ],
        animate: [
          {
            animate: [
              "none",
              "spin",
              "ping",
              "pulse",
              "bounce",
              X
            ]
          }
        ],
        transform: [
          {
            transform: [
              "",
              "gpu",
              "none"
            ]
          }
        ],
        scale: [
          {
            scale: [
              b
            ]
          }
        ],
        "scale-x": [
          {
            "scale-x": [
              b
            ]
          }
        ],
        "scale-y": [
          {
            "scale-y": [
              b
            ]
          }
        ],
        rotate: [
          {
            rotate: [
              bi,
              X
            ]
          }
        ],
        "translate-x": [
          {
            "translate-x": [
              P
            ]
          }
        ],
        "translate-y": [
          {
            "translate-y": [
              P
            ]
          }
        ],
        "skew-x": [
          {
            "skew-x": [
              C
            ]
          }
        ],
        "skew-y": [
          {
            "skew-y": [
              C
            ]
          }
        ],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              X
            ]
          }
        ],
        accent: [
          {
            accent: [
              "auto",
              e
            ]
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              X
            ]
          }
        ],
        "caret-color": [
          {
            caret: [
              e
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "none",
              "auto"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "y",
              "x",
              ""
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": j()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": j()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": j()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": j()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": j()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": j()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": j()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": j()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": j()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": j()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": j()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": j()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": j()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": j()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": j()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": j()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": j()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": j()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              X
            ]
          }
        ],
        fill: [
          {
            fill: [
              e,
              "none"
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              Sn,
              Hn,
              uc
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              e,
              "none"
            ]
          }
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      }
    };
  }, bA = rA(SA);
  ct = function(...e) {
    return bA(Px(e));
  };
  const TA = N_, Lx = h.forwardRef(({ className: e, ...t }, n) => S.jsx(wx, {
    ref: n,
    className: ct("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e),
    ...t
  }));
  Lx.displayName = wx.displayName;
  const CA = kx("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }), jx = h.forwardRef(({ className: e, variant: t, ...n }, r) => S.jsx(xx, {
    ref: r,
    className: ct(CA({
      variant: t
    }), e),
    ...n
  }));
  jx.displayName = xx.displayName;
  const EA = h.forwardRef(({ className: e, ...t }, n) => S.jsx(Tx, {
    ref: n,
    className: ct("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", e),
    ...t
  }));
  EA.displayName = Tx.displayName;
  const Vx = h.forwardRef(({ className: e, ...t }, n) => S.jsx(Cx, {
    ref: n,
    className: ct("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e),
    "toast-close": "",
    ...t,
    children: S.jsx(Rx, {
      className: "h-4 w-4"
    })
  }));
  Vx.displayName = Cx.displayName;
  const Fx = h.forwardRef(({ className: e, ...t }, n) => S.jsx(Sx, {
    ref: n,
    className: ct("text-sm font-semibold", e),
    ...t
  }));
  Fx.displayName = Sx.displayName;
  const zx = h.forwardRef(({ className: e, ...t }, n) => S.jsx(bx, {
    ref: n,
    className: ct("text-sm opacity-90", e),
    ...t
  }));
  zx.displayName = bx.displayName;
  function PA() {
    const { toasts: e } = _h();
    return S.jsxs(TA, {
      children: [
        e.map(function({ id: t, title: n, description: r, action: s, ...i }) {
          return S.jsxs(jx, {
            ...i,
            children: [
              S.jsxs("div", {
                className: "grid gap-1",
                children: [
                  n && S.jsx(Fx, {
                    children: n
                  }),
                  r && S.jsx(zx, {
                    children: r
                  })
                ]
              }),
              s,
              S.jsx(Vx, {})
            ]
          }, t);
        }),
        S.jsx(Lx, {})
      ]
    });
  }
  var kA = Hl[" useId ".trim().toString()] || (() => {
  }), _A = 0;
  cc = function(e) {
    const [t, n] = h.useState(kA());
    return jn(() => {
      n((r) => r ?? String(_A++));
    }, [
      e
    ]), e || (t ? `radix-${t}` : "");
  };
  const AA = [
    "top",
    "right",
    "bottom",
    "left"
  ], fr = Math.min, xt = Math.max, wl = Math.round, ga = Math.floor, dn = (e) => ({
    x: e,
    y: e
  }), RA = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  }, NA = {
    start: "end",
    end: "start"
  };
  function Ud(e, t, n) {
    return xt(e, fr(t, n));
  }
  function Vn(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Fn(e) {
    return e.split("-")[0];
  }
  function li(e) {
    return e.split("-")[1];
  }
  function Ih(e) {
    return e === "x" ? "y" : "x";
  }
  function Lh(e) {
    return e === "y" ? "height" : "width";
  }
  const DA = /* @__PURE__ */ new Set([
    "top",
    "bottom"
  ]);
  function ln(e) {
    return DA.has(Fn(e)) ? "y" : "x";
  }
  function jh(e) {
    return Ih(ln(e));
  }
  function MA(e, t, n) {
    n === void 0 && (n = false);
    const r = li(e), s = jh(e), i = Lh(s);
    let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return t.reference[i] > t.floating[i] && (o = xl(o)), [
      o,
      xl(o)
    ];
  }
  function OA(e) {
    const t = xl(e);
    return [
      $d(e),
      t,
      $d(t)
    ];
  }
  function $d(e) {
    return e.replace(/start|end/g, (t) => NA[t]);
  }
  const xg = [
    "left",
    "right"
  ], Sg = [
    "right",
    "left"
  ], IA = [
    "top",
    "bottom"
  ], LA = [
    "bottom",
    "top"
  ];
  function jA(e, t, n) {
    switch (e) {
      case "top":
      case "bottom":
        return n ? t ? Sg : xg : t ? xg : Sg;
      case "left":
      case "right":
        return t ? IA : LA;
      default:
        return [];
    }
  }
  function VA(e, t, n, r) {
    const s = li(e);
    let i = jA(Fn(e), n === "start", r);
    return s && (i = i.map((o) => o + "-" + s), t && (i = i.concat(i.map($d)))), i;
  }
  function xl(e) {
    return e.replace(/left|right|bottom|top/g, (t) => RA[t]);
  }
  function FA(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function Bx(e) {
    return typeof e != "number" ? FA(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function Sl(e) {
    const { x: t, y: n, width: r, height: s } = e;
    return {
      width: r,
      height: s,
      top: n,
      left: t,
      right: t + r,
      bottom: n + s,
      x: t,
      y: n
    };
  }
  function bg(e, t, n) {
    let { reference: r, floating: s } = e;
    const i = ln(t), o = jh(t), a = Lh(o), l = Fn(t), u = i === "y", c = r.x + r.width / 2 - s.width / 2, d = r.y + r.height / 2 - s.height / 2, f = r[a] / 2 - s[a] / 2;
    let p;
    switch (l) {
      case "top":
        p = {
          x: c,
          y: r.y - s.height
        };
        break;
      case "bottom":
        p = {
          x: c,
          y: r.y + r.height
        };
        break;
      case "right":
        p = {
          x: r.x + r.width,
          y: d
        };
        break;
      case "left":
        p = {
          x: r.x - s.width,
          y: d
        };
        break;
      default:
        p = {
          x: r.x,
          y: r.y
        };
    }
    switch (li(t)) {
      case "start":
        p[o] -= f * (n && u ? -1 : 1);
        break;
      case "end":
        p[o] += f * (n && u ? -1 : 1);
        break;
    }
    return p;
  }
  async function zA(e, t) {
    var n;
    t === void 0 && (t = {});
    const { x: r, y: s, platform: i, rects: o, elements: a, strategy: l } = e, { boundary: u = "clippingAncestors", rootBoundary: c = "viewport", elementContext: d = "floating", altBoundary: f = false, padding: p = 0 } = Vn(t, e), w = Bx(p), x = a[f ? d === "floating" ? "reference" : "floating" : d], m = Sl(await i.getClippingRect({
      element: (n = await (i.isElement == null ? void 0 : i.isElement(x))) == null || n ? x : x.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
      boundary: u,
      rootBoundary: c,
      strategy: l
    })), y = d === "floating" ? {
      x: r,
      y: s,
      width: o.floating.width,
      height: o.floating.height
    } : o.reference, v = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), b = await (i.isElement == null ? void 0 : i.isElement(v)) ? await (i.getScale == null ? void 0 : i.getScale(v)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, T = Sl(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: a,
      rect: y,
      offsetParent: v,
      strategy: l
    }) : y);
    return {
      top: (m.top - T.top + w.top) / b.y,
      bottom: (T.bottom - m.bottom + w.bottom) / b.y,
      left: (m.left - T.left + w.left) / b.x,
      right: (T.right - m.right + w.right) / b.x
    };
  }
  const BA = async (e, t, n) => {
    const { placement: r = "bottom", strategy: s = "absolute", middleware: i = [], platform: o } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
    let u = await o.getElementRects({
      reference: e,
      floating: t,
      strategy: s
    }), { x: c, y: d } = bg(u, r, l), f = r, p = {}, w = 0;
    for (let x = 0; x < a.length; x++) {
      var g;
      const { name: m, fn: y } = a[x], { x: v, y: b, data: T, reset: C } = await y({
        x: c,
        y: d,
        initialPlacement: r,
        placement: f,
        strategy: s,
        middlewareData: p,
        rects: u,
        platform: {
          ...o,
          detectOverflow: (g = o.detectOverflow) != null ? g : zA
        },
        elements: {
          reference: e,
          floating: t
        }
      });
      c = v ?? c, d = b ?? d, p = {
        ...p,
        [m]: {
          ...p[m],
          ...T
        }
      }, C && w <= 50 && (w++, typeof C == "object" && (C.placement && (f = C.placement), C.rects && (u = C.rects === true ? await o.getElementRects({
        reference: e,
        floating: t,
        strategy: s
      }) : C.rects), { x: c, y: d } = bg(u, f, l)), x = -1);
    }
    return {
      x: c,
      y: d,
      placement: f,
      strategy: s,
      middlewareData: p
    };
  }, UA = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const { x: n, y: r, placement: s, rects: i, platform: o, elements: a, middlewareData: l } = t, { element: u, padding: c = 0 } = Vn(e, t) || {};
      if (u == null) return {};
      const d = Bx(c), f = {
        x: n,
        y: r
      }, p = jh(s), w = Lh(p), g = await o.getDimensions(u), x = p === "y", m = x ? "top" : "left", y = x ? "bottom" : "right", v = x ? "clientHeight" : "clientWidth", b = i.reference[w] + i.reference[p] - f[p] - i.floating[w], T = f[p] - i.reference[p], C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
      let E = C ? C[v] : 0;
      (!E || !await (o.isElement == null ? void 0 : o.isElement(C))) && (E = a.floating[v] || i.floating[w]);
      const P = b / 2 - T / 2, D = E / 2 - g[w] / 2 - 1, A = fr(d[m], D), M = fr(d[y], D), j = A, Q = E - g[w] - M, L = E / 2 - g[w] / 2 + P, Z = Ud(j, L, Q), W = !l.arrow && li(s) != null && L !== Z && i.reference[w] / 2 - (L < j ? A : M) - g[w] / 2 < 0, B = W ? L < j ? L - j : L - Q : 0;
      return {
        [p]: f[p] + B,
        data: {
          [p]: Z,
          centerOffset: L - Z - B,
          ...W && {
            alignmentOffset: B
          }
        },
        reset: W
      };
    }
  }), $A = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const { placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: u } = t, { mainAxis: c = true, crossAxis: d = true, fallbackPlacements: f, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: g = true, ...x } = Vn(e, t);
        if ((n = i.arrow) != null && n.alignmentOffset) return {};
        const m = Fn(s), y = ln(a), v = Fn(a) === a, b = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), T = f || (v || !g ? [
          xl(a)
        ] : OA(a)), C = w !== "none";
        !f && C && T.push(...VA(a, g, w, b));
        const E = [
          a,
          ...T
        ], P = await l.detectOverflow(t, x), D = [];
        let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
        if (c && D.push(P[m]), d) {
          const L = MA(s, o, b);
          D.push(P[L[0]], P[L[1]]);
        }
        if (A = [
          ...A,
          {
            placement: s,
            overflows: D
          }
        ], !D.every((L) => L <= 0)) {
          var M, j;
          const L = (((M = i.flip) == null ? void 0 : M.index) || 0) + 1, Z = E[L];
          if (Z && (!(d === "alignment" ? y !== ln(Z) : false) || A.every((k) => ln(k.placement) === y ? k.overflows[0] > 0 : true))) return {
            data: {
              index: L,
              overflows: A
            },
            reset: {
              placement: Z
            }
          };
          let W = (j = A.filter((B) => B.overflows[0] <= 0).sort((B, k) => B.overflows[1] - k.overflows[1])[0]) == null ? void 0 : j.placement;
          if (!W) switch (p) {
            case "bestFit": {
              var Q;
              const B = (Q = A.filter((k) => {
                if (C) {
                  const O = ln(k.placement);
                  return O === y || O === "y";
                }
                return true;
              }).map((k) => [
                k.placement,
                k.overflows.filter((O) => O > 0).reduce((O, I) => O + I, 0)
              ]).sort((k, O) => k[1] - O[1])[0]) == null ? void 0 : Q[0];
              B && (W = B);
              break;
            }
            case "initialPlacement":
              W = a;
              break;
          }
          if (s !== W) return {
            reset: {
              placement: W
            }
          };
        }
        return {};
      }
    };
  };
  function Tg(e, t) {
    return {
      top: e.top - t.height,
      right: e.right - t.width,
      bottom: e.bottom - t.height,
      left: e.left - t.width
    };
  }
  function Cg(e) {
    return AA.some((t) => e[t] >= 0);
  }
  const WA = function(e) {
    return e === void 0 && (e = {}), {
      name: "hide",
      options: e,
      async fn(t) {
        const { rects: n, platform: r } = t, { strategy: s = "referenceHidden", ...i } = Vn(e, t);
        switch (s) {
          case "referenceHidden": {
            const o = await r.detectOverflow(t, {
              ...i,
              elementContext: "reference"
            }), a = Tg(o, n.reference);
            return {
              data: {
                referenceHiddenOffsets: a,
                referenceHidden: Cg(a)
              }
            };
          }
          case "escaped": {
            const o = await r.detectOverflow(t, {
              ...i,
              altBoundary: true
            }), a = Tg(o, n.floating);
            return {
              data: {
                escapedOffsets: a,
                escaped: Cg(a)
              }
            };
          }
          default:
            return {};
        }
      }
    };
  }, Ux = /* @__PURE__ */ new Set([
    "left",
    "top"
  ]);
  async function HA(e, t) {
    const { placement: n, platform: r, elements: s } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = Fn(n), a = li(n), l = ln(n) === "y", u = Ux.has(o) ? -1 : 1, c = i && l ? -1 : 1, d = Vn(t, e);
    let { mainAxis: f, crossAxis: p, alignmentAxis: w } = typeof d == "number" ? {
      mainAxis: d,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: d.mainAxis || 0,
      crossAxis: d.crossAxis || 0,
      alignmentAxis: d.alignmentAxis
    };
    return a && typeof w == "number" && (p = a === "end" ? w * -1 : w), l ? {
      x: p * c,
      y: f * u
    } : {
      x: f * u,
      y: p * c
    };
  }
  const KA = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, r;
        const { x: s, y: i, placement: o, middlewareData: a } = t, l = await HA(t, e);
        return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
          x: s + l.x,
          y: i + l.y,
          data: {
            ...l,
            placement: o
          }
        };
      }
    };
  }, QA = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const { x: n, y: r, placement: s, platform: i } = t, { mainAxis: o = true, crossAxis: a = false, limiter: l = {
          fn: (m) => {
            let { x: y, y: v } = m;
            return {
              x: y,
              y: v
            };
          }
        }, ...u } = Vn(e, t), c = {
          x: n,
          y: r
        }, d = await i.detectOverflow(t, u), f = ln(Fn(s)), p = Ih(f);
        let w = c[p], g = c[f];
        if (o) {
          const m = p === "y" ? "top" : "left", y = p === "y" ? "bottom" : "right", v = w + d[m], b = w - d[y];
          w = Ud(v, w, b);
        }
        if (a) {
          const m = f === "y" ? "top" : "left", y = f === "y" ? "bottom" : "right", v = g + d[m], b = g - d[y];
          g = Ud(v, g, b);
        }
        const x = l.fn({
          ...t,
          [p]: w,
          [f]: g
        });
        return {
          ...x,
          data: {
            x: x.x - n,
            y: x.y - r,
            enabled: {
              [p]: o,
              [f]: a
            }
          }
        };
      }
    };
  }, GA = function(e) {
    return e === void 0 && (e = {}), {
      options: e,
      fn(t) {
        const { x: n, y: r, placement: s, rects: i, middlewareData: o } = t, { offset: a = 0, mainAxis: l = true, crossAxis: u = true } = Vn(e, t), c = {
          x: n,
          y: r
        }, d = ln(s), f = Ih(d);
        let p = c[f], w = c[d];
        const g = Vn(a, t), x = typeof g == "number" ? {
          mainAxis: g,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...g
        };
        if (l) {
          const v = f === "y" ? "height" : "width", b = i.reference[f] - i.floating[v] + x.mainAxis, T = i.reference[f] + i.reference[v] - x.mainAxis;
          p < b ? p = b : p > T && (p = T);
        }
        if (u) {
          var m, y;
          const v = f === "y" ? "width" : "height", b = Ux.has(Fn(s)), T = i.reference[d] - i.floating[v] + (b && ((m = o.offset) == null ? void 0 : m[d]) || 0) + (b ? 0 : x.crossAxis), C = i.reference[d] + i.reference[v] + (b ? 0 : ((y = o.offset) == null ? void 0 : y[d]) || 0) - (b ? x.crossAxis : 0);
          w < T ? w = T : w > C && (w = C);
        }
        return {
          [f]: p,
          [d]: w
        };
      }
    };
  }, qA = function(e) {
    return e === void 0 && (e = {}), {
      name: "size",
      options: e,
      async fn(t) {
        var n, r;
        const { placement: s, rects: i, platform: o, elements: a } = t, { apply: l = () => {
        }, ...u } = Vn(e, t), c = await o.detectOverflow(t, u), d = Fn(s), f = li(s), p = ln(s) === "y", { width: w, height: g } = i.floating;
        let x, m;
        d === "top" || d === "bottom" ? (x = d, m = f === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (m = d, x = f === "end" ? "top" : "bottom");
        const y = g - c.top - c.bottom, v = w - c.left - c.right, b = fr(g - c[x], y), T = fr(w - c[m], v), C = !t.middlewareData.shift;
        let E = b, P = T;
        if ((n = t.middlewareData.shift) != null && n.enabled.x && (P = v), (r = t.middlewareData.shift) != null && r.enabled.y && (E = y), C && !f) {
          const A = xt(c.left, 0), M = xt(c.right, 0), j = xt(c.top, 0), Q = xt(c.bottom, 0);
          p ? P = w - 2 * (A !== 0 || M !== 0 ? A + M : xt(c.left, c.right)) : E = g - 2 * (j !== 0 || Q !== 0 ? j + Q : xt(c.top, c.bottom));
        }
        await l({
          ...t,
          availableWidth: P,
          availableHeight: E
        });
        const D = await o.getDimensions(a.floating);
        return w !== D.width || g !== D.height ? {
          reset: {
            rects: true
          }
        } : {};
      }
    };
  };
  function du() {
    return typeof window < "u";
  }
  function ui(e) {
    return $x(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function Et(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function wn(e) {
    var t;
    return (t = ($x(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function $x(e) {
    return du() ? e instanceof Node || e instanceof Et(e).Node : false;
  }
  function Xt(e) {
    return du() ? e instanceof Element || e instanceof Et(e).Element : false;
  }
  function gn(e) {
    return du() ? e instanceof HTMLElement || e instanceof Et(e).HTMLElement : false;
  }
  function Eg(e) {
    return !du() || typeof ShadowRoot > "u" ? false : e instanceof ShadowRoot || e instanceof Et(e).ShadowRoot;
  }
  const ZA = /* @__PURE__ */ new Set([
    "inline",
    "contents"
  ]);
  function Uo(e) {
    const { overflow: t, overflowX: n, overflowY: r, display: s } = Jt(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !ZA.has(s);
  }
  const YA = /* @__PURE__ */ new Set([
    "table",
    "td",
    "th"
  ]);
  function XA(e) {
    return YA.has(ui(e));
  }
  const JA = [
    ":popover-open",
    ":modal"
  ];
  function fu(e) {
    return JA.some((t) => {
      try {
        return e.matches(t);
      } catch {
        return false;
      }
    });
  }
  const eR = [
    "transform",
    "translate",
    "scale",
    "rotate",
    "perspective"
  ], tR = [
    "transform",
    "translate",
    "scale",
    "rotate",
    "perspective",
    "filter"
  ], nR = [
    "paint",
    "layout",
    "strict",
    "content"
  ];
  function Vh(e) {
    const t = Fh(), n = Xt(e) ? Jt(e) : e;
    return eR.some((r) => n[r] ? n[r] !== "none" : false) || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || tR.some((r) => (n.willChange || "").includes(r)) || nR.some((r) => (n.contain || "").includes(r));
  }
  function rR(e) {
    let t = hr(e);
    for (; gn(t) && !Ks(t); ) {
      if (Vh(t)) return t;
      if (fu(t)) return null;
      t = hr(t);
    }
    return null;
  }
  function Fh() {
    return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
  }
  const sR = /* @__PURE__ */ new Set([
    "html",
    "body",
    "#document"
  ]);
  function Ks(e) {
    return sR.has(ui(e));
  }
  function Jt(e) {
    return Et(e).getComputedStyle(e);
  }
  function hu(e) {
    return Xt(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function hr(e) {
    if (ui(e) === "html") return e;
    const t = e.assignedSlot || e.parentNode || Eg(e) && e.host || wn(e);
    return Eg(t) ? t.host : t;
  }
  function Wx(e) {
    const t = hr(e);
    return Ks(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : gn(t) && Uo(t) ? t : Wx(t);
  }
  function fo(e, t, n) {
    var r;
    t === void 0 && (t = []), n === void 0 && (n = true);
    const s = Wx(e), i = s === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Et(s);
    if (i) {
      const a = Wd(o);
      return t.concat(o, o.visualViewport || [], Uo(s) ? s : [], a && n ? fo(a) : []);
    }
    return t.concat(s, fo(s, [], n));
  }
  function Wd(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function Hx(e) {
    const t = Jt(e);
    let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
    const s = gn(e), i = s ? e.offsetWidth : n, o = s ? e.offsetHeight : r, a = wl(n) !== i || wl(r) !== o;
    return a && (n = i, r = o), {
      width: n,
      height: r,
      $: a
    };
  }
  function zh(e) {
    return Xt(e) ? e : e.contextElement;
  }
  function Ds(e) {
    const t = zh(e);
    if (!gn(t)) return dn(1);
    const n = t.getBoundingClientRect(), { width: r, height: s, $: i } = Hx(t);
    let o = (i ? wl(n.width) : n.width) / r, a = (i ? wl(n.height) : n.height) / s;
    return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
      x: o,
      y: a
    };
  }
  const iR = dn(0);
  function Kx(e) {
    const t = Et(e);
    return !Fh() || !t.visualViewport ? iR : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function oR(e, t, n) {
    return t === void 0 && (t = false), !n || t && n !== Et(e) ? false : t;
  }
  function Kr(e, t, n, r) {
    t === void 0 && (t = false), n === void 0 && (n = false);
    const s = e.getBoundingClientRect(), i = zh(e);
    let o = dn(1);
    t && (r ? Xt(r) && (o = Ds(r)) : o = Ds(e));
    const a = oR(i, n, r) ? Kx(i) : dn(0);
    let l = (s.left + a.x) / o.x, u = (s.top + a.y) / o.y, c = s.width / o.x, d = s.height / o.y;
    if (i) {
      const f = Et(i), p = r && Xt(r) ? Et(r) : r;
      let w = f, g = Wd(w);
      for (; g && r && p !== w; ) {
        const x = Ds(g), m = g.getBoundingClientRect(), y = Jt(g), v = m.left + (g.clientLeft + parseFloat(y.paddingLeft)) * x.x, b = m.top + (g.clientTop + parseFloat(y.paddingTop)) * x.y;
        l *= x.x, u *= x.y, c *= x.x, d *= x.y, l += v, u += b, w = Et(g), g = Wd(w);
      }
    }
    return Sl({
      width: c,
      height: d,
      x: l,
      y: u
    });
  }
  function pu(e, t) {
    const n = hu(e).scrollLeft;
    return t ? t.left + n : Kr(wn(e)).left + n;
  }
  function Qx(e, t) {
    const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - pu(e, n), s = n.top + t.scrollTop;
    return {
      x: r,
      y: s
    };
  }
  function aR(e) {
    let { elements: t, rect: n, offsetParent: r, strategy: s } = e;
    const i = s === "fixed", o = wn(r), a = t ? fu(t.floating) : false;
    if (r === o || a && i) return n;
    let l = {
      scrollLeft: 0,
      scrollTop: 0
    }, u = dn(1);
    const c = dn(0), d = gn(r);
    if ((d || !d && !i) && ((ui(r) !== "body" || Uo(o)) && (l = hu(r)), gn(r))) {
      const p = Kr(r);
      u = Ds(r), c.x = p.x + r.clientLeft, c.y = p.y + r.clientTop;
    }
    const f = o && !d && !i ? Qx(o, l) : dn(0);
    return {
      width: n.width * u.x,
      height: n.height * u.y,
      x: n.x * u.x - l.scrollLeft * u.x + c.x + f.x,
      y: n.y * u.y - l.scrollTop * u.y + c.y + f.y
    };
  }
  function lR(e) {
    return Array.from(e.getClientRects());
  }
  function uR(e) {
    const t = wn(e), n = hu(e), r = e.ownerDocument.body, s = xt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = xt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let o = -n.scrollLeft + pu(e);
    const a = -n.scrollTop;
    return Jt(r).direction === "rtl" && (o += xt(t.clientWidth, r.clientWidth) - s), {
      width: s,
      height: i,
      x: o,
      y: a
    };
  }
  const Pg = 25;
  function cR(e, t) {
    const n = Et(e), r = wn(e), s = n.visualViewport;
    let i = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
    if (s) {
      i = s.width, o = s.height;
      const c = Fh();
      (!c || c && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
    }
    const u = pu(r);
    if (u <= 0) {
      const c = r.ownerDocument, d = c.body, f = getComputedStyle(d), p = c.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, w = Math.abs(r.clientWidth - d.clientWidth - p);
      w <= Pg && (i -= w);
    } else u <= Pg && (i += u);
    return {
      width: i,
      height: o,
      x: a,
      y: l
    };
  }
  const dR = /* @__PURE__ */ new Set([
    "absolute",
    "fixed"
  ]);
  function fR(e, t) {
    const n = Kr(e, true, t === "fixed"), r = n.top + e.clientTop, s = n.left + e.clientLeft, i = gn(e) ? Ds(e) : dn(1), o = e.clientWidth * i.x, a = e.clientHeight * i.y, l = s * i.x, u = r * i.y;
    return {
      width: o,
      height: a,
      x: l,
      y: u
    };
  }
  function kg(e, t, n) {
    let r;
    if (t === "viewport") r = cR(e, n);
    else if (t === "document") r = uR(wn(e));
    else if (Xt(t)) r = fR(t, n);
    else {
      const s = Kx(e);
      r = {
        x: t.x - s.x,
        y: t.y - s.y,
        width: t.width,
        height: t.height
      };
    }
    return Sl(r);
  }
  function Gx(e, t) {
    const n = hr(e);
    return n === t || !Xt(n) || Ks(n) ? false : Jt(n).position === "fixed" || Gx(n, t);
  }
  function hR(e, t) {
    const n = t.get(e);
    if (n) return n;
    let r = fo(e, [], false).filter((a) => Xt(a) && ui(a) !== "body"), s = null;
    const i = Jt(e).position === "fixed";
    let o = i ? hr(e) : e;
    for (; Xt(o) && !Ks(o); ) {
      const a = Jt(o), l = Vh(o);
      !l && a.position === "fixed" && (s = null), (i ? !l && !s : !l && a.position === "static" && !!s && dR.has(s.position) || Uo(o) && !l && Gx(e, o)) ? r = r.filter((c) => c !== o) : s = a, o = hr(o);
    }
    return t.set(e, r), r;
  }
  function pR(e) {
    let { element: t, boundary: n, rootBoundary: r, strategy: s } = e;
    const o = [
      ...n === "clippingAncestors" ? fu(t) ? [] : hR(t, this._c) : [].concat(n),
      r
    ], a = o[0], l = o.reduce((u, c) => {
      const d = kg(t, c, s);
      return u.top = xt(d.top, u.top), u.right = fr(d.right, u.right), u.bottom = fr(d.bottom, u.bottom), u.left = xt(d.left, u.left), u;
    }, kg(t, a, s));
    return {
      width: l.right - l.left,
      height: l.bottom - l.top,
      x: l.left,
      y: l.top
    };
  }
  function mR(e) {
    const { width: t, height: n } = Hx(e);
    return {
      width: t,
      height: n
    };
  }
  function gR(e, t, n) {
    const r = gn(t), s = wn(t), i = n === "fixed", o = Kr(e, true, i, t);
    let a = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const l = dn(0);
    function u() {
      l.x = pu(s);
    }
    if (r || !r && !i) if ((ui(t) !== "body" || Uo(s)) && (a = hu(t)), r) {
      const p = Kr(t, true, i, t);
      l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop;
    } else s && u();
    i && !r && s && u();
    const c = s && !r && !i ? Qx(s, a) : dn(0), d = o.left + a.scrollLeft - l.x - c.x, f = o.top + a.scrollTop - l.y - c.y;
    return {
      x: d,
      y: f,
      width: o.width,
      height: o.height
    };
  }
  function dc(e) {
    return Jt(e).position === "static";
  }
  function _g(e, t) {
    if (!gn(e) || Jt(e).position === "fixed") return null;
    if (t) return t(e);
    let n = e.offsetParent;
    return wn(e) === n && (n = n.ownerDocument.body), n;
  }
  function qx(e, t) {
    const n = Et(e);
    if (fu(e)) return n;
    if (!gn(e)) {
      let s = hr(e);
      for (; s && !Ks(s); ) {
        if (Xt(s) && !dc(s)) return s;
        s = hr(s);
      }
      return n;
    }
    let r = _g(e, t);
    for (; r && XA(r) && dc(r); ) r = _g(r, t);
    return r && Ks(r) && dc(r) && !Vh(r) ? n : r || rR(e) || n;
  }
  const yR = async function(e) {
    const t = this.getOffsetParent || qx, n = this.getDimensions, r = await n(e.floating);
    return {
      reference: gR(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: r.width,
        height: r.height
      }
    };
  };
  function vR(e) {
    return Jt(e).direction === "rtl";
  }
  const wR = {
    convertOffsetParentRelativeRectToViewportRelativeRect: aR,
    getDocumentElement: wn,
    getClippingRect: pR,
    getOffsetParent: qx,
    getElementRects: yR,
    getClientRects: lR,
    getDimensions: mR,
    getScale: Ds,
    isElement: Xt,
    isRTL: vR
  };
  function Zx(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function xR(e, t) {
    let n = null, r;
    const s = wn(e);
    function i() {
      var a;
      clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
    }
    function o(a, l) {
      a === void 0 && (a = false), l === void 0 && (l = 1), i();
      const u = e.getBoundingClientRect(), { left: c, top: d, width: f, height: p } = u;
      if (a || t(), !f || !p) return;
      const w = ga(d), g = ga(s.clientWidth - (c + f)), x = ga(s.clientHeight - (d + p)), m = ga(c), v = {
        rootMargin: -w + "px " + -g + "px " + -x + "px " + -m + "px",
        threshold: xt(0, fr(1, l)) || 1
      };
      let b = true;
      function T(C) {
        const E = C[0].intersectionRatio;
        if (E !== l) {
          if (!b) return o();
          E ? o(false, E) : r = setTimeout(() => {
            o(false, 1e-7);
          }, 1e3);
        }
        E === 1 && !Zx(u, e.getBoundingClientRect()) && o(), b = false;
      }
      try {
        n = new IntersectionObserver(T, {
          ...v,
          root: s.ownerDocument
        });
      } catch {
        n = new IntersectionObserver(T, v);
      }
      n.observe(e);
    }
    return o(true), i;
  }
  function SR(e, t, n, r) {
    r === void 0 && (r = {});
    const { ancestorScroll: s = true, ancestorResize: i = true, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = false } = r, u = zh(e), c = s || i ? [
      ...u ? fo(u) : [],
      ...fo(t)
    ] : [];
    c.forEach((m) => {
      s && m.addEventListener("scroll", n, {
        passive: true
      }), i && m.addEventListener("resize", n);
    });
    const d = u && a ? xR(u, n) : null;
    let f = -1, p = null;
    o && (p = new ResizeObserver((m) => {
      let [y] = m;
      y && y.target === u && p && (p.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
        var v;
        (v = p) == null || v.observe(t);
      })), n();
    }), u && !l && p.observe(u), p.observe(t));
    let w, g = l ? Kr(e) : null;
    l && x();
    function x() {
      const m = Kr(e);
      g && !Zx(g, m) && n(), g = m, w = requestAnimationFrame(x);
    }
    return n(), () => {
      var m;
      c.forEach((y) => {
        s && y.removeEventListener("scroll", n), i && y.removeEventListener("resize", n);
      }), d?.(), (m = p) == null || m.disconnect(), p = null, l && cancelAnimationFrame(w);
    };
  }
  const bR = KA, TR = QA, CR = $A, ER = qA, PR = WA, Ag = UA, kR = GA, _R = (e, t, n) => {
    const r = /* @__PURE__ */ new Map(), s = {
      platform: wR,
      ...n
    }, i = {
      ...s.platform,
      _c: r
    };
    return BA(e, t, {
      ...s,
      platform: i
    });
  };
  var AR = typeof document < "u", RR = function() {
  }, Ba = AR ? h.useLayoutEffect : RR;
  function bl(e, t) {
    if (e === t) return true;
    if (typeof e != typeof t) return false;
    if (typeof e == "function" && e.toString() === t.toString()) return true;
    let n, r, s;
    if (e && t && typeof e == "object") {
      if (Array.isArray(e)) {
        if (n = e.length, n !== t.length) return false;
        for (r = n; r-- !== 0; ) if (!bl(e[r], t[r])) return false;
        return true;
      }
      if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length) return false;
      for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, s[r])) return false;
      for (r = n; r-- !== 0; ) {
        const i = s[r];
        if (!(i === "_owner" && e.$$typeof) && !bl(e[i], t[i])) return false;
      }
      return true;
    }
    return e !== e && t !== t;
  }
  function Yx(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function Rg(e, t) {
    const n = Yx(e);
    return Math.round(t * n) / n;
  }
  function fc(e) {
    const t = h.useRef(e);
    return Ba(() => {
      t.current = e;
    }), t;
  }
  function NR(e) {
    e === void 0 && (e = {});
    const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: s, elements: { reference: i, floating: o } = {}, transform: a = true, whileElementsMounted: l, open: u } = e, [c, d] = h.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: false
    }), [f, p] = h.useState(r);
    bl(f, r) || p(r);
    const [w, g] = h.useState(null), [x, m] = h.useState(null), y = h.useCallback((k) => {
      k !== C.current && (C.current = k, g(k));
    }, []), v = h.useCallback((k) => {
      k !== E.current && (E.current = k, m(k));
    }, []), b = i || w, T = o || x, C = h.useRef(null), E = h.useRef(null), P = h.useRef(c), D = l != null, A = fc(l), M = fc(s), j = fc(u), Q = h.useCallback(() => {
      if (!C.current || !E.current) return;
      const k = {
        placement: t,
        strategy: n,
        middleware: f
      };
      M.current && (k.platform = M.current), _R(C.current, E.current, k).then((O) => {
        const I = {
          ...O,
          isPositioned: j.current !== false
        };
        L.current && !bl(P.current, I) && (P.current = I, Fo.flushSync(() => {
          d(I);
        }));
      });
    }, [
      f,
      t,
      n,
      M,
      j
    ]);
    Ba(() => {
      u === false && P.current.isPositioned && (P.current.isPositioned = false, d((k) => ({
        ...k,
        isPositioned: false
      })));
    }, [
      u
    ]);
    const L = h.useRef(false);
    Ba(() => (L.current = true, () => {
      L.current = false;
    }), []), Ba(() => {
      if (b && (C.current = b), T && (E.current = T), b && T) {
        if (A.current) return A.current(b, T, Q);
        Q();
      }
    }, [
      b,
      T,
      Q,
      A,
      D
    ]);
    const Z = h.useMemo(() => ({
      reference: C,
      floating: E,
      setReference: y,
      setFloating: v
    }), [
      y,
      v
    ]), W = h.useMemo(() => ({
      reference: b,
      floating: T
    }), [
      b,
      T
    ]), B = h.useMemo(() => {
      const k = {
        position: n,
        left: 0,
        top: 0
      };
      if (!W.floating) return k;
      const O = Rg(W.floating, c.x), I = Rg(W.floating, c.y);
      return a ? {
        ...k,
        transform: "translate(" + O + "px, " + I + "px)",
        ...Yx(W.floating) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: n,
        left: O,
        top: I
      };
    }, [
      n,
      a,
      W.floating,
      c.x,
      c.y
    ]);
    return h.useMemo(() => ({
      ...c,
      update: Q,
      refs: Z,
      elements: W,
      floatingStyles: B
    }), [
      c,
      Q,
      Z,
      W,
      B
    ]);
  }
  const DR = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const { element: r, padding: s } = typeof e == "function" ? e(n) : e;
        return r && t(r) ? r.current != null ? Ag({
          element: r.current,
          padding: s
        }).fn(n) : {} : r ? Ag({
          element: r,
          padding: s
        }).fn(n) : {};
      }
    };
  }, MR = (e, t) => ({
    ...bR(e),
    options: [
      e,
      t
    ]
  }), OR = (e, t) => ({
    ...TR(e),
    options: [
      e,
      t
    ]
  }), IR = (e, t) => ({
    ...kR(e),
    options: [
      e,
      t
    ]
  }), LR = (e, t) => ({
    ...CR(e),
    options: [
      e,
      t
    ]
  }), jR = (e, t) => ({
    ...ER(e),
    options: [
      e,
      t
    ]
  }), VR = (e, t) => ({
    ...PR(e),
    options: [
      e,
      t
    ]
  }), FR = (e, t) => ({
    ...DR(e),
    options: [
      e,
      t
    ]
  });
  var zR = "Arrow", Xx = h.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: s = 5, ...i } = e;
    return S.jsx(ye.svg, {
      ...i,
      ref: t,
      width: r,
      height: s,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : S.jsx("polygon", {
        points: "0,0 30,0 15,10"
      })
    });
  });
  Xx.displayName = zR;
  var BR = Xx;
  function Jx(e) {
    const [t, n] = h.useState(void 0);
    return jn(() => {
      if (e) {
        n({
          width: e.offsetWidth,
          height: e.offsetHeight
        });
        const r = new ResizeObserver((s) => {
          if (!Array.isArray(s) || !s.length) return;
          const i = s[0];
          let o, a;
          if ("borderBoxSize" in i) {
            const l = i.borderBoxSize, u = Array.isArray(l) ? l[0] : l;
            o = u.inlineSize, a = u.blockSize;
          } else o = e.offsetWidth, a = e.offsetHeight;
          n({
            width: o,
            height: a
          });
        });
        return r.observe(e, {
          box: "border-box"
        }), () => r.unobserve(e);
      } else n(void 0);
    }, [
      e
    ]), t;
  }
  let Bh, eS, UR, nS, rS;
  Bh = "Popper";
  [eS, tS] = ii(Bh);
  [UR, nS] = eS(Bh);
  rS = (e) => {
    const { __scopePopper: t, children: n } = e, [r, s] = h.useState(null);
    return S.jsx(UR, {
      scope: t,
      anchor: r,
      onAnchorChange: s,
      children: n
    });
  };
  rS.displayName = Bh;
  var sS = "PopperAnchor", iS = h.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...s } = e, i = nS(sS, n), o = h.useRef(null), a = Me(t, o), l = h.useRef(null);
    return h.useEffect(() => {
      const u = l.current;
      l.current = r?.current || o.current, u !== l.current && i.onAnchorChange(l.current);
    }), r ? null : S.jsx(ye.div, {
      ...s,
      ref: a
    });
  });
  iS.displayName = sS;
  var Uh = "PopperContent", [$R, WR] = eS(Uh), oS = h.forwardRef((e, t) => {
    const { __scopePopper: n, side: r = "bottom", sideOffset: s = 0, align: i = "center", alignOffset: o = 0, arrowPadding: a = 0, avoidCollisions: l = true, collisionBoundary: u = [], collisionPadding: c = 0, sticky: d = "partial", hideWhenDetached: f = false, updatePositionStrategy: p = "optimized", onPlaced: w, ...g } = e, x = nS(Uh, n), [m, y] = h.useState(null), v = Me(t, (nn) => y(nn)), [b, T] = h.useState(null), C = Jx(b), E = C?.width ?? 0, P = C?.height ?? 0, D = r + (i !== "center" ? "-" + i : ""), A = typeof c == "number" ? c : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...c
    }, M = Array.isArray(u) ? u : [
      u
    ], j = M.length > 0, Q = {
      padding: A,
      boundary: M.filter(KR),
      altBoundary: j
    }, { refs: L, floatingStyles: Z, placement: W, isPositioned: B, middlewareData: k } = NR({
      strategy: "fixed",
      placement: D,
      whileElementsMounted: (...nn) => SR(...nn, {
        animationFrame: p === "always"
      }),
      elements: {
        reference: x.anchor
      },
      middleware: [
        MR({
          mainAxis: s + P,
          alignmentAxis: o
        }),
        l && OR({
          mainAxis: true,
          crossAxis: false,
          limiter: d === "partial" ? IR() : void 0,
          ...Q
        }),
        l && LR({
          ...Q
        }),
        jR({
          ...Q,
          apply: ({ elements: nn, rects: Dp, availableWidth: LT, availableHeight: jT }) => {
            const { width: VT, height: FT } = Dp.reference, qo = nn.floating.style;
            qo.setProperty("--radix-popper-available-width", `${LT}px`), qo.setProperty("--radix-popper-available-height", `${jT}px`), qo.setProperty("--radix-popper-anchor-width", `${VT}px`), qo.setProperty("--radix-popper-anchor-height", `${FT}px`);
          }
        }),
        b && FR({
          element: b,
          padding: a
        }),
        QR({
          arrowWidth: E,
          arrowHeight: P
        }),
        f && VR({
          strategy: "referenceHidden",
          ...Q
        })
      ]
    }), [O, I] = uS(W), $ = mn(w);
    jn(() => {
      B && $?.();
    }, [
      B,
      $
    ]);
    const le = k.arrow?.x, rt = k.arrow?.y, qe = k.arrow?.centerOffset !== 0, [hi, xn] = h.useState();
    return jn(() => {
      m && xn(window.getComputedStyle(m).zIndex);
    }, [
      m
    ]), S.jsx("div", {
      ref: L.setFloating,
      "data-radix-popper-content-wrapper": "",
      style: {
        ...Z,
        transform: B ? Z.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: hi,
        "--radix-popper-transform-origin": [
          k.transformOrigin?.x,
          k.transformOrigin?.y
        ].join(" "),
        ...k.hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      },
      dir: e.dir,
      children: S.jsx($R, {
        scope: n,
        placedSide: O,
        onArrowChange: T,
        arrowX: le,
        arrowY: rt,
        shouldHideArrow: qe,
        children: S.jsx(ye.div, {
          "data-side": O,
          "data-align": I,
          ...g,
          ref: v,
          style: {
            ...g.style,
            animation: B ? void 0 : "none"
          }
        })
      })
    });
  });
  oS.displayName = Uh;
  var aS = "PopperArrow", HR = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }, lS = h.forwardRef(function(t, n) {
    const { __scopePopper: r, ...s } = t, i = WR(aS, r), o = HR[i.placedSide];
    return S.jsx("span", {
      ref: i.onArrowChange,
      style: {
        position: "absolute",
        left: i.arrowX,
        top: i.arrowY,
        [o]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[i.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[i.placedSide],
        visibility: i.shouldHideArrow ? "hidden" : void 0
      },
      children: S.jsx(BR, {
        ...s,
        ref: n,
        style: {
          ...s.style,
          display: "block"
        }
      })
    });
  });
  lS.displayName = aS;
  function KR(e) {
    return e !== null;
  }
  var QR = (e) => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: r, middlewareData: s } = t, o = s.arrow?.centerOffset !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [u, c] = uS(n), d = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], f = (s.arrow?.x ?? 0) + a / 2, p = (s.arrow?.y ?? 0) + l / 2;
      let w = "", g = "";
      return u === "bottom" ? (w = o ? d : `${f}px`, g = `${-l}px`) : u === "top" ? (w = o ? d : `${f}px`, g = `${r.floating.height + l}px`) : u === "right" ? (w = `${-l}px`, g = o ? d : `${p}px`) : u === "left" && (w = `${r.floating.width + l}px`, g = o ? d : `${p}px`), {
        data: {
          x: w,
          y: g
        }
      };
    }
  });
  function uS(e) {
    const [t, n = "center"] = e.split("-");
    return [
      t,
      n
    ];
  }
  let YR;
  P3 = rS;
  GR = iS;
  qR = oS;
  ZR = lS;
  YR = Symbol("radix.slottable");
  function XR(e) {
    const t = ({ children: n }) => S.jsx(S.Fragment, {
      children: n
    });
    return t.displayName = `${e}.Slottable`, t.__radixId = YR, t;
  }
  var [mu] = ii("Tooltip", [
    tS
  ]), $h = tS(), cS = "TooltipProvider", JR = 700, Ng = "tooltip.open", [eN, dS] = mu(cS), fS = (e) => {
    const { __scopeTooltip: t, delayDuration: n = JR, skipDelayDuration: r = 300, disableHoverableContent: s = false, children: i } = e, o = h.useRef(true), a = h.useRef(false), l = h.useRef(0);
    return h.useEffect(() => {
      const u = l.current;
      return () => window.clearTimeout(u);
    }, []), S.jsx(eN, {
      scope: t,
      isOpenDelayedRef: o,
      delayDuration: n,
      onOpen: h.useCallback(() => {
        window.clearTimeout(l.current), o.current = false;
      }, []),
      onClose: h.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(() => o.current = true, r);
      }, [
        r
      ]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: h.useCallback((u) => {
        a.current = u;
      }, []),
      disableHoverableContent: s,
      children: i
    });
  };
  fS.displayName = cS;
  var hS = "Tooltip", [k3, gu] = mu(hS), Hd = "TooltipTrigger", tN = h.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e, s = gu(Hd, n), i = dS(Hd, n), o = $h(n), a = h.useRef(null), l = Me(t, a, s.onTriggerChange), u = h.useRef(false), c = h.useRef(false), d = h.useCallback(() => u.current = false, []);
    return h.useEffect(() => () => document.removeEventListener("pointerup", d), [
      d
    ]), S.jsx(GR, {
      asChild: true,
      ...o,
      children: S.jsx(ye.button, {
        "aria-describedby": s.open ? s.contentId : void 0,
        "data-state": s.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: ae(e.onPointerMove, (f) => {
          f.pointerType !== "touch" && !c.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), c.current = true);
        }),
        onPointerLeave: ae(e.onPointerLeave, () => {
          s.onTriggerLeave(), c.current = false;
        }),
        onPointerDown: ae(e.onPointerDown, () => {
          s.open && s.onClose(), u.current = true, document.addEventListener("pointerup", d, {
            once: true
          });
        }),
        onFocus: ae(e.onFocus, () => {
          u.current || s.onOpen();
        }),
        onBlur: ae(e.onBlur, s.onClose),
        onClick: ae(e.onClick, s.onClose)
      })
    });
  });
  tN.displayName = Hd;
  var nN = "TooltipPortal", [_3, rN] = mu(nN, {
    forceMount: void 0
  }), Qs = "TooltipContent", pS = h.forwardRef((e, t) => {
    const n = rN(Qs, e.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...i } = e, o = gu(Qs, e.__scopeTooltip);
    return S.jsx(oi, {
      present: r || o.open,
      children: o.disableHoverableContent ? S.jsx(mS, {
        side: s,
        ...i,
        ref: t
      }) : S.jsx(sN, {
        side: s,
        ...i,
        ref: t
      })
    });
  }), sN = h.forwardRef((e, t) => {
    const n = gu(Qs, e.__scopeTooltip), r = dS(Qs, e.__scopeTooltip), s = h.useRef(null), i = Me(t, s), [o, a] = h.useState(null), { trigger: l, onClose: u } = n, c = s.current, { onPointerInTransitChange: d } = r, f = h.useCallback(() => {
      a(null), d(false);
    }, [
      d
    ]), p = h.useCallback((w, g) => {
      const x = w.currentTarget, m = {
        x: w.clientX,
        y: w.clientY
      }, y = uN(m, x.getBoundingClientRect()), v = cN(m, y), b = dN(g.getBoundingClientRect()), T = hN([
        ...v,
        ...b
      ]);
      a(T), d(true);
    }, [
      d
    ]);
    return h.useEffect(() => () => f(), [
      f
    ]), h.useEffect(() => {
      if (l && c) {
        const w = (x) => p(x, c), g = (x) => p(x, l);
        return l.addEventListener("pointerleave", w), c.addEventListener("pointerleave", g), () => {
          l.removeEventListener("pointerleave", w), c.removeEventListener("pointerleave", g);
        };
      }
    }, [
      l,
      c,
      p,
      f
    ]), h.useEffect(() => {
      if (o) {
        const w = (g) => {
          const x = g.target, m = {
            x: g.clientX,
            y: g.clientY
          }, y = l?.contains(x) || c?.contains(x), v = !fN(m, o);
          y ? f() : v && (f(), u());
        };
        return document.addEventListener("pointermove", w), () => document.removeEventListener("pointermove", w);
      }
    }, [
      l,
      c,
      o,
      u,
      f
    ]), S.jsx(mS, {
      ...e,
      ref: i
    });
  }), [iN, oN] = mu(hS, {
    isInside: false
  }), aN = XR("TooltipContent"), mS = h.forwardRef((e, t) => {
    const { __scopeTooltip: n, children: r, "aria-label": s, onEscapeKeyDown: i, onPointerDownOutside: o, ...a } = e, l = gu(Qs, n), u = $h(n), { onClose: c } = l;
    return h.useEffect(() => (document.addEventListener(Ng, c), () => document.removeEventListener(Ng, c)), [
      c
    ]), h.useEffect(() => {
      if (l.trigger) {
        const d = (f) => {
          f.target?.contains(l.trigger) && c();
        };
        return window.addEventListener("scroll", d, {
          capture: true
        }), () => window.removeEventListener("scroll", d, {
          capture: true
        });
      }
    }, [
      l.trigger,
      c
    ]), S.jsx(lu, {
      asChild: true,
      disableOutsidePointerEvents: false,
      onEscapeKeyDown: i,
      onPointerDownOutside: o,
      onFocusOutside: (d) => d.preventDefault(),
      onDismiss: c,
      children: S.jsxs(qR, {
        "data-state": l.stateAttribute,
        ...u,
        ...a,
        ref: t,
        style: {
          ...a.style,
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        },
        children: [
          S.jsx(aN, {
            children: r
          }),
          S.jsx(iN, {
            scope: n,
            isInside: true,
            children: S.jsx(h_, {
              id: l.contentId,
              role: "tooltip",
              children: s || r
            })
          })
        ]
      })
    });
  });
  pS.displayName = Qs;
  var gS = "TooltipArrow", lN = h.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e, s = $h(n);
    return oN(gS, n).isInside ? null : S.jsx(ZR, {
      ...s,
      ...r,
      ref: t
    });
  });
  lN.displayName = gS;
  function uN(e, t) {
    const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), s = Math.abs(t.right - e.x), i = Math.abs(t.left - e.x);
    switch (Math.min(n, r, s, i)) {
      case i:
        return "left";
      case s:
        return "right";
      case n:
        return "top";
      case r:
        return "bottom";
      default:
        throw new Error("unreachable");
    }
  }
  function cN(e, t, n = 5) {
    const r = [];
    switch (t) {
      case "top":
        r.push({
          x: e.x - n,
          y: e.y + n
        }, {
          x: e.x + n,
          y: e.y + n
        });
        break;
      case "bottom":
        r.push({
          x: e.x - n,
          y: e.y - n
        }, {
          x: e.x + n,
          y: e.y - n
        });
        break;
      case "left":
        r.push({
          x: e.x + n,
          y: e.y - n
        }, {
          x: e.x + n,
          y: e.y + n
        });
        break;
      case "right":
        r.push({
          x: e.x - n,
          y: e.y - n
        }, {
          x: e.x - n,
          y: e.y + n
        });
        break;
    }
    return r;
  }
  function dN(e) {
    const { top: t, right: n, bottom: r, left: s } = e;
    return [
      {
        x: s,
        y: t
      },
      {
        x: n,
        y: t
      },
      {
        x: n,
        y: r
      },
      {
        x: s,
        y: r
      }
    ];
  }
  function fN(e, t) {
    const { x: n, y: r } = e;
    let s = false;
    for (let i = 0, o = t.length - 1; i < t.length; o = i++) {
      const a = t[i], l = t[o], u = a.x, c = a.y, d = l.x, f = l.y;
      c > r != f > r && n < (d - u) * (r - c) / (f - c) + u && (s = !s);
    }
    return s;
  }
  function hN(e) {
    const t = e.slice();
    return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), pN(t);
  }
  function pN(e) {
    if (e.length <= 1) return e.slice();
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      for (; t.length >= 2; ) {
        const i = t[t.length - 1], o = t[t.length - 2];
        if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) t.pop();
        else break;
      }
      t.push(s);
    }
    t.pop();
    const n = [];
    for (let r = e.length - 1; r >= 0; r--) {
      const s = e[r];
      for (; n.length >= 2; ) {
        const i = n[n.length - 1], o = n[n.length - 2];
        if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop();
        else break;
      }
      n.push(s);
    }
    return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
  }
  var mN = fS, yS = pS;
  const gN = mN, yN = h.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => S.jsx(yS, {
    ref: r,
    sideOffset: t,
    className: ct("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", e),
    ...n
  }));
  yN.displayName = yS.displayName;
  var vN = Symbol.for("react.lazy"), Tl = Hl[" use ".trim().toString()];
  function wN(e) {
    return typeof e == "object" && e !== null && "then" in e;
  }
  function vS(e) {
    return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === vN && "_payload" in e && wN(e._payload);
  }
  xN = function(e) {
    const t = bN(e), n = h.forwardRef((r, s) => {
      let { children: i, ...o } = r;
      vS(i) && typeof Tl == "function" && (i = Tl(i._payload));
      const a = h.Children.toArray(i), l = a.find(CN);
      if (l) {
        const u = l.props.children, c = a.map((d) => d === l ? h.Children.count(u) > 1 ? h.Children.only(null) : h.isValidElement(u) ? u.props.children : null : d);
        return S.jsx(t, {
          ...o,
          ref: s,
          children: h.isValidElement(u) ? h.cloneElement(u, void 0, c) : null
        });
      }
      return S.jsx(t, {
        ...o,
        ref: s,
        children: i
      });
    });
    return n.displayName = `${e}.Slot`, n;
  };
  var SN = xN("Slot");
  function bN(e) {
    const t = h.forwardRef((n, r) => {
      let { children: s, ...i } = n;
      if (vS(s) && typeof Tl == "function" && (s = Tl(s._payload)), h.isValidElement(s)) {
        const o = PN(s), a = EN(i, s.props);
        return s.type !== h.Fragment && (a.ref = r ? zo(r, o) : o), h.cloneElement(s, a);
      }
      return h.Children.count(s) > 1 ? h.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var TN = Symbol("radix.slottable");
  function CN(e) {
    return h.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === TN;
  }
  function EN(e, t) {
    const n = {
      ...t
    };
    for (const r in t) {
      const s = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
        const l = i(...a);
        return s(...a), l;
      } : s && (n[r] = s) : r === "style" ? n[r] = {
        ...s,
        ...i
      } : r === "className" && (n[r] = [
        s,
        i
      ].filter(Boolean).join(" "));
    }
    return {
      ...e,
      ...n
    };
  }
  function PN(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  let kN;
  kN = kx("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 hover-elevate active-elevate-2", {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground border border-primary-border",
        destructive: "bg-destructive text-destructive-foreground border border-destructive-border",
        outline: " border [border-color:var(--button-outline)]  shadow-xs active:shadow-none ",
        secondary: "border bg-secondary text-secondary-foreground border border-secondary-border ",
        ghost: "border border-transparent"
      },
      size: {
        default: "min-h-9 px-4 py-2",
        sm: "min-h-8 rounded-md px-3 text-xs",
        lg: "min-h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  });
  Cn = h.forwardRef(({ className: e, variant: t, size: n, asChild: r = false, ...s }, i) => {
    const o = r ? SN : "button";
    return S.jsx(o, {
      className: ct(kN({
        variant: t,
        size: n,
        className: e
      })),
      ref: i,
      ...s
    });
  });
  Cn.displayName = "Button";
  class _N extends h.Component {
    constructor() {
      super(...arguments), this.state = {
        hasError: false,
        error: null
      };
    }
    static getDerivedStateFromError(t) {
      return {
        hasError: true,
        error: t
      };
    }
    componentDidCatch(t, n) {
      console.error("Uncaught error:", t, n);
    }
    render() {
      return this.state.hasError ? this.props.fallback ? this.props.fallback : S.jsx("div", {
        className: "min-h-screen w-full flex items-center justify-center bg-zinc-950 p-4",
        children: S.jsxs("div", {
          className: "max-w-md w-full bg-zinc-900 border border-red-900/50 rounded-2xl p-8 text-center shadow-2xl",
          children: [
            S.jsx("div", {
              className: "w-16 h-16 bg-red-900/20 rounded-full flex items-center justify-center mx-auto mb-6",
              children: S.jsx(L_, {
                className: "w-8 h-8 text-red-500"
              })
            }),
            S.jsx("h2", {
              className: "text-2xl font-bold mb-2",
              children: "Something went wrong"
            }),
            S.jsx("p", {
              className: "text-zinc-400 mb-6 text-sm",
              children: "We encountered an unexpected error. The application state has been captured."
            }),
            S.jsx("div", {
              className: "p-4 bg-black/40 rounded-lg text-left mb-6 overflow-hidden",
              children: S.jsx("code", {
                className: "text-xs text-red-300 font-mono break-words line-clamp-3",
                children: this.state.error?.message
              })
            }),
            S.jsxs(Cn, {
              onClick: () => {
                this.setState({
                  hasError: false
                }), window.location.href = "/";
              },
              className: "w-full bg-red-600 hover:bg-red-700 text-white",
              children: [
                S.jsx(Ax, {
                  className: "w-4 h-4 mr-2"
                }),
                "Reload Application"
              ]
            })
          ]
        })
      }) : this.props.children;
    }
  }
  const AN = [
    "secure",
    "encrypted",
    "private",
    "anonymous",
    "free"
  ], RN = [
    "file sharing",
    "file transfer",
    "file upload"
  ], NN = [
    "secure file sharing free",
    "encrypted file upload",
    "private file sharing free",
    "anonymous file upload free",
    "secure file transfer free",
    "share files securely online free",
    "upload files without login",
    "encrypted file sharing free",
    "secure file transfer without account",
    "anonymous file upload and share",
    "send files securely online",
    "temporary file sharing link",
    "secure file sharing with auto delete",
    "send confidential files online",
    "secure document sharing without login",
    "AES-256 encrypted file sharing",
    "end-to-end encrypted file upload",
    "browser encrypted file sharing",
    "client-side encryption file sharing",
    "zero-knowledge file sharing",
    "private file sharing service",
    "anonymous secure file sharing",
    "no tracking file sharing",
    "secure file sharing without registration",
    "privacy focused file sharing",
    "temporary vault file sharing",
    "auto destruct file sharing",
    "one time download file sharing",
    "self destruct file link",
    "expiring file share link",
    "WeTransfer alternative secure",
    "SendAnywhere alternative private",
    "Google Drive alternative secure",
    "Dropbox alternative secure",
    "Firefox Send alternative",
    "secure alternative to Google Drive",
    "anonymous alternative to Dropbox",
    "free encrypted file sharing without login",
    "anonymous file sharing with auto delete",
    "secure file sharing with temporary links",
    "upload and share encrypted files instantly",
    "secure file transfer for developers",
    "secure file sharing for businesses",
    "encrypted file sharing for students",
    "share sensitive files securely online free",
    "upload confidential files securely",
    "how to share files securely online",
    "how to send confidential files safely",
    "how to upload files anonymously",
    "how to send files without login",
    "safest way to share files online",
    "how to share files without being tracked",
    "anonymous file sharing websites",
    "how to share files privately",
    "secure file sharing without account",
    "encrypted file sharing tools",
    "how to share large files securely with friends",
    "how to share project files privately",
    "free secure file sharing for students",
    "how to share API keys securely",
    "secure way to share config files",
    "encrypted file sharing for developers",
    "how to send confidential documents securely",
    "secure document sharing for business",
    "private file transfer for company",
    "upload secure files",
    "encrypt and share files",
    "share encrypted files",
    "send secure files",
    "private upload and share",
    "fast secure file transfer",
    "instant encrypted file sharing",
    "secure file sharing without login",
    "encrypted vault file sharing",
    "temporary encrypted vault",
    "private vault file sharing",
    "secure vault upload",
    "secure file sharing India",
    "encrypted file sharing India",
    "anonymous file sharing India",
    "private file sharing global"
  ];
  function wS() {
    const e = [];
    return AN.forEach((t) => {
      RN.forEach((n) => {
        e.push(`${t} ${n}`);
      });
    }), NN.forEach((t) => {
      e.includes(t) || e.push(t);
    }), e;
  }
  function xS(e) {
    return e.split(" ").map((t) => t.charAt(0).toUpperCase() + t.slice(1)).join(" ");
  }
  function SS() {
    const e = wS(), t = {};
    return e.forEach((n) => {
      const r = `/${n.replace(/\s+/g, "-")}`, s = xS(n);
      t[r] = {
        title: `${s} | VaultBridge \u2013 Free & Encrypted`,
        description: `${s} with VaultBridge. End-to-end AES-256 encrypted, no login required, auto-destruct links, temporary vaults, zero-knowledge privacy. The safest way to share files online. Free & open source.`,
        keywords: `${n}, VaultBridge, secure file sharing, encrypted file transfer, free encrypted upload, no login file sharing, anonymous file upload, temporary file links, self-destructing vault, privacy focused file sharing, zero knowledge, AES-256, share files securely online`
      };
    }), t;
  }
  A3 = function() {
    const e = wS(), t = {};
    return e.forEach((n) => {
      const r = `/${n.replace(/\s+/g, "-")}`, s = xS(n);
      t[r] = {
        slug: r,
        title: s,
        intro: `VaultBridge provides ${n} with privacy-first, zero-knowledge architecture. No login. No tracking. Just end-to-end encrypted security.`,
        explanation: `${s} securely with VaultBridge using end-to-end AES-256-GCM encryption. Files are encrypted entirely in your browser before upload, and decryption keys never leave your device. All vaults automatically expire, support burn-after-read, and require no account. Built as a secure alternative to Google Drive, WeTransfer, and Dropbox for users who prioritize privacy and anonymity.`,
        useCases: [
          "Confidential team collaboration and document exchange",
          "Secure sharing of API keys, passwords, and config files for developers",
          "Anonymous file upload and sharing without login or registration",
          "Temporary encrypted delivery with auto-destruct links",
          "Private file transfer for businesses and students",
          "Share sensitive files securely online free"
        ],
        seoFooter: `Start ${n} today with VaultBridge. Free, encrypted, anonymous. No login required. AES-256 encryption, temporary vaults, auto-destruct links, and zero-knowledge privacy. The safest way to share files online.`
      };
    }), t;
  };
  let dt, DN, MN, Dg;
  bS = [
    {
      slug: "secure-file-sharing-best-practices",
      title: "Secure File Sharing Best Practices for Teams",
      description: "Practical guidance for secure file sharing: encryption, access controls, retention policies, and temporary links.",
      excerpt: "A practical checklist for teams that need secure, temporary, and privacy-first file transfer workflows.",
      keywords: [
        "secure file sharing best practices",
        "encrypted file transfer checklist",
        "temporary secure links",
        "confidential file sharing"
      ],
      readTime: "6 min read",
      lastUpdated: "2026-02-20",
      sections: [
        {
          heading: "Start with a threat model, not a feature list",
          paragraphs: [
            "List what you are protecting, who can access it, and what happens if a link leaks. This prevents weak defaults.",
            "For most teams, the baseline controls are encrypted transfer, short retention, and strict download limits."
          ]
        },
        {
          heading: "Use temporary links and lifecycle controls",
          paragraphs: [
            "Files should not stay online forever. Expiration windows and burn-after-read limits reduce long-term risk.",
            "Treat file links like temporary credentials: rotate and revoke quickly when exposure is possible."
          ]
        },
        {
          heading: "Operationalize audits and incident response",
          paragraphs: [
            "Document who can create links, when data expires, and what triggers manual destruction. Keep this process lightweight.",
            "A strong process with simple controls beats a complex toolchain no one consistently follows."
          ]
        }
      ]
    },
    {
      slug: "encrypted-file-transfer-vs-cloud-storage",
      title: "Encrypted File Transfer vs Cloud Storage: When to Use Which",
      description: "A technical comparison between encrypted transfer workflows and permanent cloud storage platforms.",
      excerpt: "Understand the tradeoffs between temporary encrypted delivery and long-lived collaboration storage.",
      keywords: [
        "encrypted file transfer vs cloud storage",
        "secure file delivery",
        "temporary file sharing",
        "privacy-first storage alternatives"
      ],
      readTime: "7 min read",
      lastUpdated: "2026-02-20",
      sections: [
        {
          heading: "Different tools for different jobs",
          paragraphs: [
            "Encrypted transfer is optimized for delivery: send, receive, expire. Cloud storage is optimized for persistence and collaboration.",
            "Using permanent platforms for short-lived sensitive handoffs often creates unnecessary retention risk."
          ]
        },
        {
          heading: "Retention and privacy tradeoffs",
          paragraphs: [
            "Cloud platforms tend to preserve history and metadata. That helps collaboration but increases residual data.",
            "Transfer tools with short lifecycles keep less data around, which is usually better for confidentiality-sensitive payloads."
          ]
        },
        {
          heading: "Choose by lifecycle and exposure",
          paragraphs: [
            "If the file is one-time delivery, temporary encrypted transfer is usually the right default.",
            "If the file requires co-editing and long-term reference, cloud storage can be appropriate with strong controls."
          ]
        }
      ]
    },
    {
      slug: "anonymous-file-sharing-without-login",
      title: "Anonymous File Sharing Without Login: A Practical Guide",
      description: "How anonymous file sharing works, what security controls still matter, and where teams go wrong.",
      excerpt: "Anonymous sharing can be secure when encryption, expiry, and access controls are configured correctly.",
      keywords: [
        "anonymous file sharing",
        "no login file transfer",
        "private file upload",
        "secure anonymous sharing"
      ],
      readTime: "5 min read",
      lastUpdated: "2026-02-20",
      sections: [
        {
          heading: "No login does not mean no security",
          paragraphs: [
            "Accountless sharing removes friction, but security still depends on encryption and strict link controls.",
            "Use one-time codes or short retrieval windows to reduce unauthorized access opportunities."
          ]
        },
        {
          heading: "Minimize metadata and persistence",
          paragraphs: [
            "Anonymous workflows are strongest when platform-side data collection is minimal and retention is short.",
            "Avoid exposing identity markers in filenames, comments, or link-sharing channels."
          ]
        },
        {
          heading: "Set clear operational boundaries",
          paragraphs: [
            "Define which data classes can be sent via anonymous links and which require additional controls.",
            "Simple rules and short expiration defaults keep teams aligned without adding onboarding friction."
          ]
        }
      ]
    },
    {
      slug: "temporary-file-links-and-auto-destruct",
      title: "Temporary File Links and Auto-Destruct Policies Explained",
      description: "Why temporary links and auto-destruct policies are core controls for modern secure file transfer.",
      excerpt: "A breakdown of TTL windows, burn-after-read, and manual revoke patterns for safer file delivery.",
      keywords: [
        "temporary file links",
        "auto destruct file sharing",
        "time limited secure links",
        "burn after read file transfer"
      ],
      readTime: "6 min read",
      lastUpdated: "2026-02-20",
      sections: [
        {
          heading: "Why temporary links matter",
          paragraphs: [
            "Every additional hour a link is valid increases exposure. Time-bound links reduce the attack window.",
            "Expiration should be based on business need, not convenience defaults."
          ]
        },
        {
          heading: "Combine time and usage limits",
          paragraphs: [
            "TTL alone is good; TTL plus download-count limits is better. This limits replay and unintended redistribution.",
            "Burn-after-read can be effective for high-sensitivity handoffs where one retrieval is expected."
          ]
        },
        {
          heading: "Keep manual revoke available",
          paragraphs: [
            "Incidents happen. Manual destruction gives teams immediate control when a link is shared incorrectly.",
            "Pair this with auditable lifecycle logs so operational teams can verify the state quickly."
          ]
        }
      ]
    },
    {
      slug: "secure-alternative-to-google-drive-wetransfer",
      title: "Secure Alternative to Google Drive & WeTransfer for Private File Sharing",
      description: "Why VaultBridge is the best secure alternative to Google Drive, WeTransfer, Dropbox, and Firefox Send for privacy-focused encrypted file sharing without login.",
      excerpt: "Compare VaultBridge vs Google Drive, WeTransfer, and Dropbox. See why zero-knowledge encrypted file sharing with auto-destruct beats traditional cloud storage for sensitive files.",
      keywords: [
        "secure alternative to Google Drive",
        "WeTransfer alternative secure",
        "Dropbox alternative secure",
        "Firefox Send alternative",
        "anonymous alternative to Dropbox",
        "SendAnywhere alternative private",
        "private file sharing service",
        "encrypted file sharing free"
      ],
      readTime: "8 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "Why traditional cloud storage fails at privacy",
          paragraphs: [
            "Google Drive, Dropbox, and WeTransfer store your files permanently on their servers and retain metadata about who uploaded, downloaded, and shared content. This creates long-term privacy exposure that most users never consider.",
            "Cloud storage platforms are optimized for collaboration and persistence, not confidentiality. If your goal is to send files securely online without leaving a permanent trail, you need a fundamentally different architecture."
          ]
        },
        {
          heading: "VaultBridge vs Google Drive: Zero-knowledge vs full-knowledge",
          paragraphs: [
            "Google Drive encrypts files at rest, but Google holds the keys and can access your content. VaultBridge uses browser-side AES-256-GCM encryption where decryption keys never leave your device. Even we cannot read your files.",
            "With VaultBridge, there is no login, no account, no tracking cookies, and no analytics. Every file is encrypted before upload, stored as temporary encrypted blobs, and auto-destructed after expiration or first download."
          ]
        },
        {
          heading: "VaultBridge vs WeTransfer: Auto-destruct vs permanent links",
          paragraphs: [
            "WeTransfer keeps files available for 7 days on the free plan with no end-to-end encryption. VaultBridge gives you configurable expiry timers, download count limits, and burn-after-read \u2014 all with AES-256 client-side encryption.",
            "For sending confidential files online \u2014 contracts, medical records, API keys, or business documents \u2014 VaultBridge provides the security controls that WeTransfer and Dropbox simply do not offer."
          ]
        },
        {
          heading: "When to use encrypted file transfer vs cloud storage",
          paragraphs: [
            "Use VaultBridge for one-time delivery of sensitive files: secure document sharing for business, sharing API keys securely, private file transfer for companies, or anonymous file sharing without login.",
            "Use traditional cloud storage for long-term collaboration where persistence and co-editing are more important than confidentiality. For everything else, encrypted temporary vaults are the safest way to share files online."
          ]
        }
      ]
    },
    {
      slug: "encrypted-file-sharing-for-developers",
      title: "Encrypted File Sharing for Developers: Share API Keys, Config Files & Secrets Securely",
      description: "How developers can share API keys securely, transfer config files privately, and send secrets with end-to-end encrypted file sharing. No login required.",
      excerpt: "A developer's guide to sharing API keys, environment variables, SSH keys, and config files securely with end-to-end encryption and auto-destruct links.",
      keywords: [
        "encrypted file sharing for developers",
        "how to share API keys securely",
        "secure way to share config files",
        "secure file transfer for developers",
        "share secrets securely",
        "send files without login",
        "developer file sharing tool",
        "encrypted vault file sharing"
      ],
      readTime: "6 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "The developer secret-sharing problem",
          paragraphs: [
            "Every developer has faced the problem: how to share an API key, database credential, .env file, or SSH key with a teammate without exposing it in Slack, email, or a GitHub commit. Traditional methods like copy-pasting into chat channels create permanent, searchable exposure.",
            "VaultBridge solves this with encrypted file sharing that requires no login, no account, and automatically destroys the shared content after download. Your secrets stay secret."
          ]
        },
        {
          heading: "How to share API keys and config files securely",
          paragraphs: [
            "Upload your .env file, API key document, or config to VaultBridge. It is encrypted with AES-256-GCM in your browser before upload. You receive a 6-digit access code that you share with your teammate via a separate channel.",
            "Your teammate enters the code, the file is decrypted in their browser, and the vault auto-destructs. The server never sees the plaintext content, and no record of the transfer persists. This is zero-knowledge file sharing optimized for developer workflows."
          ]
        },
        {
          heading: "Clipboard sync for quick secret sharing",
          paragraphs: [
            "For small secrets like individual API keys or short config snippets, use VaultBridge's Universal Encrypted Clipboard. Paste your secret, and it's immediately encrypted and available on any device with the access code. The data lives only in RAM \u2014 never on disk.",
            "This is faster and more secure than any file sharing tool for quick developer secret exchange. It supports real-time sync via encrypted WebSockets with zero persistence."
          ]
        }
      ]
    },
    {
      slug: "secure-file-sharing-for-businesses",
      title: "Secure File Sharing for Businesses: Send Confidential Documents Without Risk",
      description: "How businesses can send confidential documents securely with encrypted file sharing and auto-destruct links. GDPR-friendly, no account required.",
      excerpt: "Enterprise-grade file security without the enterprise price tag. Send contracts, financial data, and HR documents with zero-knowledge encryption.",
      keywords: [
        "secure file sharing for businesses",
        "how to send confidential documents securely",
        "secure document sharing for business",
        "private file transfer for company",
        "send confidential files online",
        "encrypted document sharing",
        "business file sharing tool",
        "GDPR file sharing"
      ],
      readTime: "7 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "Why businesses need encrypted file transfer",
          paragraphs: [
            "Every business handles sensitive files: contracts, financial reports, employee records, client data, and legal documents. Sending these through email attachments or general cloud storage leaves permanent exposure trails that create compliance and liability risks.",
            "VaultBridge provides secure document sharing for businesses with end-to-end AES-256 encryption, configurable auto-destruct, and zero metadata retention. No accounts, no tracking, and no permanent storage."
          ]
        },
        {
          heading: "Compliance-friendly: GDPR, HIPAA and minimal data processing",
          paragraphs: [
            "Because VaultBridge operates on zero-knowledge architecture, we mathematically cannot access your files. This dramatically simplifies compliance requirements for GDPR, HIPAA, and other data protection regulations.",
            "We process the absolute minimum: encrypted blobs with routing IDs. No names, no email addresses, no IP logging beyond 24-hour DDoS protection. Your confidential business documents are truly confidential."
          ]
        },
        {
          heading: "Use cases: Legal, HR, Finance, and Client delivery",
          paragraphs: [
            "Legal departments can share contracts with auto-destruct after client review. HR can distribute compensation letters with burn-after-read. Finance can transfer spreadsheets with strict download limits.",
            "Client-facing teams can deliver sensitive deliverables via secure temporary links that expire automatically. No risk of stale links circulating months later. This is the safest way to share business files online."
          ]
        }
      ]
    },
    {
      slug: "free-secure-file-sharing-for-students",
      title: "Free Secure File Sharing for Students: Share Project Files Privately",
      description: "How students can share project files, assignments, and research securely with free encrypted file sharing. No login, no tracking, instant sharing.",
      excerpt: "A student's guide to sharing project files, research papers, and assignments securely and privately with free encrypted temporary links.",
      keywords: [
        "free secure file sharing for students",
        "encrypted file sharing for students",
        "how to share large files securely with friends",
        "how to share project files privately",
        "share files securely online free",
        "upload files without login",
        "anonymous file sharing",
        "student file sharing tool"
      ],
      readTime: "5 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "Why students need private file sharing",
          paragraphs: [
            "Students regularly share project files, research documents, lab reports, and presentations with classmates. Using public cloud links or social media file sharing exposes content to unintended audiences and creates permanent copies.",
            "VaultBridge lets you share files securely online for free with no login required. Upload your project, get a 6-digit code, share it with your group. Files auto-delete after expiration. Simple, private, and secure."
          ]
        },
        {
          heading: "How to share large files securely with friends",
          paragraphs: [
            "VaultBridge supports large file uploads with Brotli compression and chunked encrypted transfer. Even large datasets, video presentations, and research archives can be shared securely with a temporary link.",
            "Unlike Google Drive or Dropbox which require accounts and store files permanently, VaultBridge gives you temporary encrypted vaults that disappear after use. Perfect for sharing project files privately during a collaboration window."
          ]
        },
        {
          heading: "Secure collaboration without compromising privacy",
          paragraphs: [
            "No tracking cookies, no analytics, no registration. VaultBridge is free and open source \u2014 built for privacy-focused users who want anonymous file sharing without creating yet another account.",
            "Use VaultBridge whenever you need to share sensitive academic content: draft thesis chapters, personal statements, financial aid documents, or recommendation letters. Encrypt everything. Trust nothing."
          ]
        }
      ]
    },
    {
      slug: "zero-knowledge-file-sharing-explained",
      title: "Zero-Knowledge File Sharing Explained: How VaultBridge Keeps Files Private",
      description: "A complete guide to zero-knowledge architecture in file sharing. How VaultBridge uses client-side AES-256 encryption, split-key access, and ephemeral storage to make data breaches irrelevant.",
      excerpt: "Understand zero-knowledge encryption: why even a complete server breach cannot expose your files when they are encrypted before upload.",
      keywords: [
        "zero-knowledge file sharing",
        "client-side encryption file sharing",
        "AES-256 encrypted file sharing",
        "browser encrypted file sharing",
        "end-to-end encrypted file upload",
        "how VaultBridge encryption works",
        "privacy focused file sharing",
        "no tracking file sharing"
      ],
      readTime: "9 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "What zero-knowledge actually means in file sharing",
          paragraphs: [
            "Zero-knowledge means the server has zero ability to read, access, or decrypt your files. Unlike traditional encryption where the server holds keys, zero-knowledge systems ensure that keys exist only on the client device \u2014 in your browser's volatile memory.",
            "In VaultBridge, files are encrypted with AES-256-GCM using keys derived from a PIN that never touches the server. Even if our entire infrastructure is compromised, attackers get only random mathematical noise. Your data remains unreadable without the 6-digit PIN held exclusively by you."
          ]
        },
        {
          heading: "The Split-Key Protocol: Partial Key Routing",
          paragraphs: [
            "VaultBridge uses a split-key architecture. The 6-digit access code is divided: the first 3 digits serve as a routing ID (the server uses this to locate the encrypted blob), and the last 3 digits form the decryption PIN (which the server never sees).",
            "When you share a vault link with the code embedded as a URL hash fragment (#code), the hash is processed entirely by the browser and never transmitted to the server. This is privacy by architecture, not privacy by policy."
          ]
        },
        {
          heading: "Why ephemeral storage makes data breaches irrelevant",
          paragraphs: [
            "All VaultBridge vaults have strict lifecycle controls: time-based expiration, download count limits, and burn-after-read auto-destruct. Even if encrypted blobs are intercepted, they decay automatically.",
            "Combined with zero-knowledge encryption, this creates a mathematically unbreakable system: expired encrypted data without keys is useless noise. No identity, no metadata, no recovery. Your privacy is not a policy \u2014 it is physics."
          ]
        }
      ]
    },
    {
      slug: "auto-destruct-file-sharing-burn-after-read",
      title: "Auto-Destruct File Sharing & Burn-After-Read: Complete Guide",
      description: "How auto-destruct and burn-after-read file sharing works. Learn about self-destructing file links, temporary vaults, and expiring file share links for maximum security.",
      excerpt: "A complete guide to auto-destruct file sharing: self-destructing links, burn-after-read, and temporary encrypted vaults for one-time secure delivery.",
      keywords: [
        "auto destruct file sharing",
        "burn after read file sharing",
        "self destruct file link",
        "temporary file sharing link",
        "expiring file share link",
        "one time download file sharing",
        "temporary vault file sharing",
        "secure file sharing with auto delete"
      ],
      readTime: "6 min read",
      lastUpdated: "2026-02-21",
      sections: [
        {
          heading: "What is auto-destruct file sharing?",
          paragraphs: [
            "Auto-destruct file sharing means your files are automatically deleted after a predefined trigger: a time window expires, a download limit is reached, or the recipient reads the content once (burn-after-read). This is the opposite of permanent cloud storage.",
            "VaultBridge offers all three auto-destruct mechanisms. You control the expiration timer (1 hour to 7 days), the maximum number of downloads per file, and whether the vault should self-destruct immediately after the first successful download."
          ]
        },
        {
          heading: "Burn-after-read: One-time secure delivery",
          paragraphs: [
            "Burn-after-read is the most secure sharing mode. The encrypted vault is destroyed the moment the recipient successfully downloads and decrypts the file. No copies remain on the server, no link can be reused.",
            "This is ideal for sending confidential files online: passwords, legal documents, medical records, financial statements, and API keys. One read, then gone forever. The safest way to share files online."
          ]
        },
        {
          heading: "Self-destructing links vs permanent cloud links",
          paragraphs: [
            "A permanent Google Drive or Dropbox link can be forwarded, bookmarked, and accessed indefinitely unless manually revoked. Self-destructing links from VaultBridge have a mathematical expiration built into their lifecycle.",
            "Even if someone intercepts an expired link, the encrypted data has already been purged from the server. Combined with AES-256 encryption and zero-knowledge architecture, self-destructing file links provide defense-in-depth that permanent storage cannot match."
          ]
        }
      ]
    }
  ];
  R3 = bS.reduce((e, t) => (e[t.slug] = t, e), {});
  dt = {
    siteName: "VaultBridge",
    title: "VaultBridge | Secure Encrypted File Sharing & Transfer",
    description: "Share sensitive files securely with end-to-end AES-256 encryption. Self-destructing vaults, direct email relay, encrypted clipboard, zero-knowledge privacy. No account required. Free & open source.",
    keywords: "secure file transfer, encrypted file sharing, end-to-end encryption, privacy, self-destructing links, zero knowledge, AES-256, anonymous file sharing, encrypted email, secure clipboard",
    image: "/og-image.png",
    url: "https://vaultbridge.org",
    type: "website"
  };
  DN = {
    "/": {
      title: "VaultBridge | Secure Encrypted File Sharing & Transfer",
      description: "Share sensitive files securely with end-to-end AES-256 encryption. Self-destructing vaults, encrypted email relay, secure clipboard sync, and zero-knowledge privacy. No account required.",
      keywords: "secure file transfer, encrypted file sharing, end-to-end encryption, privacy, self-destructing links, zero knowledge, AES-256, anonymous file sharing, send files securely, encrypted storage"
    },
    "/upload": {
      title: "Upload & Encrypt Files Securely | VaultBridge Secure Vault",
      description: "Upload and encrypt your files with military-grade AES-256-GCM encryption. Set custom expiration times, download limits, and burn-on-read. Create self-destructing secure vaults instantly.",
      keywords: "secure file upload, encrypt files online, AES-256 encryption, self-destructing vault, secure file storage, burn after read, encrypted upload, file expiry, download limit"
    },
    "/access": {
      title: "Access Secure Vault | Decrypt & Download Files | VaultBridge",
      description: "Enter your 6-digit access code to unlock and download encrypted files. Zero-knowledge decryption happens entirely in your browser. No data is ever exposed to the server.",
      keywords: "access encrypted vault, download encrypted files, secure access code, vault unlock, zero knowledge download, decrypt files, secure file retrieval"
    },
    "/download": {
      title: "Secure File Download | Decrypt & Access Vault | VaultBridge",
      description: "Securely download encrypted files from VaultBridge. End-to-end AES-256 decryption in your browser. Files self-destruct after access limits are reached.",
      keywords: "secure download, encrypted file download, burn on read, self-destructing file, AES-256 decryption, secure vault access"
    },
    "/get-it-mailed": {
      title: "Get it Mailed | Send Files Securely via Email | VaultBridge",
      description: "Send files securely to anyone via email. Files are encrypted with AES-256 and relayed as ephemeral attachments. Zero-knowledge relay \u2014 no files are stored on our servers. No account needed.",
      keywords: "send encrypted files, secure email attachments, email file transfer, encrypted email relay, send files via email, secure file delivery, zero knowledge email, ephemeral file transfer"
    },
    "/clipboard": {
      title: "Secure Clipboard | Encrypted Text Sharing Across Devices | VaultBridge",
      description: "Share passwords, API keys, code snippets, and sensitive text across devices with end-to-end AES-256 encryption. Real-time sync with auto-destruct. No account required.",
      keywords: "encrypted clipboard, secure text sharing, share passwords securely, encrypted notes, cross-device clipboard, secure clipboard sync, AES-256 text encryption, share secrets, share API keys"
    },
    "/live": {
      title: "Live P2P File Transfer | WebRTC Encrypted | VaultBridge",
      description: "Transfer files directly between devices with WebRTC. Real-time P2P connection with end-to-end encryption. No server storage, no upload wait.",
      keywords: "P2P transfer, WebRTC file sharing, direct file transfer, peer-to-peer, real-time transfer, encrypted P2P, no server storage"
    },
    "/success": {
      title: "Vault Created Successfully | VaultBridge",
      description: "Your secure vault has been created. Share the access code or direct link to allow others to download your encrypted files securely."
    },
    "/terms": {
      title: "Terms of Service | VaultBridge",
      description: "Read the terms of service for using VaultBridge secure file sharing platform. Understand your rights and responsibilities.",
      keywords: "terms of service, VaultBridge terms, usage policy, file sharing terms"
    },
    "/privacy": {
      title: "Privacy Policy | VaultBridge",
      description: "Learn how VaultBridge protects your privacy with zero-knowledge architecture, end-to-end encryption, and a strict no-logs policy. Your data stays yours.",
      keywords: "privacy policy, VaultBridge privacy, zero knowledge privacy, no logs policy, data protection, encrypted file sharing privacy"
    },
    "/how-it-works": {
      title: "How VaultBridge Works | End-to-End Encrypted File Sharing Explained",
      description: "Understand the security architecture behind VaultBridge. Learn how AES-256 encryption, split-key access codes, and self-destructing vaults keep your files safe.",
      keywords: "how encryption works, AES-256 explained, zero knowledge architecture, secure file sharing explained, self-destructing vaults, split-key encryption"
    },
    "/security": {
      title: "Security Architecture | VaultBridge",
      description: "Technical security architecture for VaultBridge: encryption model, key flow, file lifecycle, and auto-destruct logic.",
      keywords: "vaultbridge security architecture, client-side encryption, zero-knowledge file sharing, file lifecycle security, auto-destruct logic"
    },
    "/privacy-manifesto": {
      title: "Privacy Manifesto | VaultBridge",
      description: "Why VaultBridge exists: privacy-first architecture, minimal data collection, and user-controlled secure transfer.",
      keywords: "privacy manifesto, privacy-first file sharing, zero tracking philosophy, user controlled security"
    },
    "/roadmap": {
      title: "Public Roadmap | VaultBridge",
      description: "Transparent roadmap for VaultBridge: upcoming security, privacy, and product milestones.",
      keywords: "vaultbridge roadmap, secure file sharing roadmap, privacy product roadmap"
    },
    "/blog": {
      title: "VaultBridge Blog | Privacy and Security Guides",
      description: "Technical articles on secure file transfer, encrypted delivery, anonymous sharing, and lifecycle security controls.",
      keywords: "vaultbridge blog, secure file sharing guides, encrypted transfer best practices, privacy-first file delivery"
    },
    "/secure-file-sharing-free": {
      title: "Secure File Sharing Free | VaultBridge",
      description: "Secure file sharing without login, tracking, or permanent storage. Encrypted transfers with temporary lifecycle controls.",
      keywords: "secure file sharing free, private file sharing, no login file sharing, encrypted secure link sharing"
    },
    "/encrypted-file-transfer": {
      title: "Encrypted File Transfer | VaultBridge",
      description: "Encrypted file transfer with temporary storage and secure access. Built for privacy-conscious sharing.",
      keywords: "encrypted file transfer, secure transfer links, privacy file transfer, zero tracking file sharing"
    },
    "/private-file-sharing": {
      title: "Private File Sharing | VaultBridge",
      description: "Private file sharing for teams and individuals who need secure, temporary, encrypted delivery.",
      keywords: "private file sharing, confidential file transfer, encrypted private upload, secure temporary file storage"
    },
    "/anonymous-file-sharing": {
      title: "Anonymous File Sharing | VaultBridge",
      description: "Share files anonymously with encrypted transfer and temporary retention controls.",
      keywords: "anonymous file sharing, no account file sharing, anonymous encrypted sharing, privacy sharing tool"
    },
    "/free-encrypted-upload": {
      title: "Free Encrypted Upload | VaultBridge",
      description: "Free encrypted upload flow for secure sharing without account friction.",
      keywords: "free encrypted upload, secure encrypted upload, no login encrypted transfer, privacy-first upload"
    },
    "/send-files-securely": {
      title: "Send Files Securely | VaultBridge",
      description: "Send files securely with encrypted transfer, temporary vault lifecycle, and zero tracking defaults.",
      keywords: "send files securely, secure file transfer, encrypted link sharing, temporary secure vault"
    }
  };
  MN = Object.fromEntries(bS.map((e) => [
    `/blog/${e.slug}`,
    {
      title: `${e.title} | VaultBridge Blog`,
      description: e.description,
      keywords: e.keywords.join(", ")
    }
  ]));
  Dg = {
    ...SS(),
    ...DN,
    ...MN
  };
  function ON(e) {
    const [t] = xh();
    h.useEffect(() => {
      const n = t.endsWith("/") && t.length > 1 ? t.slice(0, -1) : t, r = "/" + n.split("/")[1], s = Dg[n] || Dg[r] || {}, i = {
        ...dt,
        ...s,
        ...e
      };
      document.title = i.title || dt.title;
      const o = (l, u, c) => {
        let d = document.querySelector(l);
        if (!d) {
          d = document.createElement("meta");
          const [f, p] = l.replace("meta[", "").replace("]", "").split("=");
          d.setAttribute(f, p?.replace(/"/g, "") || ""), document.head.appendChild(d);
        }
        d.setAttribute(u, c);
      };
      o('meta[name="description"]', "content", i.description || dt.description), o('meta[name="keywords"]', "content", i.keywords || dt.keywords), o('meta[property="og:title"]', "content", i.title || dt.title), o('meta[property="og:description"]', "content", i.description || dt.description), o('meta[property="og:url"]', "content", `${dt.url}${n}`), o('meta[property="og:image"]', "content", i.image || dt.image), o('meta[property="og:type"]', "content", i.type || dt.type), o('meta[name="twitter:title"]', "content", i.title || dt.title), o('meta[name="twitter:description"]', "content", i.description || dt.description), o('meta[name="twitter:image"]', "content", i.image || dt.image), o('meta[name="twitter:url"]', "content", `${dt.url}${n}`);
      let a = document.querySelector('link[rel="canonical"]');
      a || (a = document.createElement("link"), a.rel = "canonical", document.head.appendChild(a)), a.href = `${dt.url}${n}`;
    }, [
      t,
      e
    ]);
  }
  const Wh = h.createContext({});
  Hh = function(e) {
    const t = h.useRef(null);
    return t.current === null && (t.current = e()), t.current;
  };
  let yu;
  yu = h.createContext(null);
  Kh = h.createContext({
    transformPagePoint: (e) => e,
    isStatic: false,
    reducedMotion: "never"
  });
  class IN extends h.Component {
    getSnapshotBeforeUpdate(t) {
      const n = this.props.childRef.current;
      if (n && t.isPresent && !this.props.isPresent) {
        const r = this.props.sizeRef.current;
        r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
      }
      return null;
    }
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  }
  function LN({ children: e, isPresent: t }) {
    const n = h.useId(), r = h.useRef(null), s = h.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0
    }), { nonce: i } = h.useContext(Kh);
    return h.useInsertionEffect(() => {
      const { width: o, height: a, top: l, left: u } = s.current;
      if (t || !r.current || !o || !a) return;
      r.current.dataset.motionPopId = n;
      const c = document.createElement("style");
      return i && (c.nonce = i), document.head.appendChild(c), c.sheet && c.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${u}px !important;
          }
        `), () => {
        document.head.removeChild(c);
      };
    }, [
      t
    ]), S.jsx(IN, {
      isPresent: t,
      childRef: r,
      sizeRef: s,
      children: h.cloneElement(e, {
        ref: r
      })
    });
  }
  const jN = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o }) => {
    const a = Hh(VN), l = h.useId(), u = h.useCallback((d) => {
      a.set(d, true);
      for (const f of a.values()) if (!f) return;
      r && r();
    }, [
      a,
      r
    ]), c = h.useMemo(() => ({
      id: l,
      initial: t,
      isPresent: n,
      custom: s,
      onExitComplete: u,
      register: (d) => (a.set(d, false), () => a.delete(d))
    }), i ? [
      Math.random(),
      u
    ] : [
      n,
      u
    ]);
    return h.useMemo(() => {
      a.forEach((d, f) => a.set(f, false));
    }, [
      n
    ]), h.useEffect(() => {
      !n && !a.size && r && r();
    }, [
      n
    ]), o === "popLayout" && (e = S.jsx(LN, {
      isPresent: n,
      children: e
    })), S.jsx(yu.Provider, {
      value: c,
      children: e
    });
  };
  function VN() {
    return /* @__PURE__ */ new Map();
  }
  function TS(e = true) {
    const t = h.useContext(yu);
    if (t === null) return [
      true,
      null
    ];
    const { isPresent: n, onExitComplete: r, register: s } = t, i = h.useId();
    h.useEffect(() => {
      e && s(i);
    }, [
      e
    ]);
    const o = h.useCallback(() => e && r && r(i), [
      i,
      r,
      e
    ]);
    return !n && r ? [
      false,
      o
    ] : [
      true
    ];
  }
  const ya = (e) => e.key || "";
  function Mg(e) {
    const t = [];
    return h.Children.forEach(e, (n) => {
      h.isValidElement(n) && t.push(n);
    }), t;
  }
  let Qh;
  Qh = typeof window < "u";
  CS = Qh ? h.useLayoutEffect : h.useEffect;
  Ai = ({ children: e, custom: t, initial: n = true, onExitComplete: r, presenceAffectsLayout: s = true, mode: i = "sync", propagate: o = false }) => {
    const [a, l] = TS(o), u = h.useMemo(() => Mg(e), [
      e
    ]), c = o && !a ? [] : u.map(ya), d = h.useRef(true), f = h.useRef(u), p = Hh(() => /* @__PURE__ */ new Map()), [w, g] = h.useState(u), [x, m] = h.useState(u);
    CS(() => {
      d.current = false, f.current = u;
      for (let b = 0; b < x.length; b++) {
        const T = ya(x[b]);
        c.includes(T) ? p.delete(T) : p.get(T) !== true && p.set(T, false);
      }
    }, [
      x,
      c.length,
      c.join("-")
    ]);
    const y = [];
    if (u !== w) {
      let b = [
        ...u
      ];
      for (let T = 0; T < x.length; T++) {
        const C = x[T], E = ya(C);
        c.includes(E) || (b.splice(T, 0, C), y.push(C));
      }
      i === "wait" && y.length && (b = y), m(Mg(b)), g(u);
      return;
    }
    const { forceRender: v } = h.useContext(Wh);
    return S.jsx(S.Fragment, {
      children: x.map((b) => {
        const T = ya(b), C = o && !a ? false : u === x || c.includes(T), E = () => {
          if (p.has(T)) p.set(T, true);
          else return;
          let P = true;
          p.forEach((D) => {
            D || (P = false);
          }), P && (v?.(), m(f.current), o && l?.(), r && r());
        };
        return S.jsx(jN, {
          isPresent: C,
          initial: !d.current || n ? void 0 : false,
          custom: C ? void 0 : t,
          presenceAffectsLayout: s,
          mode: i,
          onExitComplete: C ? void 0 : E,
          children: b
        }, T);
      })
    });
  };
  vt = (e) => e;
  let ES;
  N3 = vt;
  ES = vt;
  function Gh(e) {
    let t;
    return () => (t === void 0 && (t = e()), t);
  }
  let Nn, Dn, FN;
  Gs = (e, t, n) => {
    const r = t - e;
    return r === 0 ? 1 : (n - e) / r;
  };
  Nn = (e) => e * 1e3;
  Dn = (e) => e / 1e3;
  FN = {
    useManualTiming: false
  };
  function zN(e) {
    let t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = false, s = false;
    const i = /* @__PURE__ */ new WeakSet();
    let o = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    function a(u) {
      i.has(u) && (l.schedule(u), e()), u(o);
    }
    const l = {
      schedule: (u, c = false, d = false) => {
        const p = d && r ? t : n;
        return c && i.add(u), p.has(u) || p.add(u), u;
      },
      cancel: (u) => {
        n.delete(u), i.delete(u);
      },
      process: (u) => {
        if (o = u, r) {
          s = true;
          return;
        }
        r = true, [t, n] = [
          n,
          t
        ], t.forEach(a), t.clear(), r = false, s && (s = false, l.process(u));
      }
    };
    return l;
  }
  const va = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender"
  ], BN = 40;
  function PS(e, t) {
    let n = false, r = true;
    const s = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    }, i = () => n = true, o = va.reduce((m, y) => (m[y] = zN(i), m), {}), { read: a, resolveKeyframes: l, update: u, preRender: c, render: d, postRender: f } = o, p = () => {
      const m = performance.now();
      n = false, s.delta = r ? 1e3 / 60 : Math.max(Math.min(m - s.timestamp, BN), 1), s.timestamp = m, s.isProcessing = true, a.process(s), l.process(s), u.process(s), c.process(s), d.process(s), f.process(s), s.isProcessing = false, n && t && (r = false, e(p));
    }, w = () => {
      n = true, r = true, s.isProcessing || e(p);
    };
    return {
      schedule: va.reduce((m, y) => {
        const v = o[y];
        return m[y] = (b, T = false, C = false) => (n || w(), v.schedule(b, T, C)), m;
      }, {}),
      cancel: (m) => {
        for (let y = 0; y < va.length; y++) o[va[y]].cancel(m);
      },
      state: s,
      steps: o
    };
  }
  let hc, kS, Og, qs;
  ({ schedule: ge, cancel: pr, state: Ke, steps: hc } = PS(typeof requestAnimationFrame < "u" ? requestAnimationFrame : vt, true));
  kS = h.createContext({
    strict: false
  });
  Og = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: [
      "exit"
    ],
    drag: [
      "drag",
      "dragControls"
    ],
    focus: [
      "whileFocus"
    ],
    hover: [
      "whileHover",
      "onHoverStart",
      "onHoverEnd"
    ],
    tap: [
      "whileTap",
      "onTap",
      "onTapStart",
      "onTapCancel"
    ],
    pan: [
      "onPan",
      "onPanStart",
      "onPanSessionStart",
      "onPanEnd"
    ],
    inView: [
      "whileInView",
      "onViewportEnter",
      "onViewportLeave"
    ],
    layout: [
      "layout",
      "layoutId"
    ]
  };
  qs = {};
  for (const e in Og) qs[e] = {
    isEnabled: (t) => Og[e].some((n) => !!t[n])
  };
  function UN(e) {
    for (const t in e) qs[t] = {
      ...qs[t],
      ...e[t]
    };
  }
  const $N = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function Cl(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || $N.has(e);
  }
  let _S = (e) => !Cl(e);
  function WN(e) {
    e && (_S = (t) => t.startsWith("on") ? !Cl(t) : e(t));
  }
  try {
    WN(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function HN(e, t, n) {
    const r = {};
    for (const s in e) s === "values" && typeof e.values == "object" || (_S(s) || n === true && Cl(s) || !t && !Cl(s) || e.draggable && s.startsWith("onDrag")) && (r[s] = e[s]);
    return r;
  }
  function KN(e) {
    if (typeof Proxy > "u") return e;
    const t = /* @__PURE__ */ new Map(), n = (...r) => e(...r);
    return new Proxy(n, {
      get: (r, s) => s === "create" ? e : (t.has(s) || t.set(s, e(s)), t.get(s))
    });
  }
  const vu = h.createContext({});
  function ho(e) {
    return typeof e == "string" || Array.isArray(e);
  }
  function wu(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function";
  }
  const qh = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ], Zh = [
    "initial",
    ...qh
  ];
  function xu(e) {
    return wu(e.animate) || Zh.some((t) => ho(e[t]));
  }
  function AS(e) {
    return !!(xu(e) || e.variants);
  }
  function QN(e, t) {
    if (xu(e)) {
      const { initial: n, animate: r } = e;
      return {
        initial: n === false || ho(n) ? n : void 0,
        animate: ho(r) ? r : void 0
      };
    }
    return e.inherit !== false ? t : {};
  }
  function GN(e) {
    const { initial: t, animate: n } = QN(e, h.useContext(vu));
    return h.useMemo(() => ({
      initial: t,
      animate: n
    }), [
      Ig(t),
      Ig(n)
    ]);
  }
  function Ig(e) {
    return Array.isArray(e) ? e.join(" ") : e;
  }
  const qN = Symbol.for("motionComponentSymbol");
  function vs(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
  }
  function ZN(e, t, n) {
    return h.useCallback((r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : vs(n) && (n.current = r));
    }, [
      t
    ]);
  }
  const Yh = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), YN = "framerAppearId", RS = "data-" + Yh(YN), { schedule: Xh } = PS(queueMicrotask, false), NS = h.createContext({});
  function XN(e, t, n, r, s) {
    var i, o;
    const { visualElement: a } = h.useContext(vu), l = h.useContext(kS), u = h.useContext(yu), c = h.useContext(Kh).reducedMotion, d = h.useRef(null);
    r = r || l.renderer, !d.current && r && (d.current = r(e, {
      visualState: t,
      parent: a,
      props: n,
      presenceContext: u,
      blockInitialAnimation: u ? u.initial === false : false,
      reducedMotionConfig: c
    }));
    const f = d.current, p = h.useContext(NS);
    f && !f.projection && s && (f.type === "html" || f.type === "svg") && JN(d.current, n, s, p);
    const w = h.useRef(false);
    h.useInsertionEffect(() => {
      f && w.current && f.update(n, u);
    });
    const g = n[RS], x = h.useRef(!!g && !(!((i = window.MotionHandoffIsComplete) === null || i === void 0) && i.call(window, g)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, g)));
    return CS(() => {
      f && (w.current = true, window.MotionIsMounted = true, f.updateFeatures(), Xh.render(f.render), x.current && f.animationState && f.animationState.animateChanges());
    }), h.useEffect(() => {
      f && (!x.current && f.animationState && f.animationState.animateChanges(), x.current && (queueMicrotask(() => {
        var m;
        (m = window.MotionHandoffMarkAsComplete) === null || m === void 0 || m.call(window, g);
      }), x.current = false));
    }), f;
  }
  function JN(e, t, n, r) {
    const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: u } = t;
    e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : DS(e.parent)), e.projection.setOptions({
      layoutId: s,
      layout: i,
      alwaysMeasureLayout: !!o || a && vs(a),
      visualElement: e,
      animationType: typeof i == "string" ? i : "both",
      initialPromotionConfig: r,
      layoutScroll: l,
      layoutRoot: u
    });
  }
  function DS(e) {
    if (e) return e.options.allowProjection !== false ? e.projection : DS(e.parent);
  }
  function e2({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: s }) {
    var i, o;
    e && UN(e);
    function a(u, c) {
      let d;
      const f = {
        ...h.useContext(Kh),
        ...u,
        layoutId: t2(u)
      }, { isStatic: p } = f, w = GN(u), g = r(u, p);
      if (!p && Qh) {
        n2();
        const x = r2(f);
        d = x.MeasureLayout, w.visualElement = XN(s, g, f, t, x.ProjectionNode);
      }
      return S.jsxs(vu.Provider, {
        value: w,
        children: [
          d && w.visualElement ? S.jsx(d, {
            visualElement: w.visualElement,
            ...f
          }) : null,
          n(s, u, ZN(g, w.visualElement, c), g, p, w.visualElement)
        ]
      });
    }
    a.displayName = `motion.${typeof s == "string" ? s : `create(${(o = (i = s.displayName) !== null && i !== void 0 ? i : s.name) !== null && o !== void 0 ? o : ""})`}`;
    const l = h.forwardRef(a);
    return l[qN] = s, l;
  }
  function t2({ layoutId: e }) {
    const t = h.useContext(Wh).id;
    return t && e !== void 0 ? t + "-" + e : e;
  }
  function n2(e, t) {
    h.useContext(kS).strict;
  }
  function r2(e) {
    const { drag: t, layout: n } = qs;
    if (!t && !n) return {};
    const r = {
      ...t,
      ...n
    };
    return {
      MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0,
      ProjectionNode: r.ProjectionNode
    };
  }
  const s2 = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function Jh(e) {
    return typeof e != "string" || e.includes("-") ? false : !!(s2.indexOf(e) > -1 || /[A-Z]/u.test(e));
  }
  function Lg(e) {
    const t = [
      {},
      {}
    ];
    return e?.values.forEach((n, r) => {
      t[0][r] = n.get(), t[1][r] = n.getVelocity();
    }), t;
  }
  function ep(e, t, n, r) {
    if (typeof t == "function") {
      const [s, i] = Lg(r);
      t = t(n !== void 0 ? n : e.custom, s, i);
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
      const [s, i] = Lg(r);
      t = t(n !== void 0 ? n : e.custom, s, i);
    }
    return t;
  }
  const Kd = (e) => Array.isArray(e), i2 = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), o2 = (e) => Kd(e) ? e[e.length - 1] || 0 : e, et = (e) => !!(e && e.getVelocity);
  function Ua(e) {
    const t = et(e) ? e.get() : e;
    return i2(t) ? t.toValue() : t;
  }
  function a2({ scrapeMotionValuesFromProps: e, createRenderState: t, onUpdate: n }, r, s, i) {
    const o = {
      latestValues: l2(r, s, i, e),
      renderState: t()
    };
    return n && (o.onMount = (a) => n({
      props: r,
      current: a,
      ...o
    }), o.onUpdate = (a) => n(a)), o;
  }
  const MS = (e) => (t, n) => {
    const r = h.useContext(vu), s = h.useContext(yu), i = () => a2(e, t, r, s);
    return n ? i() : Hh(i);
  };
  function l2(e, t, n, r) {
    const s = {}, i = r(e, {});
    for (const f in i) s[f] = Ua(i[f]);
    let { initial: o, animate: a } = e;
    const l = xu(e), u = AS(e);
    t && u && !l && e.inherit !== false && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate));
    let c = n ? n.initial === false : false;
    c = c || o === false;
    const d = c ? a : o;
    if (d && typeof d != "boolean" && !wu(d)) {
      const f = Array.isArray(d) ? d : [
        d
      ];
      for (let p = 0; p < f.length; p++) {
        const w = ep(e, f[p]);
        if (w) {
          const { transitionEnd: g, transition: x, ...m } = w;
          for (const y in m) {
            let v = m[y];
            if (Array.isArray(v)) {
              const b = c ? v.length - 1 : 0;
              v = v[b];
            }
            v !== null && (s[y] = v);
          }
          for (const y in g) s[y] = g[y];
        }
      }
    }
    return s;
  }
  let ci, es, OS, IS, u2, tp, c2, LS, di, po, wa, $o, Qn, fn, H, d2, f2, jg, h2, p2, Vg, np, m2, g2;
  ci = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  es = new Set(ci);
  OS = (e) => (t) => typeof t == "string" && t.startsWith(e);
  IS = OS("--");
  u2 = OS("var(--");
  tp = (e) => u2(e) ? c2.test(e.split("/*")[0].trim()) : false;
  c2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  LS = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
  zn = (e, t, n) => n > t ? t : n < e ? e : n;
  di = {
    test: (e) => typeof e == "number",
    parse: parseFloat,
    transform: (e) => e
  };
  po = {
    ...di,
    transform: (e) => zn(0, 1, e)
  };
  wa = {
    ...di,
    default: 1
  };
  $o = (e) => ({
    test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: (t) => `${t}${e}`
  });
  Qn = $o("deg");
  fn = $o("%");
  H = $o("px");
  d2 = $o("vh");
  f2 = $o("vw");
  jg = {
    ...fn,
    parse: (e) => fn.parse(e) / 100,
    transform: (e) => fn.transform(e * 100)
  };
  h2 = {
    borderWidth: H,
    borderTopWidth: H,
    borderRightWidth: H,
    borderBottomWidth: H,
    borderLeftWidth: H,
    borderRadius: H,
    radius: H,
    borderTopLeftRadius: H,
    borderTopRightRadius: H,
    borderBottomRightRadius: H,
    borderBottomLeftRadius: H,
    width: H,
    maxWidth: H,
    height: H,
    maxHeight: H,
    top: H,
    right: H,
    bottom: H,
    left: H,
    padding: H,
    paddingTop: H,
    paddingRight: H,
    paddingBottom: H,
    paddingLeft: H,
    margin: H,
    marginTop: H,
    marginRight: H,
    marginBottom: H,
    marginLeft: H,
    backgroundPositionX: H,
    backgroundPositionY: H
  };
  p2 = {
    rotate: Qn,
    rotateX: Qn,
    rotateY: Qn,
    rotateZ: Qn,
    scale: wa,
    scaleX: wa,
    scaleY: wa,
    scaleZ: wa,
    skew: Qn,
    skewX: Qn,
    skewY: Qn,
    distance: H,
    translateX: H,
    translateY: H,
    translateZ: H,
    x: H,
    y: H,
    z: H,
    perspective: H,
    transformPerspective: H,
    opacity: po,
    originX: jg,
    originY: jg,
    originZ: H
  };
  Vg = {
    ...di,
    transform: Math.round
  };
  np = {
    ...h2,
    ...p2,
    zIndex: Vg,
    size: H,
    fillOpacity: po,
    strokeOpacity: po,
    numOctaves: Vg
  };
  m2 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  g2 = ci.length;
  function y2(e, t, n) {
    let r = "", s = true;
    for (let i = 0; i < g2; i++) {
      const o = ci[i], a = e[o];
      if (a === void 0) continue;
      let l = true;
      if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
        const u = LS(a, np[o]);
        if (!l) {
          s = false;
          const c = m2[o] || o;
          r += `${c}(${u}) `;
        }
        n && (t[o] = u);
      }
    }
    return r = r.trim(), n ? r = n(t, s ? "" : r) : s && (r = "none"), r;
  }
  function rp(e, t, n) {
    const { style: r, vars: s, transformOrigin: i } = e;
    let o = false, a = false;
    for (const l in t) {
      const u = t[l];
      if (es.has(l)) {
        o = true;
        continue;
      } else if (IS(l)) {
        s[l] = u;
        continue;
      } else {
        const c = LS(u, np[l]);
        l.startsWith("origin") ? (a = true, i[l] = c) : r[l] = c;
      }
    }
    if (t.transform || (o || n ? r.transform = y2(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
      const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = i;
      r.transformOrigin = `${l} ${u} ${c}`;
    }
  }
  const v2 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  }, w2 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function x2(e, t, n = 1, r = 0, s = true) {
    e.pathLength = 1;
    const i = s ? v2 : w2;
    e[i.offset] = H.transform(-r);
    const o = H.transform(t), a = H.transform(n);
    e[i.array] = `${o} ${a}`;
  }
  function Fg(e, t, n) {
    return typeof e == "string" ? e : H.transform(t + n * e);
  }
  function S2(e, t, n) {
    const r = Fg(t, e.x, e.width), s = Fg(n, e.y, e.height);
    return `${r} ${s}`;
  }
  function sp(e, { attrX: t, attrY: n, attrScale: r, originX: s, originY: i, pathLength: o, pathSpacing: a = 1, pathOffset: l = 0, ...u }, c, d) {
    if (rp(e, u, d), c) {
      e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
      return;
    }
    e.attrs = e.style, e.style = {};
    const { attrs: f, style: p, dimensions: w } = e;
    f.transform && (w && (p.transform = f.transform), delete f.transform), w && (s !== void 0 || i !== void 0 || p.transform) && (p.transformOrigin = S2(w, s !== void 0 ? s : 0.5, i !== void 0 ? i : 0.5)), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), o !== void 0 && x2(f, o, a, l, false);
  }
  const ip = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  }), jS = () => ({
    ...ip(),
    attrs: {}
  }), op = (e) => typeof e == "string" && e.toLowerCase() === "svg";
  function VS(e, { style: t, vars: n }, r, s) {
    Object.assign(e.style, t, s && s.getProjectionStyles(r));
    for (const i in n) e.style.setProperty(i, n[i]);
  }
  const FS = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);
  function zS(e, t, n, r) {
    VS(e, t, void 0, r);
    for (const s in t.attrs) e.setAttribute(FS.has(s) ? s : Yh(s), t.attrs[s]);
  }
  const El = {};
  function b2(e) {
    Object.assign(El, e);
  }
  function BS(e, { layout: t, layoutId: n }) {
    return es.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!El[e] || e === "opacity");
  }
  function ap(e, t, n) {
    var r;
    const { style: s } = e, i = {};
    for (const o in s) (et(s[o]) || t.style && et(t.style[o]) || BS(o, e) || ((r = n?.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (i[o] = s[o]);
    return i;
  }
  function US(e, t, n) {
    const r = ap(e, t, n);
    for (const s in e) if (et(e[s]) || et(t[s])) {
      const i = ci.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
      r[i] = e[s];
    }
    return r;
  }
  function T2(e, t) {
    try {
      t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
    } catch {
      t.dimensions = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
  }
  const zg = [
    "x",
    "y",
    "width",
    "height",
    "cx",
    "cy",
    "r"
  ], C2 = {
    useVisualState: MS({
      scrapeMotionValuesFromProps: US,
      createRenderState: jS,
      onUpdate: ({ props: e, prevProps: t, current: n, renderState: r, latestValues: s }) => {
        if (!n) return;
        let i = !!e.drag;
        if (!i) {
          for (const a in s) if (es.has(a)) {
            i = true;
            break;
          }
        }
        if (!i) return;
        let o = !t;
        if (t) for (let a = 0; a < zg.length; a++) {
          const l = zg[a];
          e[l] !== t[l] && (o = true);
        }
        o && ge.read(() => {
          T2(n, r), ge.render(() => {
            sp(r, s, op(n.tagName), e.transformTemplate), zS(n, r);
          });
        });
      }
    })
  }, E2 = {
    useVisualState: MS({
      scrapeMotionValuesFromProps: ap,
      createRenderState: ip
    })
  };
  function $S(e, t, n) {
    for (const r in t) !et(t[r]) && !BS(r, n) && (e[r] = t[r]);
  }
  function P2({ transformTemplate: e }, t) {
    return h.useMemo(() => {
      const n = ip();
      return rp(n, t, e), Object.assign({}, n.vars, n.style);
    }, [
      t
    ]);
  }
  function k2(e, t) {
    const n = e.style || {}, r = {};
    return $S(r, n, e), Object.assign(r, P2(e, t)), r;
  }
  function _2(e, t) {
    const n = {}, r = k2(e, t);
    return e.drag && e.dragListener !== false && (n.draggable = false, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === true ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
  }
  function A2(e, t, n, r) {
    const s = h.useMemo(() => {
      const i = jS();
      return sp(i, t, op(r), e.transformTemplate), {
        ...i.attrs,
        style: {
          ...i.style
        }
      };
    }, [
      t
    ]);
    if (e.style) {
      const i = {};
      $S(i, e.style, e), s.style = {
        ...i,
        ...s.style
      };
    }
    return s;
  }
  function R2(e = false) {
    return (n, r, s, { latestValues: i }, o) => {
      const l = (Jh(n) ? A2 : _2)(r, i, o, n), u = HN(r, typeof n == "string", e), c = n !== h.Fragment ? {
        ...u,
        ...l,
        ref: s
      } : {}, { children: d } = r, f = h.useMemo(() => et(d) ? d.get() : d, [
        d
      ]);
      return h.createElement(n, {
        ...c,
        children: f
      });
    };
  }
  function N2(e, t) {
    return function(r, { forwardMotionProps: s } = {
      forwardMotionProps: false
    }) {
      const o = {
        ...Jh(r) ? C2 : E2,
        preloadedFeatures: e,
        useRender: R2(s),
        createVisualElement: t,
        Component: r
      };
      return e2(o);
    };
  }
  function WS(e, t) {
    if (!Array.isArray(t)) return false;
    const n = t.length;
    if (n !== e.length) return false;
    for (let r = 0; r < n; r++) if (t[r] !== e[r]) return false;
    return true;
  }
  function Su(e, t, n) {
    const r = e.getProps();
    return ep(r, t, n !== void 0 ? n : r.custom, e);
  }
  D2 = Gh(() => window.ScrollTimeline !== void 0);
  class M2 {
    constructor(t) {
      this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
    }
    get finished() {
      return Promise.all(this.animations.map((t) => "finished" in t ? t.finished : t));
    }
    getAll(t) {
      return this.animations[0][t];
    }
    setAll(t, n) {
      for (let r = 0; r < this.animations.length; r++) this.animations[r][t] = n;
    }
    attachTimeline(t, n) {
      const r = this.animations.map((s) => {
        if (D2() && s.attachTimeline) return s.attachTimeline(t);
        if (typeof n == "function") return n(s);
      });
      return () => {
        r.forEach((s, i) => {
          s && s(), this.animations[i].stop();
        });
      };
    }
    get time() {
      return this.getAll("time");
    }
    set time(t) {
      this.setAll("time", t);
    }
    get speed() {
      return this.getAll("speed");
    }
    set speed(t) {
      this.setAll("speed", t);
    }
    get startTime() {
      return this.getAll("startTime");
    }
    get duration() {
      let t = 0;
      for (let n = 0; n < this.animations.length; n++) t = Math.max(t, this.animations[n].duration);
      return t;
    }
    runAll(t) {
      this.animations.forEach((n) => n[t]());
    }
    flatten() {
      this.runAll("flatten");
    }
    play() {
      this.runAll("play");
    }
    pause() {
      this.runAll("pause");
    }
    cancel() {
      this.runAll("cancel");
    }
    complete() {
      this.runAll("complete");
    }
  }
  class O2 extends M2 {
    then(t, n) {
      return Promise.all(this.animations).then(t).catch(n);
    }
  }
  function lp(e, t) {
    return e ? e[t] || e.default || e : void 0;
  }
  const Qd = 2e4;
  function HS(e) {
    let t = 0;
    const n = 50;
    let r = e.next(t);
    for (; !r.done && t < Qd; ) t += n, r = e.next(t);
    return t >= Qd ? 1 / 0 : t;
  }
  function up(e) {
    return typeof e == "function";
  }
  function Bg(e, t) {
    e.timeline = t, e.onfinish = null;
  }
  const cp = (e) => Array.isArray(e) && typeof e[0] == "number", I2 = {
    linearEasing: void 0
  };
  function L2(e, t) {
    const n = Gh(e);
    return () => {
      var r;
      return (r = I2[t]) !== null && r !== void 0 ? r : n();
    };
  }
  const Pl = L2(() => {
    try {
      document.createElement("div").animate({
        opacity: 0
      }, {
        easing: "linear(0, 1)"
      });
    } catch {
      return false;
    }
    return true;
  }, "linearEasing"), KS = (e, t, n = 10) => {
    let r = "";
    const s = Math.max(Math.round(t / n), 2);
    for (let i = 0; i < s; i++) r += e(Gs(0, s - 1, i)) + ", ";
    return `linear(${r.substring(0, r.length - 2)})`;
  };
  function QS(e) {
    return !!(typeof e == "function" && Pl() || !e || typeof e == "string" && (e in Gd || Pl()) || cp(e) || Array.isArray(e) && e.every(QS));
  }
  const Ri = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Gd = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Ri([
      0,
      0.65,
      0.55,
      1
    ]),
    circOut: Ri([
      0.55,
      0,
      1,
      0.45
    ]),
    backIn: Ri([
      0.31,
      0.01,
      0.66,
      -0.59
    ]),
    backOut: Ri([
      0.33,
      1.53,
      0.69,
      0.99
    ])
  };
  function GS(e, t) {
    if (e) return typeof e == "function" && Pl() ? KS(e, t) : cp(e) ? Ri(e) : Array.isArray(e) ? e.map((n) => GS(n, t) || Gd.easeOut) : Gd[e];
  }
  const Bt = {
    x: false,
    y: false
  };
  function qS() {
    return Bt.x || Bt.y;
  }
  j2 = function(e, t, n) {
    var r;
    if (e instanceof Element) return [
      e
    ];
    if (typeof e == "string") {
      let s = document;
      const i = (r = void 0) !== null && r !== void 0 ? r : s.querySelectorAll(e);
      return i ? Array.from(i) : [];
    }
    return Array.from(e);
  };
  function ZS(e, t) {
    const n = j2(e), r = new AbortController(), s = {
      passive: true,
      ...t,
      signal: r.signal
    };
    return [
      n,
      s,
      () => r.abort()
    ];
  }
  function Ug(e) {
    return (t) => {
      t.pointerType === "touch" || qS() || e(t);
    };
  }
  function V2(e, t, n = {}) {
    const [r, s, i] = ZS(e, n), o = Ug((a) => {
      const { target: l } = a, u = t(a);
      if (typeof u != "function" || !l) return;
      const c = Ug((d) => {
        u(d), l.removeEventListener("pointerleave", c);
      });
      l.addEventListener("pointerleave", c, s);
    });
    return r.forEach((a) => {
      a.addEventListener("pointerenter", o, s);
    }), i;
  }
  const YS = (e, t) => t ? e === t ? true : YS(e, t.parentElement) : false, dp = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== false, F2 = /* @__PURE__ */ new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function z2(e) {
    return F2.has(e.tagName) || e.tabIndex !== -1;
  }
  const Ni = /* @__PURE__ */ new WeakSet();
  function $g(e) {
    return (t) => {
      t.key === "Enter" && e(t);
    };
  }
  function pc(e, t) {
    e.dispatchEvent(new PointerEvent("pointer" + t, {
      isPrimary: true,
      bubbles: true
    }));
  }
  const B2 = (e, t) => {
    const n = e.currentTarget;
    if (!n) return;
    const r = $g(() => {
      if (Ni.has(n)) return;
      pc(n, "down");
      const s = $g(() => {
        pc(n, "up");
      }), i = () => pc(n, "cancel");
      n.addEventListener("keyup", s, t), n.addEventListener("blur", i, t);
    });
    n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
  };
  function Wg(e) {
    return dp(e) && !qS();
  }
  function U2(e, t, n = {}) {
    const [r, s, i] = ZS(e, n), o = (a) => {
      const l = a.currentTarget;
      if (!Wg(a) || Ni.has(l)) return;
      Ni.add(l);
      const u = t(a), c = (p, w) => {
        window.removeEventListener("pointerup", d), window.removeEventListener("pointercancel", f), !(!Wg(p) || !Ni.has(l)) && (Ni.delete(l), typeof u == "function" && u(p, {
          success: w
        }));
      }, d = (p) => {
        c(p, n.useGlobalTarget || YS(l, p.target));
      }, f = (p) => {
        c(p, false);
      };
      window.addEventListener("pointerup", d, s), window.addEventListener("pointercancel", f, s);
    };
    return r.forEach((a) => {
      !z2(a) && a.getAttribute("tabindex") === null && (a.tabIndex = 0), (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), a.addEventListener("focus", (u) => B2(u, s), s);
    }), i;
  }
  function $2(e) {
    return e === "x" || e === "y" ? Bt[e] ? null : (Bt[e] = true, () => {
      Bt[e] = false;
    }) : Bt.x || Bt.y ? null : (Bt.x = Bt.y = true, () => {
      Bt.x = Bt.y = false;
    });
  }
  const XS = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...ci
  ]);
  let $a;
  function W2() {
    $a = void 0;
  }
  const hn = {
    now: () => ($a === void 0 && hn.set(Ke.isProcessing || FN.useManualTiming ? Ke.timestamp : performance.now()), $a),
    set: (e) => {
      $a = e, queueMicrotask(W2);
    }
  };
  function fp(e, t) {
    e.indexOf(t) === -1 && e.push(t);
  }
  function hp(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1);
  }
  class pp {
    constructor() {
      this.subscriptions = [];
    }
    add(t) {
      return fp(this.subscriptions, t), () => hp(this.subscriptions, t);
    }
    notify(t, n, r) {
      const s = this.subscriptions.length;
      if (s) if (s === 1) this.subscriptions[0](t, n, r);
      else for (let i = 0; i < s; i++) {
        const o = this.subscriptions[i];
        o && o(t, n, r);
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  JS = function(e, t) {
    return t ? e * (1e3 / t) : 0;
  };
  let Hg, H2;
  Hg = 30;
  H2 = (e) => !isNaN(parseFloat(e));
  Kg = {
    current: void 0
  };
  class K2 {
    constructor(t, n = {}) {
      this.version = "11.18.2", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, s = true) => {
        const i = hn.now();
        this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), s && this.events.renderRequest && this.events.renderRequest.notify(this.current);
      }, this.hasAnimated = false, this.setCurrent(t), this.owner = n.owner;
    }
    setCurrent(t) {
      this.current = t, this.updatedAt = hn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = H2(this.current));
    }
    setPrevFrameValue(t = this.current) {
      this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
    }
    onChange(t) {
      return this.on("change", t);
    }
    on(t, n) {
      this.events[t] || (this.events[t] = new pp());
      const r = this.events[t].add(n);
      return t === "change" ? () => {
        r(), ge.read(() => {
          this.events.change.getSize() || this.stop();
        });
      } : r;
    }
    clearListeners() {
      for (const t in this.events) this.events[t].clear();
    }
    attach(t, n) {
      this.passiveEffect = t, this.stopPassiveEffect = n;
    }
    set(t, n = true) {
      !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
    }
    setWithVelocity(t, n, r) {
      this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
    }
    jump(t, n = true) {
      this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
    }
    get() {
      return Kg.current && Kg.current.push(this), this.current;
    }
    getPrevious() {
      return this.prev;
    }
    getVelocity() {
      const t = hn.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Hg) return 0;
      const n = Math.min(this.updatedAt - this.prevUpdatedAt, Hg);
      return JS(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
    }
    start(t) {
      return this.stop(), new Promise((n) => {
        this.hasAnimated = true, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
      });
    }
    stop() {
      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
    }
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    destroy() {
      this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
    }
  }
  mo = function(e, t) {
    return new K2(e, t);
  };
  function Q2(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, mo(n));
  }
  function G2(e, t) {
    const n = Su(e, t);
    let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {};
    i = {
      ...i,
      ...r
    };
    for (const o in i) {
      const a = o2(i[o]);
      Q2(e, o, a);
    }
  }
  function q2(e) {
    return !!(et(e) && e.add);
  }
  function qd(e, t) {
    const n = e.getValue("willChange");
    if (q2(n)) return n.add(t);
  }
  function e1(e) {
    return e.props[RS];
  }
  const t1 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, Z2 = 1e-7, Y2 = 12;
  function X2(e, t, n, r, s) {
    let i, o, a = 0;
    do
      o = t + (n - t) / 2, i = t1(o, r, s) - e, i > 0 ? n = o : t = o;
    while (Math.abs(i) > Z2 && ++a < Y2);
    return o;
  }
  function Wo(e, t, n, r) {
    if (e === t && n === r) return vt;
    const s = (i) => X2(i, 0, 1, e, n);
    return (i) => i === 0 || i === 1 ? i : t1(s(i), t, r);
  }
  const n1 = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, r1 = (e) => (t) => 1 - e(1 - t), s1 = Wo(0.33, 1.53, 0.69, 0.99), mp = r1(s1), i1 = n1(mp), o1 = (e) => (e *= 2) < 1 ? 0.5 * mp(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), gp = (e) => 1 - Math.sin(Math.acos(e)), a1 = r1(gp), l1 = n1(gp), u1 = (e) => /^0[^.\s]+$/u.test(e);
  function J2(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || u1(e) : true;
  }
  const $i = (e) => Math.round(e * 1e5) / 1e5, yp = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function eD(e) {
    return e == null;
  }
  const tD = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, vp = (e, t) => (n) => !!(typeof n == "string" && tD.test(n) && n.startsWith(e) || t && !eD(n) && Object.prototype.hasOwnProperty.call(n, t)), c1 = (e, t, n) => (r) => {
    if (typeof r != "string") return r;
    const [s, i, o, a] = r.match(yp);
    return {
      [e]: parseFloat(s),
      [t]: parseFloat(i),
      [n]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1
    };
  }, nD = (e) => zn(0, 255, e), mc = {
    ...di,
    transform: (e) => Math.round(nD(e))
  }, Or = {
    test: vp("rgb", "red"),
    parse: c1("red", "green", "blue"),
    transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + mc.transform(e) + ", " + mc.transform(t) + ", " + mc.transform(n) + ", " + $i(po.transform(r)) + ")"
  };
  function rD(e) {
    let t = "", n = "", r = "", s = "";
    return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), s = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), s = e.substring(4, 5), t += t, n += n, r += r, s += s), {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: s ? parseInt(s, 16) / 255 : 1
    };
  }
  const Zd = {
    test: vp("#"),
    parse: rD,
    transform: Or.transform
  }, ws = {
    test: vp("hsl", "hue"),
    parse: c1("hue", "saturation", "lightness"),
    transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + fn.transform($i(t)) + ", " + fn.transform($i(n)) + ", " + $i(po.transform(r)) + ")"
  }, Xe = {
    test: (e) => Or.test(e) || Zd.test(e) || ws.test(e),
    parse: (e) => Or.test(e) ? Or.parse(e) : ws.test(e) ? ws.parse(e) : Zd.parse(e),
    transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Or.transform(e) : ws.transform(e)
  }, sD = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function iD(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(yp)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(sD)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
  }
  const d1 = "number", f1 = "color", oD = "var", aD = "var(", Qg = "${}", lD = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function go(e) {
    const t = e.toString(), n = [], r = {
      color: [],
      number: [],
      var: []
    }, s = [];
    let i = 0;
    const a = t.replace(lD, (l) => (Xe.test(l) ? (r.color.push(i), s.push(f1), n.push(Xe.parse(l))) : l.startsWith(aD) ? (r.var.push(i), s.push(oD), n.push(l)) : (r.number.push(i), s.push(d1), n.push(parseFloat(l))), ++i, Qg)).split(Qg);
    return {
      values: n,
      split: a,
      indexes: r,
      types: s
    };
  }
  function h1(e) {
    return go(e).values;
  }
  function p1(e) {
    const { split: t, types: n } = go(e), r = t.length;
    return (s) => {
      let i = "";
      for (let o = 0; o < r; o++) if (i += t[o], s[o] !== void 0) {
        const a = n[o];
        a === d1 ? i += $i(s[o]) : a === f1 ? i += Xe.transform(s[o]) : i += s[o];
      }
      return i;
    };
  }
  const uD = (e) => typeof e == "number" ? 0 : e;
  function cD(e) {
    const t = h1(e);
    return p1(e)(t.map(uD));
  }
  const mr = {
    test: iD,
    parse: h1,
    createTransformer: p1,
    getAnimatableNone: cD
  }, dD = /* @__PURE__ */ new Set([
    "brightness",
    "contrast",
    "saturate",
    "opacity"
  ]);
  function fD(e) {
    const [t, n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow") return e;
    const [r] = n.match(yp) || [];
    if (!r) return e;
    const s = n.replace(r, "");
    let i = dD.has(t) ? 1 : 0;
    return r !== n && (i *= 100), t + "(" + i + s + ")";
  }
  const hD = /\b([a-z-]*)\(.*?\)/gu, Yd = {
    ...mr,
    getAnimatableNone: (e) => {
      const t = e.match(hD);
      return t ? t.map(fD).join(" ") : e;
    }
  }, pD = {
    ...np,
    color: Xe,
    backgroundColor: Xe,
    outlineColor: Xe,
    fill: Xe,
    stroke: Xe,
    borderColor: Xe,
    borderTopColor: Xe,
    borderRightColor: Xe,
    borderBottomColor: Xe,
    borderLeftColor: Xe,
    filter: Yd,
    WebkitFilter: Yd
  }, wp = (e) => pD[e];
  function m1(e, t) {
    let n = wp(e);
    return n !== Yd && (n = mr), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
  }
  const mD = /* @__PURE__ */ new Set([
    "auto",
    "none",
    "0"
  ]);
  function gD(e, t, n) {
    let r = 0, s;
    for (; r < e.length && !s; ) {
      const i = e[r];
      typeof i == "string" && !mD.has(i) && go(i).values.length && (s = e[r]), r++;
    }
    if (s && n) for (const i of t) e[i] = m1(n, s);
  }
  const Gg = (e) => e === di || e === H, qg = (e, t) => parseFloat(e.split(", ")[t]), Zg = (e, t) => (n, { transform: r }) => {
    if (r === "none" || !r) return 0;
    const s = r.match(/^matrix3d\((.+)\)$/u);
    if (s) return qg(s[1], t);
    {
      const i = r.match(/^matrix\((.+)\)$/u);
      return i ? qg(i[1], e) : 0;
    }
  }, yD = /* @__PURE__ */ new Set([
    "x",
    "y",
    "z"
  ]), vD = ci.filter((e) => !yD.has(e));
  function wD(e) {
    const t = [];
    return vD.forEach((n) => {
      const r = e.getValue(n);
      r !== void 0 && (t.push([
        n,
        r.get()
      ]), r.set(n.startsWith("scale") ? 1 : 0));
    }), t;
  }
  const Zs = {
    width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, { top: t }) => parseFloat(t),
    left: (e, { left: t }) => parseFloat(t),
    bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
    right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
    x: Zg(4, 13),
    y: Zg(5, 14)
  };
  Zs.translateX = Zs.x;
  Zs.translateY = Zs.y;
  const jr = /* @__PURE__ */ new Set();
  let Xd = false, Jd = false;
  function g1() {
    if (Jd) {
      const e = Array.from(jr).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
      t.forEach((r) => {
        const s = wD(r);
        s.length && (n.set(r, s), r.render());
      }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
        r.render();
        const s = n.get(r);
        s && s.forEach(([i, o]) => {
          var a;
          (a = r.getValue(i)) === null || a === void 0 || a.set(o);
        });
      }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
      });
    }
    Jd = false, Xd = false, jr.forEach((e) => e.complete()), jr.clear();
  }
  function y1() {
    jr.forEach((e) => {
      e.readKeyframes(), e.needsMeasurement && (Jd = true);
    });
  }
  function xD() {
    y1(), g1();
  }
  class xp {
    constructor(t, n, r, s, i, o = false) {
      this.isComplete = false, this.isAsync = false, this.needsMeasurement = false, this.isScheduled = false, this.unresolvedKeyframes = [
        ...t
      ], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o;
    }
    scheduleResolve() {
      this.isScheduled = true, this.isAsync ? (jr.add(this), Xd || (Xd = true, ge.read(y1), ge.resolveKeyframes(g1))) : (this.readKeyframes(), this.complete());
    }
    readKeyframes() {
      const { unresolvedKeyframes: t, name: n, element: r, motionValue: s } = this;
      for (let i = 0; i < t.length; i++) if (t[i] === null) if (i === 0) {
        const o = s?.get(), a = t[t.length - 1];
        if (o !== void 0) t[0] = o;
        else if (r && n) {
          const l = r.readValue(n, a);
          l != null && (t[0] = l);
        }
        t[0] === void 0 && (t[0] = a), s && o === void 0 && s.set(t[0]);
      } else t[i] = t[i - 1];
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete() {
      this.isComplete = true, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), jr.delete(this);
    }
    cancel() {
      this.isComplete || (this.isScheduled = false, jr.delete(this));
    }
    resume() {
      this.isComplete || this.scheduleResolve();
    }
  }
  const v1 = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), SD = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
  function bD(e) {
    const t = SD.exec(e);
    if (!t) return [
      ,
    ];
    const [, n, r, s] = t;
    return [
      `--${n ?? r}`,
      s
    ];
  }
  function w1(e, t, n = 1) {
    const [r, s] = bD(e);
    if (!r) return;
    const i = window.getComputedStyle(t).getPropertyValue(r);
    if (i) {
      const o = i.trim();
      return v1(o) ? parseFloat(o) : o;
    }
    return tp(s) ? w1(s, t, n + 1) : s;
  }
  const x1 = (e) => (t) => t.test(e), TD = {
    test: (e) => e === "auto",
    parse: (e) => e
  }, S1 = [
    di,
    H,
    fn,
    Qn,
    f2,
    d2,
    TD
  ], Yg = (e) => S1.find(x1(e));
  class b1 extends xp {
    constructor(t, n, r, s, i) {
      super(t, n, r, s, i, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes: t, element: n, name: r } = this;
      if (!n || !n.current) return;
      super.readKeyframes();
      for (let l = 0; l < t.length; l++) {
        let u = t[l];
        if (typeof u == "string" && (u = u.trim(), tp(u))) {
          const c = w1(u, n.current);
          c !== void 0 && (t[l] = c), l === t.length - 1 && (this.finalKeyframe = u);
        }
      }
      if (this.resolveNoneKeyframes(), !XS.has(r) || t.length !== 2) return;
      const [s, i] = t, o = Yg(s), a = Yg(i);
      if (o !== a) if (Gg(o) && Gg(a)) for (let l = 0; l < t.length; l++) {
        const u = t[l];
        typeof u == "string" && (t[l] = parseFloat(u));
      }
      else this.needsMeasurement = true;
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes: t, name: n } = this, r = [];
      for (let s = 0; s < t.length; s++) J2(t[s]) && r.push(s);
      r.length && gD(t, r, n);
    }
    measureInitialState() {
      const { element: t, unresolvedKeyframes: n, name: r } = this;
      if (!t || !t.current) return;
      r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Zs[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
      const s = n[n.length - 1];
      s !== void 0 && t.getValue(r, s).jump(s, false);
    }
    measureEndState() {
      var t;
      const { element: n, name: r, unresolvedKeyframes: s } = this;
      if (!n || !n.current) return;
      const i = n.getValue(r);
      i && i.jump(this.measuredOrigin, false);
      const o = s.length - 1, a = s[o];
      s[o] = Zs[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, u]) => {
        n.getValue(l).set(u);
      }), this.resolveNoneKeyframes();
    }
  }
  const Xg = (e, t) => t === "zIndex" ? false : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (mr.test(e) || e === "0") && !e.startsWith("url("));
  function CD(e) {
    const t = e[0];
    if (e.length === 1) return true;
    for (let n = 0; n < e.length; n++) if (e[n] !== t) return true;
  }
  function ED(e, t, n, r) {
    const s = e[0];
    if (s === null) return false;
    if (t === "display" || t === "visibility") return true;
    const i = e[e.length - 1], o = Xg(s, t), a = Xg(i, t);
    return !o || !a ? false : CD(e) || (n === "spring" || up(n)) && r;
  }
  const PD = (e) => e !== null;
  function bu(e, { repeat: t, repeatType: n = "loop" }, r) {
    const s = e.filter(PD), i = t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
    return !i || r === void 0 ? s[i] : r;
  }
  const kD = 40;
  class T1 {
    constructor({ autoplay: t = true, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", ...a }) {
      this.isStopped = false, this.hasAttemptedResolve = false, this.createdAt = hn.now(), this.options = {
        autoplay: t,
        delay: n,
        type: r,
        repeat: s,
        repeatDelay: i,
        repeatType: o,
        ...a
      }, this.updateFinishedPromise();
    }
    calcStartTime() {
      return this.resolvedAt ? this.resolvedAt - this.createdAt > kD ? this.resolvedAt : this.createdAt : this.createdAt;
    }
    get resolved() {
      return !this._resolved && !this.hasAttemptedResolve && xD(), this._resolved;
    }
    onKeyframesResolved(t, n) {
      this.resolvedAt = hn.now(), this.hasAttemptedResolve = true;
      const { name: r, type: s, velocity: i, delay: o, onComplete: a, onUpdate: l, isGenerator: u } = this.options;
      if (!u && !ED(t, r, s, i)) if (o) this.options.duration = 0;
      else {
        l && l(bu(t, this.options, n)), a && a(), this.resolveFinishedPromise();
        return;
      }
      const c = this.initPlayback(t, n);
      c !== false && (this._resolved = {
        keyframes: t,
        finalKeyframe: n,
        ...c
      }, this.onPostResolved());
    }
    onPostResolved() {
    }
    then(t, n) {
      return this.currentFinishedPromise.then(t, n);
    }
    flatten() {
      this.options.type = "keyframes", this.options.ease = "linear";
    }
    updateFinishedPromise() {
      this.currentFinishedPromise = new Promise((t) => {
        this.resolveFinishedPromise = t;
      });
    }
  }
  const be = (e, t, n) => e + (t - e) * n;
  function gc(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
  }
  function _D({ hue: e, saturation: t, lightness: n, alpha: r }) {
    e /= 360, t /= 100, n /= 100;
    let s = 0, i = 0, o = 0;
    if (!t) s = i = o = n;
    else {
      const a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
      s = gc(l, a, e + 1 / 3), i = gc(l, a, e), o = gc(l, a, e - 1 / 3);
    }
    return {
      red: Math.round(s * 255),
      green: Math.round(i * 255),
      blue: Math.round(o * 255),
      alpha: r
    };
  }
  function kl(e, t) {
    return (n) => n > 0 ? t : e;
  }
  const yc = (e, t, n) => {
    const r = e * e, s = n * (t * t - r) + r;
    return s < 0 ? 0 : Math.sqrt(s);
  }, AD = [
    Zd,
    Or,
    ws
  ], RD = (e) => AD.find((t) => t.test(e));
  function Jg(e) {
    const t = RD(e);
    if (!t) return false;
    let n = t.parse(e);
    return t === ws && (n = _D(n)), n;
  }
  const ey = (e, t) => {
    const n = Jg(e), r = Jg(t);
    if (!n || !r) return kl(e, t);
    const s = {
      ...n
    };
    return (i) => (s.red = yc(n.red, r.red, i), s.green = yc(n.green, r.green, i), s.blue = yc(n.blue, r.blue, i), s.alpha = be(n.alpha, r.alpha, i), Or.transform(s));
  }, ND = (e, t) => (n) => t(e(n)), Ho = (...e) => e.reduce(ND), ef = /* @__PURE__ */ new Set([
    "none",
    "hidden"
  ]);
  function DD(e, t) {
    return ef.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
  }
  function MD(e, t) {
    return (n) => be(e, t, n);
  }
  function Sp(e) {
    return typeof e == "number" ? MD : typeof e == "string" ? tp(e) ? kl : Xe.test(e) ? ey : LD : Array.isArray(e) ? C1 : typeof e == "object" ? Xe.test(e) ? ey : OD : kl;
  }
  function C1(e, t) {
    const n = [
      ...e
    ], r = n.length, s = e.map((i, o) => Sp(i)(i, t[o]));
    return (i) => {
      for (let o = 0; o < r; o++) n[o] = s[o](i);
      return n;
    };
  }
  function OD(e, t) {
    const n = {
      ...e,
      ...t
    }, r = {};
    for (const s in n) e[s] !== void 0 && t[s] !== void 0 && (r[s] = Sp(e[s])(e[s], t[s]));
    return (s) => {
      for (const i in r) n[i] = r[i](s);
      return n;
    };
  }
  function ID(e, t) {
    var n;
    const r = [], s = {
      color: 0,
      var: 0,
      number: 0
    };
    for (let i = 0; i < t.values.length; i++) {
      const o = t.types[i], a = e.indexes[o][s[o]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0;
      r[i] = l, s[o]++;
    }
    return r;
  }
  const LD = (e, t) => {
    const n = mr.createTransformer(t), r = go(e), s = go(t);
    return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? ef.has(e) && !s.values.length || ef.has(t) && !r.values.length ? DD(e, t) : Ho(C1(ID(r, s), s.values), n) : kl(e, t);
  };
  function E1(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? be(e, t, n) : Sp(e)(e, t);
  }
  const jD = 5;
  function P1(e, t, n) {
    const r = Math.max(t - jD, 0);
    return JS(n - e(r), t - r);
  }
  const ke = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1
  }, vc = 1e-3;
  function VD({ duration: e = ke.duration, bounce: t = ke.bounce, velocity: n = ke.velocity, mass: r = ke.mass }) {
    let s, i, o = 1 - t;
    o = zn(ke.minDamping, ke.maxDamping, o), e = zn(ke.minDuration, ke.maxDuration, Dn(e)), o < 1 ? (s = (u) => {
      const c = u * o, d = c * e, f = c - n, p = tf(u, o), w = Math.exp(-d);
      return vc - f / p * w;
    }, i = (u) => {
      const d = u * o * e, f = d * n + n, p = Math.pow(o, 2) * Math.pow(u, 2) * e, w = Math.exp(-d), g = tf(Math.pow(u, 2), o);
      return (-s(u) + vc > 0 ? -1 : 1) * ((f - p) * w) / g;
    }) : (s = (u) => {
      const c = Math.exp(-u * e), d = (u - n) * e + 1;
      return -vc + c * d;
    }, i = (u) => {
      const c = Math.exp(-u * e), d = (n - u) * (e * e);
      return c * d;
    });
    const a = 5 / e, l = zD(s, i, a);
    if (e = Nn(e), isNaN(l)) return {
      stiffness: ke.stiffness,
      damping: ke.damping,
      duration: e
    };
    {
      const u = Math.pow(l, 2) * r;
      return {
        stiffness: u,
        damping: o * 2 * Math.sqrt(r * u),
        duration: e
      };
    }
  }
  const FD = 12;
  function zD(e, t, n) {
    let r = n;
    for (let s = 1; s < FD; s++) r = r - e(r) / t(r);
    return r;
  }
  function tf(e, t) {
    return e * Math.sqrt(1 - t * t);
  }
  const BD = [
    "duration",
    "bounce"
  ], UD = [
    "stiffness",
    "damping",
    "mass"
  ];
  function ty(e, t) {
    return t.some((n) => e[n] !== void 0);
  }
  function $D(e) {
    let t = {
      velocity: ke.velocity,
      stiffness: ke.stiffness,
      damping: ke.damping,
      mass: ke.mass,
      isResolvedFromDuration: false,
      ...e
    };
    if (!ty(e, UD) && ty(e, BD)) if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), s = r * r, i = 2 * zn(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(s);
      t = {
        ...t,
        mass: ke.mass,
        stiffness: s,
        damping: i
      };
    } else {
      const n = VD(e);
      t = {
        ...t,
        ...n,
        mass: ke.mass
      }, t.isResolvedFromDuration = true;
    }
    return t;
  }
  function k1(e = ke.visualDuration, t = ke.bounce) {
    const n = typeof e != "object" ? {
      visualDuration: e,
      keyframes: [
        0,
        1
      ],
      bounce: t
    } : e;
    let { restSpeed: r, restDelta: s } = n;
    const i = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = {
      done: false,
      value: i
    }, { stiffness: l, damping: u, mass: c, duration: d, velocity: f, isResolvedFromDuration: p } = $D({
      ...n,
      velocity: -Dn(n.velocity || 0)
    }), w = f || 0, g = u / (2 * Math.sqrt(l * c)), x = o - i, m = Dn(Math.sqrt(l / c)), y = Math.abs(x) < 5;
    r || (r = y ? ke.restSpeed.granular : ke.restSpeed.default), s || (s = y ? ke.restDelta.granular : ke.restDelta.default);
    let v;
    if (g < 1) {
      const T = tf(m, g);
      v = (C) => {
        const E = Math.exp(-g * m * C);
        return o - E * ((w + g * m * x) / T * Math.sin(T * C) + x * Math.cos(T * C));
      };
    } else if (g === 1) v = (T) => o - Math.exp(-m * T) * (x + (w + m * x) * T);
    else {
      const T = m * Math.sqrt(g * g - 1);
      v = (C) => {
        const E = Math.exp(-g * m * C), P = Math.min(T * C, 300);
        return o - E * ((w + g * m * x) * Math.sinh(P) + T * x * Math.cosh(P)) / T;
      };
    }
    const b = {
      calculatedDuration: p && d || null,
      next: (T) => {
        const C = v(T);
        if (p) a.done = T >= d;
        else {
          let E = 0;
          g < 1 && (E = T === 0 ? Nn(w) : P1(v, T, C));
          const P = Math.abs(E) <= r, D = Math.abs(o - C) <= s;
          a.done = P && D;
        }
        return a.value = a.done ? o : C, a;
      },
      toString: () => {
        const T = Math.min(HS(b), Qd), C = KS((E) => b.next(T * E).value, T, 30);
        return T + "ms " + C;
      }
    };
    return b;
  }
  function ny({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: u = 0.5, restSpeed: c }) {
    const d = e[0], f = {
      done: false,
      value: d
    }, p = (P) => a !== void 0 && P < a || l !== void 0 && P > l, w = (P) => a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l;
    let g = n * t;
    const x = d + g, m = o === void 0 ? x : o(x);
    m !== x && (g = m - d);
    const y = (P) => -g * Math.exp(-P / r), v = (P) => m + y(P), b = (P) => {
      const D = y(P), A = v(P);
      f.done = Math.abs(D) <= u, f.value = f.done ? m : A;
    };
    let T, C;
    const E = (P) => {
      p(f.value) && (T = P, C = k1({
        keyframes: [
          f.value,
          w(f.value)
        ],
        velocity: P1(v, P, f.value),
        damping: s,
        stiffness: i,
        restDelta: u,
        restSpeed: c
      }));
    };
    return E(0), {
      calculatedDuration: null,
      next: (P) => {
        let D = false;
        return !C && T === void 0 && (D = true, b(P), E(P)), T !== void 0 && P >= T ? C.next(P - T) : (!D && b(P), f);
      }
    };
  }
  const WD = Wo(0.42, 0, 1, 1), HD = Wo(0, 0, 0.58, 1), _1 = Wo(0.42, 0, 0.58, 1), KD = (e) => Array.isArray(e) && typeof e[0] != "number", QD = {
    linear: vt,
    easeIn: WD,
    easeInOut: _1,
    easeOut: HD,
    circIn: gp,
    circInOut: l1,
    circOut: a1,
    backIn: mp,
    backInOut: i1,
    backOut: s1,
    anticipate: o1
  }, ry = (e) => {
    if (cp(e)) {
      ES(e.length === 4);
      const [t, n, r, s] = e;
      return Wo(t, n, r, s);
    } else if (typeof e == "string") return QD[e];
    return e;
  };
  function GD(e, t, n) {
    const r = [], s = n || E1, i = e.length - 1;
    for (let o = 0; o < i; o++) {
      let a = s(e[o], e[o + 1]);
      if (t) {
        const l = Array.isArray(t) ? t[o] || vt : t;
        a = Ho(l, a);
      }
      r.push(a);
    }
    return r;
  }
  qD = function(e, t, { clamp: n = true, ease: r, mixer: s } = {}) {
    const i = e.length;
    if (ES(i === t.length), i === 1) return () => t[0];
    if (i === 2 && t[0] === t[1]) return () => t[1];
    const o = e[0] === e[1];
    e[0] > e[i - 1] && (e = [
      ...e
    ].reverse(), t = [
      ...t
    ].reverse());
    const a = GD(t, r, s), l = a.length, u = (c) => {
      if (o && c < e[0]) return t[0];
      let d = 0;
      if (l > 1) for (; d < e.length - 2 && !(c < e[d + 1]); d++) ;
      const f = Gs(e[d], e[d + 1], c);
      return a[d](f);
    };
    return n ? (c) => u(zn(e[0], e[i - 1], c)) : u;
  };
  function ZD(e, t) {
    const n = e[e.length - 1];
    for (let r = 1; r <= t; r++) {
      const s = Gs(0, t, r);
      e.push(be(n, 1, s));
    }
  }
  YD = function(e) {
    const t = [
      0
    ];
    return ZD(t, e.length - 1), t;
  };
  function XD(e, t) {
    return e.map((n) => n * t);
  }
  function JD(e, t) {
    return e.map(() => t || _1).splice(0, e.length - 1);
  }
  function _l({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
    const s = KD(r) ? r.map(ry) : ry(r), i = {
      done: false,
      value: t[0]
    }, o = XD(n && n.length === t.length ? n : YD(t), e), a = qD(o, t, {
      ease: Array.isArray(s) ? s : JD(t, s)
    });
    return {
      calculatedDuration: e,
      next: (l) => (i.value = a(l), i.done = l >= e, i)
    };
  }
  const eM = (e) => {
    const t = ({ timestamp: n }) => e(n);
    return {
      start: () => ge.update(t, true),
      stop: () => pr(t),
      now: () => Ke.isProcessing ? Ke.timestamp : hn.now()
    };
  }, tM = {
    decay: ny,
    inertia: ny,
    tween: _l,
    keyframes: _l,
    spring: k1
  }, nM = (e) => e / 100;
  class bp extends T1 {
    constructor(t) {
      super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
        if (this.resolver.cancel(), this.isStopped = true, this.state === "idle") return;
        this.teardown();
        const { onStop: l } = this.options;
        l && l();
      };
      const { name: n, motionValue: r, element: s, keyframes: i } = this.options, o = s?.KeyframeResolver || xp, a = (l, u) => this.onKeyframesResolved(l, u);
      this.resolver = new o(i, a, n, r, s), this.resolver.scheduleResolve();
    }
    flatten() {
      super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
    initPlayback(t) {
      const { type: n = "keyframes", repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = this.options, a = up(n) ? n : tM[n] || _l;
      let l, u;
      a !== _l && typeof t[0] != "number" && (l = Ho(nM, E1(t[0], t[1])), t = [
        0,
        100
      ]);
      const c = a({
        ...this.options,
        keyframes: t
      });
      i === "mirror" && (u = a({
        ...this.options,
        keyframes: [
          ...t
        ].reverse(),
        velocity: -o
      })), c.calculatedDuration === null && (c.calculatedDuration = HS(c));
      const { calculatedDuration: d } = c, f = d + s, p = f * (r + 1) - s;
      return {
        generator: c,
        mirroredGenerator: u,
        mapPercentToKeyframes: l,
        calculatedDuration: d,
        resolvedDuration: f,
        totalDuration: p
      };
    }
    onPostResolved() {
      const { autoplay: t = true } = this.options;
      this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState;
    }
    tick(t, n = false) {
      const { resolved: r } = this;
      if (!r) {
        const { keyframes: P } = this.options;
        return {
          done: true,
          value: P[P.length - 1]
        };
      }
      const { finalKeyframe: s, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: u, totalDuration: c, resolvedDuration: d } = r;
      if (this.startTime === null) return i.next(0);
      const { delay: f, repeat: p, repeatType: w, repeatDelay: g, onUpdate: x } = this.options;
      this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - c / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
      const m = this.currentTime - f * (this.speed >= 0 ? 1 : -1), y = this.speed >= 0 ? m < 0 : m > c;
      this.currentTime = Math.max(m, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c);
      let v = this.currentTime, b = i;
      if (p) {
        const P = Math.min(this.currentTime, c) / d;
        let D = Math.floor(P), A = P % 1;
        !A && P >= 1 && (A = 1), A === 1 && D--, D = Math.min(D, p + 1), !!(D % 2) && (w === "reverse" ? (A = 1 - A, g && (A -= g / d)) : w === "mirror" && (b = o)), v = zn(0, 1, A) * d;
      }
      const T = y ? {
        done: false,
        value: l[0]
      } : b.next(v);
      a && (T.value = a(T.value));
      let { done: C } = T;
      !y && u !== null && (C = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0);
      const E = this.holdTime === null && (this.state === "finished" || this.state === "running" && C);
      return E && s !== void 0 && (T.value = bu(l, this.options, s)), x && x(T.value), E && this.finish(), T;
    }
    get duration() {
      const { resolved: t } = this;
      return t ? Dn(t.calculatedDuration) : 0;
    }
    get time() {
      return Dn(this.currentTime);
    }
    set time(t) {
      t = Nn(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(t) {
      const n = this.playbackSpeed !== t;
      this.playbackSpeed = t, n && (this.time = Dn(this.currentTime));
    }
    play() {
      if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
        this.pendingPlayState = "running";
        return;
      }
      if (this.isStopped) return;
      const { driver: t = eM, onPlay: n, startTime: r } = this.options;
      this.driver || (this.driver = t((i) => this.tick(i))), n && n();
      const s = this.driver.now();
      this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = s) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
    }
    pause() {
      var t;
      if (!this._resolved) {
        this.pendingPlayState = "paused";
        return;
      }
      this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0;
    }
    complete() {
      this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
    }
    finish() {
      this.teardown(), this.state = "finished";
      const { onComplete: t } = this.options;
      t && t();
    }
    cancel() {
      this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
    }
    teardown() {
      this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
    }
    stopDriver() {
      this.driver && (this.driver.stop(), this.driver = void 0);
    }
    sample(t) {
      return this.startTime = 0, this.tick(t, true);
    }
  }
  const rM = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
  ]);
  function sM(e, t, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a = "easeInOut", times: l } = {}) {
    const u = {
      [t]: n
    };
    l && (u.offset = l);
    const c = GS(a, s);
    return Array.isArray(c) && (u.easing = c), e.animate(u, {
      delay: r,
      duration: s,
      easing: Array.isArray(c) ? "linear" : c,
      fill: "both",
      iterations: i + 1,
      direction: o === "reverse" ? "alternate" : "normal"
    });
  }
  const iM = Gh(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Al = 10, oM = 2e4;
  function aM(e) {
    return up(e.type) || e.type === "spring" || !QS(e.ease);
  }
  function lM(e, t) {
    const n = new bp({
      ...t,
      keyframes: e,
      repeat: 0,
      delay: 0,
      isGenerator: true
    });
    let r = {
      done: false,
      value: e[0]
    };
    const s = [];
    let i = 0;
    for (; !r.done && i < oM; ) r = n.sample(i), s.push(r.value), i += Al;
    return {
      times: void 0,
      keyframes: s,
      duration: i - Al,
      ease: "linear"
    };
  }
  const A1 = {
    anticipate: o1,
    backInOut: i1,
    circInOut: l1
  };
  function uM(e) {
    return e in A1;
  }
  class sy extends T1 {
    constructor(t) {
      super(t);
      const { name: n, motionValue: r, element: s, keyframes: i } = this.options;
      this.resolver = new b1(i, (o, a) => this.onKeyframesResolved(o, a), n, r, s), this.resolver.scheduleResolve();
    }
    initPlayback(t, n) {
      let { duration: r = 300, times: s, ease: i, type: o, motionValue: a, name: l, startTime: u } = this.options;
      if (!a.owner || !a.owner.current) return false;
      if (typeof i == "string" && Pl() && uM(i) && (i = A1[i]), aM(this.options)) {
        const { onComplete: d, onUpdate: f, motionValue: p, element: w, ...g } = this.options, x = lM(t, g);
        t = x.keyframes, t.length === 1 && (t[1] = t[0]), r = x.duration, s = x.times, i = x.ease, o = "keyframes";
      }
      const c = sM(a.owner.current, l, t, {
        ...this.options,
        duration: r,
        times: s,
        ease: i
      });
      return c.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (Bg(c, this.pendingTimeline), this.pendingTimeline = void 0) : c.onfinish = () => {
        const { onComplete: d } = this.options;
        a.set(bu(t, this.options, n)), d && d(), this.cancel(), this.resolveFinishedPromise();
      }, {
        animation: c,
        duration: r,
        times: s,
        type: o,
        ease: i,
        keyframes: t
      };
    }
    get duration() {
      const { resolved: t } = this;
      if (!t) return 0;
      const { duration: n } = t;
      return Dn(n);
    }
    get time() {
      const { resolved: t } = this;
      if (!t) return 0;
      const { animation: n } = t;
      return Dn(n.currentTime || 0);
    }
    set time(t) {
      const { resolved: n } = this;
      if (!n) return;
      const { animation: r } = n;
      r.currentTime = Nn(t);
    }
    get speed() {
      const { resolved: t } = this;
      if (!t) return 1;
      const { animation: n } = t;
      return n.playbackRate;
    }
    set speed(t) {
      const { resolved: n } = this;
      if (!n) return;
      const { animation: r } = n;
      r.playbackRate = t;
    }
    get state() {
      const { resolved: t } = this;
      if (!t) return "idle";
      const { animation: n } = t;
      return n.playState;
    }
    get startTime() {
      const { resolved: t } = this;
      if (!t) return null;
      const { animation: n } = t;
      return n.startTime;
    }
    attachTimeline(t) {
      if (!this._resolved) this.pendingTimeline = t;
      else {
        const { resolved: n } = this;
        if (!n) return vt;
        const { animation: r } = n;
        Bg(r, t);
      }
      return vt;
    }
    play() {
      if (this.isStopped) return;
      const { resolved: t } = this;
      if (!t) return;
      const { animation: n } = t;
      n.playState === "finished" && this.updateFinishedPromise(), n.play();
    }
    pause() {
      const { resolved: t } = this;
      if (!t) return;
      const { animation: n } = t;
      n.pause();
    }
    stop() {
      if (this.resolver.cancel(), this.isStopped = true, this.state === "idle") return;
      this.resolveFinishedPromise(), this.updateFinishedPromise();
      const { resolved: t } = this;
      if (!t) return;
      const { animation: n, keyframes: r, duration: s, type: i, ease: o, times: a } = t;
      if (n.playState === "idle" || n.playState === "finished") return;
      if (this.time) {
        const { motionValue: u, onUpdate: c, onComplete: d, element: f, ...p } = this.options, w = new bp({
          ...p,
          keyframes: r,
          duration: s,
          type: i,
          ease: o,
          times: a,
          isGenerator: true
        }), g = Nn(this.time);
        u.setWithVelocity(w.sample(g - Al).value, w.sample(g).value, Al);
      }
      const { onStop: l } = this.options;
      l && l(), this.cancel();
    }
    complete() {
      const { resolved: t } = this;
      t && t.animation.finish();
    }
    cancel() {
      const { resolved: t } = this;
      t && t.animation.cancel();
    }
    static supports(t) {
      const { motionValue: n, name: r, repeatDelay: s, repeatType: i, damping: o, type: a } = t;
      if (!n || !n.owner || !(n.owner.current instanceof HTMLElement)) return false;
      const { onUpdate: l, transformTemplate: u } = n.owner.getProps();
      return iM() && r && rM.has(r) && !l && !u && !s && i !== "mirror" && o !== 0 && a !== "inertia";
    }
  }
  const cM = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  }, dM = (e) => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  }), fM = {
    type: "keyframes",
    duration: 0.8
  }, hM = {
    type: "keyframes",
    ease: [
      0.25,
      0.1,
      0.35,
      1
    ],
    duration: 0.3
  }, pM = (e, { keyframes: t }) => t.length > 2 ? fM : es.has(e) ? e.startsWith("scale") ? dM(t[1]) : cM : hM;
  function mM({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: u, ...c }) {
    return !!Object.keys(c).length;
  }
  const Tp = (e, t, n, r = {}, s, i) => (o) => {
    const a = lp(r, e) || {}, l = a.delay || r.delay || 0;
    let { elapsed: u = 0 } = r;
    u = u - Nn(l);
    let c = {
      keyframes: Array.isArray(n) ? n : [
        null,
        n
      ],
      ease: "easeOut",
      velocity: t.getVelocity(),
      ...a,
      delay: -u,
      onUpdate: (f) => {
        t.set(f), a.onUpdate && a.onUpdate(f);
      },
      onComplete: () => {
        o(), a.onComplete && a.onComplete();
      },
      name: e,
      motionValue: t,
      element: i ? void 0 : s
    };
    mM(a) || (c = {
      ...c,
      ...pM(e, c)
    }), c.duration && (c.duration = Nn(c.duration)), c.repeatDelay && (c.repeatDelay = Nn(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from);
    let d = false;
    if ((c.type === false || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (d = true)), d && !i && t.get() !== void 0) {
      const f = bu(c.keyframes, a);
      if (f !== void 0) return ge.update(() => {
        c.onUpdate(f), c.onComplete();
      }), new O2([]);
    }
    return !i && sy.supports(c) ? new sy(c) : new bp(c);
  };
  function gM({ protectedKeys: e, needsAnimating: t }, n) {
    const r = e.hasOwnProperty(n) && t[n] !== true;
    return t[n] = false, r;
  }
  function R1(e, t, { delay: n = 0, transitionOverride: r, type: s } = {}) {
    var i;
    let { transition: o = e.getDefaultTransition(), transitionEnd: a, ...l } = t;
    r && (o = r);
    const u = [], c = s && e.animationState && e.animationState.getState()[s];
    for (const d in l) {
      const f = e.getValue(d, (i = e.latestValues[d]) !== null && i !== void 0 ? i : null), p = l[d];
      if (p === void 0 || c && gM(c, d)) continue;
      const w = {
        delay: n,
        ...lp(o || {}, d)
      };
      let g = false;
      if (window.MotionHandoffAnimation) {
        const m = e1(e);
        if (m) {
          const y = window.MotionHandoffAnimation(m, d, ge);
          y !== null && (w.startTime = y, g = true);
        }
      }
      qd(e, d), f.start(Tp(d, f, p, e.shouldReduceMotion && XS.has(d) ? {
        type: false
      } : w, e, g));
      const x = f.animation;
      x && u.push(x);
    }
    return a && Promise.all(u).then(() => {
      ge.update(() => {
        a && G2(e, a);
      });
    }), u;
  }
  function nf(e, t, n = {}) {
    var r;
    const s = Su(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
    let { transition: i = e.getDefaultTransition() || {} } = s || {};
    n.transitionOverride && (i = n.transitionOverride);
    const o = s ? () => Promise.all(R1(e, s, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (u = 0) => {
      const { delayChildren: c = 0, staggerChildren: d, staggerDirection: f } = i;
      return yM(e, t, c + u, d, f, n);
    } : () => Promise.resolve(), { when: l } = i;
    if (l) {
      const [u, c] = l === "beforeChildren" ? [
        o,
        a
      ] : [
        a,
        o
      ];
      return u().then(() => c());
    } else return Promise.all([
      o(),
      a(n.delay)
    ]);
  }
  function yM(e, t, n = 0, r = 0, s = 1, i) {
    const o = [], a = (e.variantChildren.size - 1) * r, l = s === 1 ? (u = 0) => u * r : (u = 0) => a - u * r;
    return Array.from(e.variantChildren).sort(vM).forEach((u, c) => {
      u.notify("AnimationStart", t), o.push(nf(u, t, {
        ...i,
        delay: n + l(c)
      }).then(() => u.notify("AnimationComplete", t)));
    }), Promise.all(o);
  }
  function vM(e, t) {
    return e.sortNodePosition(t);
  }
  function wM(e, t, n = {}) {
    e.notify("AnimationStart", t);
    let r;
    if (Array.isArray(t)) {
      const s = t.map((i) => nf(e, i, n));
      r = Promise.all(s);
    } else if (typeof t == "string") r = nf(e, t, n);
    else {
      const s = typeof t == "function" ? Su(e, t, n.custom) : t;
      r = Promise.all(R1(e, s, n));
    }
    return r.then(() => {
      e.notify("AnimationComplete", t);
    });
  }
  const xM = Zh.length;
  function N1(e) {
    if (!e) return;
    if (!e.isControllingVariants) {
      const n = e.parent ? N1(e.parent) || {} : {};
      return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
    }
    const t = {};
    for (let n = 0; n < xM; n++) {
      const r = Zh[n], s = e.props[r];
      (ho(s) || s === false) && (t[r] = s);
    }
    return t;
  }
  const SM = [
    ...qh
  ].reverse(), bM = qh.length;
  function TM(e) {
    return (t) => Promise.all(t.map(({ animation: n, options: r }) => wM(e, n, r)));
  }
  function CM(e) {
    let t = TM(e), n = iy(), r = true;
    const s = (l) => (u, c) => {
      var d;
      const f = Su(e, c, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0);
      if (f) {
        const { transition: p, transitionEnd: w, ...g } = f;
        u = {
          ...u,
          ...g,
          ...w
        };
      }
      return u;
    };
    function i(l) {
      t = l(e);
    }
    function o(l) {
      const { props: u } = e, c = N1(e.parent) || {}, d = [], f = /* @__PURE__ */ new Set();
      let p = {}, w = 1 / 0;
      for (let x = 0; x < bM; x++) {
        const m = SM[x], y = n[m], v = u[m] !== void 0 ? u[m] : c[m], b = ho(v), T = m === l ? y.isActive : null;
        T === false && (w = x);
        let C = v === c[m] && v !== u[m] && b;
        if (C && r && e.manuallyAnimateOnMount && (C = false), y.protectedKeys = {
          ...p
        }, !y.isActive && T === null || !v && !y.prevProp || wu(v) || typeof v == "boolean") continue;
        const E = EM(y.prevProp, v);
        let P = E || m === l && y.isActive && !C && b || x > w && b, D = false;
        const A = Array.isArray(v) ? v : [
          v
        ];
        let M = A.reduce(s(m), {});
        T === false && (M = {});
        const { prevResolvedValues: j = {} } = y, Q = {
          ...j,
          ...M
        }, L = (B) => {
          P = true, f.has(B) && (D = true, f.delete(B)), y.needsAnimating[B] = true;
          const k = e.getValue(B);
          k && (k.liveStyle = false);
        };
        for (const B in Q) {
          const k = M[B], O = j[B];
          if (p.hasOwnProperty(B)) continue;
          let I = false;
          Kd(k) && Kd(O) ? I = !WS(k, O) : I = k !== O, I ? k != null ? L(B) : f.add(B) : k !== void 0 && f.has(B) ? L(B) : y.protectedKeys[B] = true;
        }
        y.prevProp = v, y.prevResolvedValues = M, y.isActive && (p = {
          ...p,
          ...M
        }), r && e.blockInitialAnimation && (P = false), P && (!(C && E) || D) && d.push(...A.map((B) => ({
          animation: B,
          options: {
            type: m
          }
        })));
      }
      if (f.size) {
        const x = {};
        f.forEach((m) => {
          const y = e.getBaseTarget(m), v = e.getValue(m);
          v && (v.liveStyle = true), x[m] = y ?? null;
        }), d.push({
          animation: x
        });
      }
      let g = !!d.length;
      return r && (u.initial === false || u.initial === u.animate) && !e.manuallyAnimateOnMount && (g = false), r = false, g ? t(d) : Promise.resolve();
    }
    function a(l, u) {
      var c;
      if (n[l].isActive === u) return Promise.resolve();
      (c = e.variantChildren) === null || c === void 0 || c.forEach((f) => {
        var p;
        return (p = f.animationState) === null || p === void 0 ? void 0 : p.setActive(l, u);
      }), n[l].isActive = u;
      const d = o(l);
      for (const f in n) n[f].protectedKeys = {};
      return d;
    }
    return {
      animateChanges: o,
      setActive: a,
      setAnimateFunction: i,
      getState: () => n,
      reset: () => {
        n = iy(), r = true;
      }
    };
  }
  function EM(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !WS(t, e) : false;
  }
  function Er(e = false) {
    return {
      isActive: e,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function iy() {
    return {
      animate: Er(true),
      whileInView: Er(),
      whileHover: Er(),
      whileTap: Er(),
      whileDrag: Er(),
      whileFocus: Er(),
      exit: Er()
    };
  }
  class Cr {
    constructor(t) {
      this.isMounted = false, this.node = t;
    }
    update() {
    }
  }
  class PM extends Cr {
    constructor(t) {
      super(t), t.animationState || (t.animationState = CM(t));
    }
    updateAnimationControlsSubscription() {
      const { animate: t } = this.node.getProps();
      wu(t) && (this.unmountControls = t.subscribe(this.node));
    }
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
      t !== n && this.updateAnimationControlsSubscription();
    }
    unmount() {
      var t;
      this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this);
    }
  }
  let kM = 0;
  class _M extends Cr {
    constructor() {
      super(...arguments), this.id = kM++;
    }
    update() {
      if (!this.node.presenceContext) return;
      const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || t === r) return;
      const s = this.node.animationState.setActive("exit", !t);
      n && !t && s.then(() => n(this.id));
    }
    mount() {
      const { register: t } = this.node.presenceContext || {};
      t && (this.unmount = t(this.id));
    }
    unmount() {
    }
  }
  const AM = {
    animation: {
      Feature: PM
    },
    exit: {
      Feature: _M
    }
  };
  function yo(e, t, n, r = {
    passive: true
  }) {
    return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
  }
  function Ko(e) {
    return {
      point: {
        x: e.pageX,
        y: e.pageY
      }
    };
  }
  const RM = (e) => (t) => dp(t) && e(t, Ko(t));
  function Wi(e, t, n, r) {
    return yo(e, t, RM(n), r);
  }
  const oy = (e, t) => Math.abs(e - t);
  function NM(e, t) {
    const n = oy(e.x, t.x), r = oy(e.y, t.y);
    return Math.sqrt(n ** 2 + r ** 2);
  }
  class D1 {
    constructor(t, n, { transformPagePoint: r, contextWindow: s, dragSnapToOrigin: i = false } = {}) {
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const d = xc(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, p = NM(d.offset, {
          x: 0,
          y: 0
        }) >= 3;
        if (!f && !p) return;
        const { point: w } = d, { timestamp: g } = Ke;
        this.history.push({
          ...w,
          timestamp: g
        });
        const { onStart: x, onMove: m } = this.handlers;
        f || (x && x(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), m && m(this.lastMoveEvent, d);
      }, this.handlePointerMove = (d, f) => {
        this.lastMoveEvent = d, this.lastMoveEventInfo = wc(f, this.transformPagePoint), ge.update(this.updatePoint, true);
      }, this.handlePointerUp = (d, f) => {
        this.end();
        const { onEnd: p, onSessionEnd: w, resumeAnimation: g } = this.handlers;
        if (this.dragSnapToOrigin && g && g(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const x = xc(d.type === "pointercancel" ? this.lastMoveEventInfo : wc(f, this.transformPagePoint), this.history);
        this.startEvent && p && p(d, x), w && w(d, x);
      }, !dp(t)) return;
      this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.contextWindow = s || window;
      const o = Ko(t), a = wc(o, this.transformPagePoint), { point: l } = a, { timestamp: u } = Ke;
      this.history = [
        {
          ...l,
          timestamp: u
        }
      ];
      const { onSessionStart: c } = n;
      c && c(t, xc(a, this.history)), this.removeListeners = Ho(Wi(this.contextWindow, "pointermove", this.handlePointerMove), Wi(this.contextWindow, "pointerup", this.handlePointerUp), Wi(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(t) {
      this.handlers = t;
    }
    end() {
      this.removeListeners && this.removeListeners(), pr(this.updatePoint);
    }
  }
  function wc(e, t) {
    return t ? {
      point: t(e.point)
    } : e;
  }
  function ay(e, t) {
    return {
      x: e.x - t.x,
      y: e.y - t.y
    };
  }
  function xc({ point: e }, t) {
    return {
      point: e,
      delta: ay(e, M1(t)),
      offset: ay(e, DM(t)),
      velocity: MM(t, 0.1)
    };
  }
  function DM(e) {
    return e[0];
  }
  function M1(e) {
    return e[e.length - 1];
  }
  function MM(e, t) {
    if (e.length < 2) return {
      x: 0,
      y: 0
    };
    let n = e.length - 1, r = null;
    const s = M1(e);
    for (; n >= 0 && (r = e[n], !(s.timestamp - r.timestamp > Nn(t))); ) n--;
    if (!r) return {
      x: 0,
      y: 0
    };
    const i = Dn(s.timestamp - r.timestamp);
    if (i === 0) return {
      x: 0,
      y: 0
    };
    const o = {
      x: (s.x - r.x) / i,
      y: (s.y - r.y) / i
    };
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
  }
  const O1 = 1e-4, OM = 1 - O1, IM = 1 + O1, I1 = 0.01, LM = 0 - I1, jM = 0 + I1;
  function _t(e) {
    return e.max - e.min;
  }
  function VM(e, t, n) {
    return Math.abs(e - t) <= n;
  }
  function ly(e, t, n, r = 0.5) {
    e.origin = r, e.originPoint = be(t.min, t.max, e.origin), e.scale = _t(n) / _t(t), e.translate = be(n.min, n.max, e.origin) - e.originPoint, (e.scale >= OM && e.scale <= IM || isNaN(e.scale)) && (e.scale = 1), (e.translate >= LM && e.translate <= jM || isNaN(e.translate)) && (e.translate = 0);
  }
  function Hi(e, t, n, r) {
    ly(e.x, t.x, n.x, r ? r.originX : void 0), ly(e.y, t.y, n.y, r ? r.originY : void 0);
  }
  function uy(e, t, n) {
    e.min = n.min + t.min, e.max = e.min + _t(t);
  }
  function FM(e, t, n) {
    uy(e.x, t.x, n.x), uy(e.y, t.y, n.y);
  }
  function cy(e, t, n) {
    e.min = t.min - n.min, e.max = e.min + _t(t);
  }
  function Ki(e, t, n) {
    cy(e.x, t.x, n.x), cy(e.y, t.y, n.y);
  }
  function zM(e, { min: t, max: n }, r) {
    return t !== void 0 && e < t ? e = r ? be(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? be(n, e, r.max) : Math.min(e, n)), e;
  }
  function dy(e, t, n) {
    return {
      min: t !== void 0 ? e.min + t : void 0,
      max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    };
  }
  function BM(e, { top: t, left: n, bottom: r, right: s }) {
    return {
      x: dy(e.x, n, s),
      y: dy(e.y, t, r)
    };
  }
  function fy(e, t) {
    let n = t.min - e.min, r = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n, r] = [
      r,
      n
    ]), {
      min: n,
      max: r
    };
  }
  function UM(e, t) {
    return {
      x: fy(e.x, t.x),
      y: fy(e.y, t.y)
    };
  }
  function $M(e, t) {
    let n = 0.5;
    const r = _t(e), s = _t(t);
    return s > r ? n = Gs(t.min, t.max - r, e.min) : r > s && (n = Gs(e.min, e.max - s, t.min)), zn(0, 1, n);
  }
  function WM(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
  }
  const rf = 0.35;
  function HM(e = rf) {
    return e === false ? e = 0 : e === true && (e = rf), {
      x: hy(e, "left", "right"),
      y: hy(e, "top", "bottom")
    };
  }
  function hy(e, t, n) {
    return {
      min: py(e, t),
      max: py(e, n)
    };
  }
  function py(e, t) {
    return typeof e == "number" ? e : e[t] || 0;
  }
  const my = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  }), xs = () => ({
    x: my(),
    y: my()
  }), gy = () => ({
    min: 0,
    max: 0
  }), Re = () => ({
    x: gy(),
    y: gy()
  });
  function Dt(e) {
    return [
      e("x"),
      e("y")
    ];
  }
  function L1({ top: e, left: t, right: n, bottom: r }) {
    return {
      x: {
        min: t,
        max: n
      },
      y: {
        min: e,
        max: r
      }
    };
  }
  function KM({ x: e, y: t }) {
    return {
      top: t.min,
      right: e.max,
      bottom: t.max,
      left: e.min
    };
  }
  function QM(e, t) {
    if (!t) return e;
    const n = t({
      x: e.left,
      y: e.top
    }), r = t({
      x: e.right,
      y: e.bottom
    });
    return {
      top: n.y,
      left: n.x,
      bottom: r.y,
      right: r.x
    };
  }
  function Sc(e) {
    return e === void 0 || e === 1;
  }
  function sf({ scale: e, scaleX: t, scaleY: n }) {
    return !Sc(e) || !Sc(t) || !Sc(n);
  }
  function _r(e) {
    return sf(e) || j1(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
  }
  function j1(e) {
    return yy(e.x) || yy(e.y);
  }
  function yy(e) {
    return e && e !== "0%";
  }
  function Rl(e, t, n) {
    const r = e - n, s = t * r;
    return n + s;
  }
  function vy(e, t, n, r, s) {
    return s !== void 0 && (e = Rl(e, s, r)), Rl(e, n, r) + t;
  }
  function of(e, t = 0, n = 1, r, s) {
    e.min = vy(e.min, t, n, r, s), e.max = vy(e.max, t, n, r, s);
  }
  function V1(e, { x: t, y: n }) {
    of(e.x, t.translate, t.scale, t.originPoint), of(e.y, n.translate, n.scale, n.originPoint);
  }
  const wy = 0.999999999999, xy = 1.0000000000001;
  function GM(e, t, n, r = false) {
    const s = n.length;
    if (!s) return;
    t.x = t.y = 1;
    let i, o;
    for (let a = 0; a < s; a++) {
      i = n[a], o = i.projectionDelta;
      const { visualElement: l } = i.options;
      l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && bs(e, {
        x: -i.scroll.offset.x,
        y: -i.scroll.offset.y
      }), o && (t.x *= o.x.scale, t.y *= o.y.scale, V1(e, o)), r && _r(i.latestValues) && bs(e, i.latestValues));
    }
    t.x < xy && t.x > wy && (t.x = 1), t.y < xy && t.y > wy && (t.y = 1);
  }
  function Ss(e, t) {
    e.min = e.min + t, e.max = e.max + t;
  }
  function Sy(e, t, n, r, s = 0.5) {
    const i = be(e.min, e.max, s);
    of(e, t, n, i, r);
  }
  function bs(e, t) {
    Sy(e.x, t.x, t.scaleX, t.scale, t.originX), Sy(e.y, t.y, t.scaleY, t.scale, t.originY);
  }
  function F1(e, t) {
    return L1(QM(e.getBoundingClientRect(), t));
  }
  function qM(e, t, n) {
    const r = F1(e, n), { scroll: s } = t;
    return s && (Ss(r.x, s.offset.x), Ss(r.y, s.offset.y)), r;
  }
  const z1 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, ZM = /* @__PURE__ */ new WeakMap();
  class YM {
    constructor(t) {
      this.openDragLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = {
        x: 0,
        y: 0
      }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = Re(), this.visualElement = t;
    }
    start(t, { snapToCursor: n = false } = {}) {
      const { presenceContext: r } = this.visualElement;
      if (r && r.isPresent === false) return;
      const s = (c) => {
        const { dragSnapToOrigin: d } = this.getProps();
        d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Ko(c).point);
      }, i = (c, d) => {
        const { drag: f, dragPropagation: p, onDragStart: w } = this.getProps();
        if (f && !p && (this.openDragLock && this.openDragLock(), this.openDragLock = $2(f), !this.openDragLock)) return;
        this.isDragging = true, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = true, this.visualElement.projection.target = void 0), Dt((x) => {
          let m = this.getAxisMotionValue(x).get() || 0;
          if (fn.test(m)) {
            const { projection: y } = this.visualElement;
            if (y && y.layout) {
              const v = y.layout.layoutBox[x];
              v && (m = _t(v) * (parseFloat(m) / 100));
            }
          }
          this.originPoint[x] = m;
        }), w && ge.postRender(() => w(c, d)), qd(this.visualElement, "transform");
        const { animationState: g } = this.visualElement;
        g && g.setActive("whileDrag", true);
      }, o = (c, d) => {
        const { dragPropagation: f, dragDirectionLock: p, onDirectionLock: w, onDrag: g } = this.getProps();
        if (!f && !this.openDragLock) return;
        const { offset: x } = d;
        if (p && this.currentDirection === null) {
          this.currentDirection = XM(x), this.currentDirection !== null && w && w(this.currentDirection);
          return;
        }
        this.updateAxis("x", d.point, x), this.updateAxis("y", d.point, x), this.visualElement.render(), g && g(c, d);
      }, a = (c, d) => this.stop(c, d), l = () => Dt((c) => {
        var d;
        return this.getAnimationState(c) === "paused" && ((d = this.getAxisMotionValue(c).animation) === null || d === void 0 ? void 0 : d.play());
      }), { dragSnapToOrigin: u } = this.getProps();
      this.panSession = new D1(t, {
        onSessionStart: s,
        onStart: i,
        onMove: o,
        onSessionEnd: a,
        resumeAnimation: l
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        contextWindow: z1(this.visualElement)
      });
    }
    stop(t, n) {
      const r = this.isDragging;
      if (this.cancel(), !r) return;
      const { velocity: s } = n;
      this.startAnimation(s);
      const { onDragEnd: i } = this.getProps();
      i && ge.postRender(() => i(t, n));
    }
    cancel() {
      this.isDragging = false;
      const { projection: t, animationState: n } = this.visualElement;
      t && (t.isAnimationBlocked = false), this.panSession && this.panSession.end(), this.panSession = void 0;
      const { dragPropagation: r } = this.getProps();
      !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", false);
    }
    updateAxis(t, n, r) {
      const { drag: s } = this.getProps();
      if (!r || !xa(t, s, this.currentDirection)) return;
      const i = this.getAxisMotionValue(t);
      let o = this.originPoint[t] + r[t];
      this.constraints && this.constraints[t] && (o = zM(o, this.constraints[t], this.elastic[t])), i.set(o);
    }
    resolveConstraints() {
      var t;
      const { dragConstraints: n, dragElastic: r } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, i = this.constraints;
      n && vs(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && s ? this.constraints = BM(s.layoutBox, n) : this.constraints = false, this.elastic = HM(r), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && Dt((o) => {
        this.constraints !== false && this.getAxisMotionValue(o) && (this.constraints[o] = WM(s.layoutBox[o], this.constraints[o]));
      });
    }
    resolveRefConstraints() {
      const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
      if (!t || !vs(t)) return false;
      const r = t.current, { projection: s } = this.visualElement;
      if (!s || !s.layout) return false;
      const i = qM(r, s.root, this.visualElement.getTransformPagePoint());
      let o = UM(s.layout.layoutBox, i);
      if (n) {
        const a = n(KM(o));
        this.hasMutatedConstraints = !!a, a && (o = L1(a));
      }
      return o;
    }
    startAnimation(t) {
      const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = Dt((c) => {
        if (!xa(c, n, this.currentDirection)) return;
        let d = l && l[c] || {};
        o && (d = {
          min: 0,
          max: 0
        });
        const f = s ? 200 : 1e6, p = s ? 40 : 1e7, w = {
          type: "inertia",
          velocity: r ? t[c] : 0,
          bounceStiffness: f,
          bounceDamping: p,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...i,
          ...d
        };
        return this.startAxisValueAnimation(c, w);
      });
      return Promise.all(u).then(a);
    }
    startAxisValueAnimation(t, n) {
      const r = this.getAxisMotionValue(t);
      return qd(this.visualElement, t), r.start(Tp(t, r, 0, n, this.visualElement, false));
    }
    stopAnimation() {
      Dt((t) => this.getAxisMotionValue(t).stop());
    }
    pauseAnimation() {
      Dt((t) => {
        var n;
        return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
      });
    }
    getAnimationState(t) {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
    }
    getAxisMotionValue(t) {
      const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n];
      return s || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
    }
    snapToCursor(t) {
      Dt((n) => {
        const { drag: r } = this.getProps();
        if (!xa(n, r, this.currentDirection)) return;
        const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n);
        if (s && s.layout) {
          const { min: o, max: a } = s.layout.layoutBox[n];
          i.set(t[n] - be(o, a, 0.5));
        }
      });
    }
    scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
      if (!vs(n) || !r || !this.constraints) return;
      this.stopAnimation();
      const s = {
        x: 0,
        y: 0
      };
      Dt((o) => {
        const a = this.getAxisMotionValue(o);
        if (a && this.constraints !== false) {
          const l = a.get();
          s[o] = $M({
            min: l,
            max: l
          }, this.constraints[o]);
        }
      });
      const { transformTemplate: i } = this.visualElement.getProps();
      this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Dt((o) => {
        if (!xa(o, t, null)) return;
        const a = this.getAxisMotionValue(o), { min: l, max: u } = this.constraints[o];
        a.set(be(l, u, s[o]));
      });
    }
    addListeners() {
      if (!this.visualElement.current) return;
      ZM.set(this.visualElement, this);
      const t = this.visualElement.current, n = Wi(t, "pointerdown", (l) => {
        const { drag: u, dragListener: c = true } = this.getProps();
        u && c && this.start(l);
      }), r = () => {
        const { dragConstraints: l } = this.getProps();
        vs(l) && l.current && (this.constraints = this.resolveRefConstraints());
      }, { projection: s } = this.visualElement, i = s.addEventListener("measure", r);
      s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), ge.read(r);
      const o = yo(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => {
        this.isDragging && u && (Dt((c) => {
          const d = this.getAxisMotionValue(c);
          d && (this.originPoint[c] += l[c].translate, d.set(d.get() + l[c].translate));
        }), this.visualElement.render());
      });
      return () => {
        o(), n(), i(), a && a();
      };
    }
    getProps() {
      const t = this.visualElement.getProps(), { drag: n = false, dragDirectionLock: r = false, dragPropagation: s = false, dragConstraints: i = false, dragElastic: o = rf, dragMomentum: a = true } = t;
      return {
        ...t,
        drag: n,
        dragDirectionLock: r,
        dragPropagation: s,
        dragConstraints: i,
        dragElastic: o,
        dragMomentum: a
      };
    }
  }
  function xa(e, t, n) {
    return (t === true || t === e) && (n === null || n === e);
  }
  function XM(e, t = 10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
  }
  class JM extends Cr {
    constructor(t) {
      super(t), this.removeGroupControls = vt, this.removeListeners = vt, this.controls = new YM(t);
    }
    mount() {
      const { dragControls: t } = this.node.getProps();
      t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || vt;
    }
    unmount() {
      this.removeGroupControls(), this.removeListeners();
    }
  }
  const by = (e) => (t, n) => {
    e && ge.postRender(() => e(t, n));
  };
  class eO extends Cr {
    constructor() {
      super(...arguments), this.removePointerDownListener = vt;
    }
    onPointerDown(t) {
      this.session = new D1(t, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: z1(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps();
      return {
        onSessionStart: by(t),
        onStart: by(n),
        onMove: r,
        onEnd: (i, o) => {
          delete this.session, s && ge.postRender(() => s(i, o));
        }
      };
    }
    mount() {
      this.removePointerDownListener = Wi(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener(), this.session && this.session.end();
    }
  }
  const Wa = {
    hasAnimatedSinceResize: true,
    hasEverUpdated: false
  };
  function Ty(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
  }
  const Ci = {
    correct: (e, t) => {
      if (!t.target) return e;
      if (typeof e == "string") if (H.test(e)) e = parseFloat(e);
      else return e;
      const n = Ty(e, t.target.x), r = Ty(e, t.target.y);
      return `${n}% ${r}%`;
    }
  }, tO = {
    correct: (e, { treeScale: t, projectionDelta: n }) => {
      const r = e, s = mr.parse(e);
      if (s.length > 5) return r;
      const i = mr.createTransformer(e), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y;
      s[0 + o] /= a, s[1 + o] /= l;
      const u = be(a, l, 0.5);
      return typeof s[2 + o] == "number" && (s[2 + o] /= u), typeof s[3 + o] == "number" && (s[3 + o] /= u), i(s);
    }
  };
  class nO extends h.Component {
    componentDidMount() {
      const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = t;
      b2(rO), i && (n.group && n.group.add(i), r && r.register && s && r.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => {
        this.safeToRemove();
      }), i.setOptions({
        ...i.options,
        onExitComplete: () => this.safeToRemove()
      })), Wa.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(t) {
      const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, o = r.projection;
      return o && (o.isPresent = i, s || t.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || ge.postRender(() => {
        const a = o.getStack();
        (!a || !a.members.length) && this.safeToRemove();
      }))), null;
    }
    componentDidUpdate() {
      const { projection: t } = this.props.visualElement;
      t && (t.root.didUpdate(), Xh.postRender(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove();
      }));
    }
    componentWillUnmount() {
      const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = t;
      s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s));
    }
    safeToRemove() {
      const { safeToRemove: t } = this.props;
      t && t();
    }
    render() {
      return null;
    }
  }
  function B1(e) {
    const [t, n] = TS(), r = h.useContext(Wh);
    return S.jsx(nO, {
      ...e,
      layoutGroup: r,
      switchLayoutGroup: h.useContext(NS),
      isPresent: t,
      safeToRemove: n
    });
  }
  const rO = {
    borderRadius: {
      ...Ci,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: Ci,
    borderTopRightRadius: Ci,
    borderBottomLeftRadius: Ci,
    borderBottomRightRadius: Ci,
    boxShadow: tO
  };
  function sO(e, t, n) {
    const r = et(e) ? e : mo(e);
    return r.start(Tp("", r, t, n)), r.animation;
  }
  function iO(e) {
    return e instanceof SVGElement && e.tagName !== "svg";
  }
  const oO = (e, t) => e.depth - t.depth;
  class aO {
    constructor() {
      this.children = [], this.isDirty = false;
    }
    add(t) {
      fp(this.children, t), this.isDirty = true;
    }
    remove(t) {
      hp(this.children, t), this.isDirty = true;
    }
    forEach(t) {
      this.isDirty && this.children.sort(oO), this.isDirty = false, this.children.forEach(t);
    }
  }
  function lO(e, t) {
    const n = hn.now(), r = ({ timestamp: s }) => {
      const i = s - n;
      i >= t && (pr(r), e(i - t));
    };
    return ge.read(r, true), () => pr(r);
  }
  const U1 = [
    "TopLeft",
    "TopRight",
    "BottomLeft",
    "BottomRight"
  ], uO = U1.length, Cy = (e) => typeof e == "string" ? parseFloat(e) : e, Ey = (e) => typeof e == "number" || H.test(e);
  function cO(e, t, n, r, s, i) {
    s ? (e.opacity = be(0, n.opacity !== void 0 ? n.opacity : 1, dO(r)), e.opacityExit = be(t.opacity !== void 0 ? t.opacity : 1, 0, fO(r))) : i && (e.opacity = be(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let o = 0; o < uO; o++) {
      const a = `border${U1[o]}Radius`;
      let l = Py(t, a), u = Py(n, a);
      if (l === void 0 && u === void 0) continue;
      l || (l = 0), u || (u = 0), l === 0 || u === 0 || Ey(l) === Ey(u) ? (e[a] = Math.max(be(Cy(l), Cy(u), r), 0), (fn.test(u) || fn.test(l)) && (e[a] += "%")) : e[a] = u;
    }
    (t.rotate || n.rotate) && (e.rotate = be(t.rotate || 0, n.rotate || 0, r));
  }
  function Py(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius;
  }
  const dO = $1(0, 0.5, a1), fO = $1(0.5, 0.95, vt);
  function $1(e, t, n) {
    return (r) => r < e ? 0 : r > t ? 1 : n(Gs(e, t, r));
  }
  function ky(e, t) {
    e.min = t.min, e.max = t.max;
  }
  function Nt(e, t) {
    ky(e.x, t.x), ky(e.y, t.y);
  }
  function _y(e, t) {
    e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
  }
  function Ay(e, t, n, r, s) {
    return e -= t, e = Rl(e, 1 / n, r), s !== void 0 && (e = Rl(e, 1 / s, r)), e;
  }
  function hO(e, t = 0, n = 1, r = 0.5, s, i = e, o = e) {
    if (fn.test(t) && (t = parseFloat(t), t = be(o.min, o.max, t / 100) - o.min), typeof t != "number") return;
    let a = be(i.min, i.max, r);
    e === i && (a -= t), e.min = Ay(e.min, t, n, a, s), e.max = Ay(e.max, t, n, a, s);
  }
  function Ry(e, t, [n, r, s], i, o) {
    hO(e, t[n], t[r], t[s], t.scale, i, o);
  }
  const pO = [
    "x",
    "scaleX",
    "originX"
  ], mO = [
    "y",
    "scaleY",
    "originY"
  ];
  function Ny(e, t, n, r) {
    Ry(e.x, t, pO, n ? n.x : void 0, r ? r.x : void 0), Ry(e.y, t, mO, n ? n.y : void 0, r ? r.y : void 0);
  }
  function Dy(e) {
    return e.translate === 0 && e.scale === 1;
  }
  function W1(e) {
    return Dy(e.x) && Dy(e.y);
  }
  function My(e, t) {
    return e.min === t.min && e.max === t.max;
  }
  function gO(e, t) {
    return My(e.x, t.x) && My(e.y, t.y);
  }
  function Oy(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
  }
  function H1(e, t) {
    return Oy(e.x, t.x) && Oy(e.y, t.y);
  }
  function Iy(e) {
    return _t(e.x) / _t(e.y);
  }
  function Ly(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
  }
  class yO {
    constructor() {
      this.members = [];
    }
    add(t) {
      fp(this.members, t), t.scheduleRender();
    }
    remove(t) {
      if (hp(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
        const n = this.members[this.members.length - 1];
        n && this.promote(n);
      }
    }
    relegate(t) {
      const n = this.members.findIndex((s) => t === s);
      if (n === 0) return false;
      let r;
      for (let s = n; s >= 0; s--) {
        const i = this.members[s];
        if (i.isPresent !== false) {
          r = i;
          break;
        }
      }
      return r ? (this.promote(r), true) : false;
    }
    promote(t, n) {
      const r = this.lead;
      if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
        r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = true), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = true);
        const { crossfade: s } = t.options;
        s === false && r.hide();
      }
    }
    exitAnimationComplete() {
      this.members.forEach((t) => {
        const { options: n, resumingFrom: r } = t;
        n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
      });
    }
    scheduleRender() {
      this.members.forEach((t) => {
        t.instance && t.scheduleRender(false);
      });
    }
    removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }
  }
  function vO(e, t, n) {
    let r = "";
    const s = e.x.translate / t.x, i = e.y.translate / t.y, o = n?.z || 0;
    if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
      const { transformPerspective: u, rotate: c, rotateX: d, rotateY: f, skewX: p, skewY: w } = n;
      u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), p && (r += `skewX(${p}deg) `), w && (r += `skewY(${w}deg) `);
    }
    const a = e.x.scale * t.x, l = e.y.scale * t.y;
    return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none";
  }
  const Ar = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
  }, Di = typeof window < "u" && window.MotionDebug !== void 0, bc = [
    "",
    "X",
    "Y",
    "Z"
  ], wO = {
    visibility: "hidden"
  }, jy = 1e3;
  let xO = 0;
  function Tc(e, t, n, r) {
    const { latestValues: s } = t;
    s[e] && (n[e] = s[e], t.setStaticValue(e, 0), r && (r[e] = 0));
  }
  function K1(e) {
    if (e.hasCheckedOptimisedAppear = true, e.root === e) return;
    const { visualElement: t } = e.options;
    if (!t) return;
    const n = e1(t);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
      const { layout: s, layoutId: i } = e.options;
      window.MotionCancelOptimisedAnimation(n, "transform", ge, !(s || i));
    }
    const { parent: r } = e;
    r && !r.hasCheckedOptimisedAppear && K1(r);
  }
  function Q1({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) {
    return class {
      constructor(o = {}, a = t?.()) {
        this.id = xO++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.isProjectionDirty = false, this.isSharedProjectionDirty = false, this.isTransformDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.hasCheckedOptimisedAppear = false, this.treeScale = {
          x: 1,
          y: 1
        }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = false, this.updateScheduled = false, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = false, this.checkUpdateFailed = () => {
          this.isUpdating && (this.isUpdating = false, this.clearAllSnapshots());
        }, this.updateProjection = () => {
          this.projectionUpdateScheduled = false, Di && (Ar.totalNodes = Ar.resolvedTargetDeltas = Ar.recalculatedProjection = 0), this.nodes.forEach(TO), this.nodes.forEach(_O), this.nodes.forEach(AO), this.nodes.forEach(CO), Di && window.MotionDebug.record(Ar);
        }, this.resolvedRelativeTargetAt = 0, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [
          ...a.path,
          a
        ] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
        for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = true;
        this.root === this && (this.nodes = new aO());
      }
      addEventListener(o, a) {
        return this.eventHandlers.has(o) || this.eventHandlers.set(o, new pp()), this.eventHandlers.get(o).add(a);
      }
      notifyListeners(o, ...a) {
        const l = this.eventHandlers.get(o);
        l && l.notify(...a);
      }
      hasListeners(o) {
        return this.eventHandlers.has(o);
      }
      mount(o, a = this.root.hasTreeAnimated) {
        if (this.instance) return;
        this.isSVG = iO(o), this.instance = o;
        const { layoutId: l, layout: u, visualElement: c } = this.options;
        if (c && !c.current && c.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (u || l) && (this.isLayoutDirty = true), e) {
          let d;
          const f = () => this.root.updateBlockedByResize = false;
          e(o, () => {
            this.root.updateBlockedByResize = true, d && d(), d = lO(f, 250), Wa.hasAnimatedSinceResize && (Wa.hasAnimatedSinceResize = false, this.nodes.forEach(Fy));
          });
        }
        l && this.root.registerSharedNode(l, this), this.options.animate !== false && c && (l || u) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: p, layout: w }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0, this.relativeTarget = void 0;
            return;
          }
          const g = this.options.transition || c.getDefaultTransition() || OO, { onLayoutAnimationStart: x, onLayoutAnimationComplete: m } = c.getProps(), y = !this.targetLayout || !H1(this.targetLayout, w) || p, v = !f && p;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || v || f && (y || !this.currentAnimation)) {
            this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, v);
            const b = {
              ...lp(g, "layout"),
              onPlay: x,
              onComplete: m
            };
            (c.shouldReduceMotion || this.options.layoutRoot) && (b.delay = 0, b.type = false), this.startAnimation(b);
          } else f || Fy(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
          this.targetLayout = w;
        });
      }
      unmount() {
        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
        const o = this.getStack();
        o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, pr(this.updateProjection);
      }
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      startUpdate() {
        this.isUpdateBlocked() || (this.isUpdating = true, this.nodes && this.nodes.forEach(RO), this.animationId++);
      }
      getTransformTemplate() {
        const { visualElement: o } = this.options;
        return o && o.getProps().transformTemplate;
      }
      willUpdate(o = true) {
        if (this.root.hasTreeAnimated = true, this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && K1(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
        this.isLayoutDirty = true;
        for (let c = 0; c < this.path.length; c++) {
          const d = this.path[c];
          d.shouldResetTransform = true, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(false);
        }
        const { layoutId: a, layout: l } = this.options;
        if (a === void 0 && !l) return;
        const u = this.getTransformTemplate();
        this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
      }
      update() {
        if (this.updateScheduled = false, this.isUpdateBlocked()) {
          this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Vy);
          return;
        }
        this.isUpdating || this.nodes.forEach(PO), this.isUpdating = false, this.nodes.forEach(kO), this.nodes.forEach(SO), this.nodes.forEach(bO), this.clearAllSnapshots();
        const a = hn.now();
        Ke.delta = zn(0, 1e3 / 60, a - Ke.timestamp), Ke.timestamp = a, Ke.isProcessing = true, hc.update.process(Ke), hc.preRender.process(Ke), hc.render.process(Ke), Ke.isProcessing = false;
      }
      didUpdate() {
        this.updateScheduled || (this.updateScheduled = true, Xh.read(this.scheduleUpdate));
      }
      clearAllSnapshots() {
        this.nodes.forEach(EO), this.sharedNodes.forEach(NO);
      }
      scheduleUpdateProjection() {
        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = true, ge.preRender(this.updateProjection, false, true));
      }
      scheduleCheckAfterUnmount() {
        ge.postRender(() => {
          this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
        });
      }
      updateSnapshot() {
        this.snapshot || !this.instance || (this.snapshot = this.measure());
      }
      updateLayout() {
        if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
        if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
        const o = this.layout;
        this.layout = this.measure(false), this.layoutCorrected = Re(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement: a } = this.options;
        a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
      }
      updateScroll(o = "measure") {
        let a = !!(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = false), a) {
          const l = r(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: l,
            offset: n(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : l
          };
        }
      }
      resetTransform() {
        if (!s) return;
        const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !W1(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue;
        o && (a || _r(this.latestValues) || c) && (s(this.instance, u), this.shouldResetTransform = false, this.scheduleRender());
      }
      measure(o = true) {
        const a = this.measurePageBox();
        let l = this.removeElementScroll(a);
        return o && (l = this.removeTransform(l)), IO(l), {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        var o;
        const { visualElement: a } = this.options;
        if (!a) return Re();
        const l = a.measureViewportBox();
        if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(LO))) {
          const { scroll: c } = this.root;
          c && (Ss(l.x, c.offset.x), Ss(l.y, c.offset.y));
        }
        return l;
      }
      removeElementScroll(o) {
        var a;
        const l = Re();
        if (Nt(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l;
        for (let u = 0; u < this.path.length; u++) {
          const c = this.path[u], { scroll: d, options: f } = c;
          c !== this.root && d && f.layoutScroll && (d.wasRoot && Nt(l, o), Ss(l.x, d.offset.x), Ss(l.y, d.offset.y));
        }
        return l;
      }
      applyTransform(o, a = false) {
        const l = Re();
        Nt(l, o);
        for (let u = 0; u < this.path.length; u++) {
          const c = this.path[u];
          !a && c.options.layoutScroll && c.scroll && c !== c.root && bs(l, {
            x: -c.scroll.offset.x,
            y: -c.scroll.offset.y
          }), _r(c.latestValues) && bs(l, c.latestValues);
        }
        return _r(this.latestValues) && bs(l, this.latestValues), l;
      }
      removeTransform(o) {
        const a = Re();
        Nt(a, o);
        for (let l = 0; l < this.path.length; l++) {
          const u = this.path[l];
          if (!u.instance || !_r(u.latestValues)) continue;
          sf(u.latestValues) && u.updateSnapshot();
          const c = Re(), d = u.measurePageBox();
          Nt(c, d), Ny(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c);
        }
        return _r(this.latestValues) && Ny(a, this.latestValues), a;
      }
      setTargetDelta(o) {
        this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = true;
      }
      setOptions(o) {
        this.options = {
          ...this.options,
          ...o,
          crossfade: o.crossfade !== void 0 ? o.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ke.timestamp && this.relativeParent.resolveTargetDelta(true);
      }
      resolveTargetDelta(o = false) {
        var a;
        const l = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
        const u = !!this.resumingFrom || this !== l;
        if (!(o || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
        const { layout: d, layoutId: f } = this.options;
        if (!(!this.layout || !(d || f))) {
          if (this.resolvedRelativeTargetAt = Ke.timestamp, !this.targetDelta && !this.relativeTarget) {
            const p = this.getClosestProjectingParent();
            p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Re(), this.relativeTargetOrigin = Re(), Ki(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), Nt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          if (!(!this.relativeTarget && !this.targetDelta)) {
            if (this.target || (this.target = Re(), this.targetWithTransforms = Re()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), FM(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Nt(this.target, this.layout.layoutBox), V1(this.target, this.targetDelta)) : Nt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
              this.attemptToResolveRelativeTarget = false;
              const p = this.getClosestProjectingParent();
              p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Re(), this.relativeTargetOrigin = Re(), Ki(this.relativeTargetOrigin, this.target, p.target), Nt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
            }
            Di && Ar.resolvedTargetDeltas++;
          }
        }
      }
      getClosestProjectingParent() {
        if (!(!this.parent || sf(this.parent.latestValues) || j1(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
      }
      isProjecting() {
        return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        var o;
        const a = this.getLead(), l = !!this.resumingFrom || this !== a;
        let u = true;
        if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (u = false), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = false), this.resolvedRelativeTargetAt === Ke.timestamp && (u = false), u) return;
        const { layout: c, layoutId: d } = this.options;
        if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || d)) return;
        Nt(this.layoutCorrected, this.layout.layoutBox);
        const f = this.treeScale.x, p = this.treeScale.y;
        GM(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = Re());
        const { target: w } = a;
        if (!w) {
          this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
          return;
        }
        !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (_y(this.prevProjectionDelta.x, this.projectionDelta.x), _y(this.prevProjectionDelta.y, this.projectionDelta.y)), Hi(this.projectionDelta, this.layoutCorrected, w, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== p || !Ly(this.projectionDelta.x, this.prevProjectionDelta.x) || !Ly(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", w)), Di && Ar.recalculatedProjection++;
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(o = true) {
        var a;
        if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
          const l = this.getStack();
          l && l.scheduleRender();
        }
        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = xs(), this.projectionDelta = xs(), this.projectionDeltaWithTransform = xs();
      }
      setAnimationOrigin(o, a = false) {
        const l = this.snapshot, u = l ? l.latestValues : {}, c = {
          ...this.latestValues
        }, d = xs();
        (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
        const f = Re(), p = l ? l.source : void 0, w = this.layout ? this.layout.source : void 0, g = p !== w, x = this.getStack(), m = !x || x.members.length <= 1, y = !!(g && !m && this.options.crossfade === true && !this.path.some(MO));
        this.animationProgress = 0;
        let v;
        this.mixTargetDelta = (b) => {
          const T = b / 1e3;
          zy(d.x, o.x, T), zy(d.y, o.y, T), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ki(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), DO(this.relativeTarget, this.relativeTargetOrigin, f, T), v && gO(this.relativeTarget, v) && (this.isProjectionDirty = false), v || (v = Re()), Nt(v, this.relativeTarget)), g && (this.animationValues = c, cO(c, u, this.latestValues, T, y, m)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = T;
        }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(o) {
        this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (pr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ge.update(() => {
          Wa.hasAnimatedSinceResize = true, this.currentAnimation = sO(0, jy, {
            ...o,
            onUpdate: (a) => {
              this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
            },
            onComplete: () => {
              o.onComplete && o.onComplete(), this.completeAnimation();
            }
          }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
        const o = this.getStack();
        o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(jy), this.currentAnimation.stop()), this.completeAnimation();
      }
      applyTransformsToTarget() {
        const o = this.getLead();
        let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = o;
        if (!(!a || !l || !u)) {
          if (this !== o && this.layout && u && G1(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
            l = this.target || Re();
            const d = _t(this.layout.layoutBox.x);
            l.x.min = o.target.x.min, l.x.max = l.x.min + d;
            const f = _t(this.layout.layoutBox.y);
            l.y.min = o.target.y.min, l.y.max = l.y.min + f;
          }
          Nt(a, l), bs(a, c), Hi(this.projectionDeltaWithTransform, this.layoutCorrected, a, c);
        }
      }
      registerSharedNode(o, a) {
        this.sharedNodes.has(o) || this.sharedNodes.set(o, new yO()), this.sharedNodes.get(o).add(a);
        const u = a.options.initialPromotionConfig;
        a.promote({
          transition: u ? u.transition : void 0,
          preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
        });
      }
      isLead() {
        const o = this.getStack();
        return o ? o.lead === this : true;
      }
      getLead() {
        var o;
        const { layoutId: a } = this.options;
        return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
      }
      getPrevLead() {
        var o;
        const { layoutId: a } = this.options;
        return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
      }
      getStack() {
        const { layoutId: o } = this.options;
        if (o) return this.root.sharedNodes.get(o);
      }
      promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
        const u = this.getStack();
        u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = true), a && this.setOptions({
          transition: a
        });
      }
      relegate() {
        const o = this.getStack();
        return o ? o.relegate(this) : false;
      }
      resetSkewAndRotation() {
        const { visualElement: o } = this.options;
        if (!o) return;
        let a = false;
        const { latestValues: l } = o;
        if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = true), !a) return;
        const u = {};
        l.z && Tc("z", o, u, this.animationValues);
        for (let c = 0; c < bc.length; c++) Tc(`rotate${bc[c]}`, o, u, this.animationValues), Tc(`skew${bc[c]}`, o, u, this.animationValues);
        o.render();
        for (const c in u) o.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]);
        o.scheduleRender();
      }
      getProjectionStyles(o) {
        var a, l;
        if (!this.instance || this.isSVG) return;
        if (!this.isVisible) return wO;
        const u = {
          visibility: ""
        }, c = this.getTransformTemplate();
        if (this.needsReset) return this.needsReset = false, u.opacity = "", u.pointerEvents = Ua(o?.pointerEvents) || "", u.transform = c ? c(this.latestValues, "") : "none", u;
        const d = this.getLead();
        if (!this.projectionDelta || !this.layout || !d.target) {
          const g = {};
          return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = Ua(o?.pointerEvents) || ""), this.hasProjected && !_r(this.latestValues) && (g.transform = c ? c({}, "") : "none", this.hasProjected = false), g;
        }
        const f = d.animationValues || d.latestValues;
        this.applyTransformsToTarget(), u.transform = vO(this.projectionDeltaWithTransform, this.treeScale, f), c && (u.transform = c(f, u.transform));
        const { x: p, y: w } = this.projectionDelta;
        u.transformOrigin = `${p.origin * 100}% ${w.origin * 100}% 0`, d.animationValues ? u.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : u.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
        for (const g in El) {
          if (f[g] === void 0) continue;
          const { correct: x, applyTo: m } = El[g], y = u.transform === "none" ? f[g] : x(f[g], d);
          if (m) {
            const v = m.length;
            for (let b = 0; b < v; b++) u[m[b]] = y;
          } else u[g] = y;
        }
        return this.options.layoutId && (u.pointerEvents = d === this ? Ua(o?.pointerEvents) || "" : "none"), u;
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      resetTree() {
        this.root.nodes.forEach((o) => {
          var a;
          return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
        }), this.root.nodes.forEach(Vy), this.root.sharedNodes.clear();
      }
    };
  }
  function SO(e) {
    e.updateLayout();
  }
  function bO(e) {
    var t;
    const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
      const { layoutBox: r, measuredBox: s } = e.layout, { animationType: i } = e.options, o = n.source !== e.layout.source;
      i === "size" ? Dt((d) => {
        const f = o ? n.measuredBox[d] : n.layoutBox[d], p = _t(f);
        f.min = r[d].min, f.max = f.min + p;
      }) : G1(i, n.layoutBox, r) && Dt((d) => {
        const f = o ? n.measuredBox[d] : n.layoutBox[d], p = _t(r[d]);
        f.max = f.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = true, e.relativeTarget[d].max = e.relativeTarget[d].min + p);
      });
      const a = xs();
      Hi(a, r, n.layoutBox);
      const l = xs();
      o ? Hi(l, e.applyTransform(s, true), n.measuredBox) : Hi(l, r, n.layoutBox);
      const u = !W1(a);
      let c = false;
      if (!e.resumeFrom) {
        const d = e.getClosestProjectingParent();
        if (d && !d.resumeFrom) {
          const { snapshot: f, layout: p } = d;
          if (f && p) {
            const w = Re();
            Ki(w, n.layoutBox, f.layoutBox);
            const g = Re();
            Ki(g, r, p.layoutBox), H1(w, g) || (c = true), d.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = w, e.relativeParent = d);
          }
        }
      }
      e.notifyListeners("didUpdate", {
        layout: r,
        snapshot: n,
        delta: l,
        layoutDelta: a,
        hasLayoutChanged: u,
        hasRelativeTargetChanged: c
      });
    } else if (e.isLead()) {
      const { onExitComplete: r } = e.options;
      r && r();
    }
    e.options.transition = void 0;
  }
  function TO(e) {
    Di && Ar.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
  }
  function CO(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = false;
  }
  function EO(e) {
    e.clearSnapshot();
  }
  function Vy(e) {
    e.clearMeasurements();
  }
  function PO(e) {
    e.isLayoutDirty = false;
  }
  function kO(e) {
    const { visualElement: t } = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
  }
  function Fy(e) {
    e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = true;
  }
  function _O(e) {
    e.resolveTargetDelta();
  }
  function AO(e) {
    e.calcProjection();
  }
  function RO(e) {
    e.resetSkewAndRotation();
  }
  function NO(e) {
    e.removeLeadSnapshot();
  }
  function zy(e, t, n) {
    e.translate = be(t.translate, 0, n), e.scale = be(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
  }
  function By(e, t, n, r) {
    e.min = be(t.min, n.min, r), e.max = be(t.max, n.max, r);
  }
  function DO(e, t, n, r) {
    By(e.x, t.x, n.x, r), By(e.y, t.y, n.y, r);
  }
  function MO(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0;
  }
  const OO = {
    duration: 0.45,
    ease: [
      0.4,
      0,
      0.1,
      1
    ]
  }, Uy = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), $y = Uy("applewebkit/") && !Uy("chrome/") ? Math.round : vt;
  function Wy(e) {
    e.min = $y(e.min), e.max = $y(e.max);
  }
  function IO(e) {
    Wy(e.x), Wy(e.y);
  }
  function G1(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !VM(Iy(t), Iy(n), 0.2);
  }
  function LO(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot);
  }
  const jO = Q1({
    attachResizeListener: (e, t) => yo(e, "resize", t),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  }), Cc = {
    current: void 0
  }, q1 = Q1({
    measureScroll: (e) => ({
      x: e.scrollLeft,
      y: e.scrollTop
    }),
    defaultParent: () => {
      if (!Cc.current) {
        const e = new jO({});
        e.mount(window), e.setOptions({
          layoutScroll: true
        }), Cc.current = e;
      }
      return Cc.current;
    },
    resetTransform: (e, t) => {
      e.style.transform = t !== void 0 ? t : "none";
    },
    checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
  }), VO = {
    pan: {
      Feature: eO
    },
    drag: {
      Feature: JM,
      ProjectionNode: q1,
      MeasureLayout: B1
    }
  };
  function Hy(e, t, n) {
    const { props: r } = e;
    e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
    const s = "onHover" + n, i = r[s];
    i && ge.postRender(() => i(t, Ko(t)));
  }
  class FO extends Cr {
    mount() {
      const { current: t } = this.node;
      t && (this.unmount = V2(t, (n) => (Hy(this.node, n, "Start"), (r) => Hy(this.node, r, "End"))));
    }
    unmount() {
    }
  }
  class zO extends Cr {
    constructor() {
      super(...arguments), this.isActive = false;
    }
    onFocus() {
      let t = false;
      try {
        t = this.node.current.matches(":focus-visible");
      } catch {
        t = true;
      }
      !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", true), this.isActive = true);
    }
    onBlur() {
      !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", false), this.isActive = false);
    }
    mount() {
      this.unmount = Ho(yo(this.node.current, "focus", () => this.onFocus()), yo(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  }
  function Ky(e, t, n) {
    const { props: r } = e;
    e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
    const s = "onTap" + (n === "End" ? "" : n), i = r[s];
    i && ge.postRender(() => i(t, Ko(t)));
  }
  class BO extends Cr {
    mount() {
      const { current: t } = this.node;
      t && (this.unmount = U2(t, (n) => (Ky(this.node, n, "Start"), (r, { success: s }) => Ky(this.node, r, s ? "End" : "Cancel")), {
        useGlobalTarget: this.node.props.globalTapTarget
      }));
    }
    unmount() {
    }
  }
  const af = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), UO = (e) => {
    const t = af.get(e.target);
    t && t(e);
  }, $O = (e) => {
    e.forEach(UO);
  };
  function WO({ root: e, ...t }) {
    const n = e || document;
    Ec.has(n) || Ec.set(n, {});
    const r = Ec.get(n), s = JSON.stringify(t);
    return r[s] || (r[s] = new IntersectionObserver($O, {
      root: e,
      ...t
    })), r[s];
  }
  function HO(e, t, n) {
    const r = WO(t);
    return af.set(e, n), r.observe(e), () => {
      af.delete(e), r.unobserve(e);
    };
  }
  const KO = {
    some: 0,
    all: 1
  };
  class QO extends Cr {
    constructor() {
      super(...arguments), this.hasEnteredView = false, this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = t, o = {
        root: n ? n.current : void 0,
        rootMargin: r,
        threshold: typeof s == "number" ? s : KO[s]
      }, a = (l) => {
        const { isIntersecting: u } = l;
        if (this.isInView === u || (this.isInView = u, i && !u && this.hasEnteredView)) return;
        u && (this.hasEnteredView = true), this.node.animationState && this.node.animationState.setActive("whileInView", u);
        const { onViewportEnter: c, onViewportLeave: d } = this.node.getProps(), f = u ? c : d;
        f && f(l);
      };
      return HO(this.node.current, o, a);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver > "u") return;
      const { props: t, prevProps: n } = this.node;
      [
        "amount",
        "margin",
        "root"
      ].some(GO(t, n)) && this.startObserver();
    }
    unmount() {
    }
  }
  function GO({ viewport: e = {} }, { viewport: t = {} } = {}) {
    return (n) => e[n] !== t[n];
  }
  const qO = {
    inView: {
      Feature: QO
    },
    tap: {
      Feature: BO
    },
    focus: {
      Feature: zO
    },
    hover: {
      Feature: FO
    }
  }, ZO = {
    layout: {
      ProjectionNode: q1,
      MeasureLayout: B1
    }
  }, lf = {
    current: null
  }, Z1 = {
    current: false
  };
  function YO() {
    if (Z1.current = true, !!Qh) if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => lf.current = e.matches;
      e.addListener(t), t();
    } else lf.current = false;
  }
  const XO = [
    ...S1,
    Xe,
    mr
  ], JO = (e) => XO.find(x1(e)), Qy = /* @__PURE__ */ new WeakMap();
  function eI(e, t, n) {
    for (const r in t) {
      const s = t[r], i = n[r];
      if (et(s)) e.addValue(r, s);
      else if (et(i)) e.addValue(r, mo(s, {
        owner: e
      }));
      else if (i !== s) if (e.hasValue(r)) {
        const o = e.getValue(r);
        o.liveStyle === true ? o.jump(s) : o.hasAnimated || o.set(s);
      } else {
        const o = e.getStaticValue(r);
        e.addValue(r, mo(o !== void 0 ? o : s, {
          owner: e
        }));
      }
    }
    for (const r in n) t[r] === void 0 && e.removeValue(r);
    return t;
  }
  const Gy = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  class tI {
    scrapeMotionValuesFromProps(t, n, r) {
      return {};
    }
    constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: s, blockInitialAnimation: i, visualState: o }, a = {}) {
      this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = false, this.isControllingVariants = false, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = xp, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
      }, this.renderScheduledAt = 0, this.scheduleRender = () => {
        const p = hn.now();
        this.renderScheduledAt < p && (this.renderScheduledAt = p, ge.render(this.render, false, true));
      };
      const { latestValues: l, renderState: u, onUpdate: c } = o;
      this.onUpdate = c, this.latestValues = l, this.baseTarget = {
        ...l
      }, this.initialValues = n.initial ? {
        ...l
      } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = xu(n), this.isVariantNode = AS(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
      const { willChange: d, ...f } = this.scrapeMotionValuesFromProps(n, {}, this);
      for (const p in f) {
        const w = f[p];
        l[p] !== void 0 && et(w) && w.set(l[p], false);
      }
    }
    mount(t) {
      this.current = t, Qy.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), Z1.current || YO(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : lf.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
    }
    unmount() {
      Qy.delete(this.current), this.projection && this.projection.unmount(), pr(this.notifyUpdate), pr(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
      for (const t in this.events) this.events[t].clear();
      for (const t in this.features) {
        const n = this.features[t];
        n && (n.unmount(), n.isMounted = false);
      }
      this.current = null;
    }
    bindToMotionValue(t, n) {
      this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
      const r = es.has(t), s = n.on("change", (a) => {
        this.latestValues[t] = a, this.props.onUpdate && ge.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = true);
      }), i = n.on("renderRequest", this.scheduleRender);
      let o;
      window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
        s(), i(), o && o(), n.owner && n.stop();
      });
    }
    sortNodePosition(t) {
      return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
    }
    updateFeatures() {
      let t = "animation";
      for (t in qs) {
        const n = qs[t];
        if (!n) continue;
        const { isEnabled: r, Feature: s } = n;
        if (!this.features[t] && s && r(this.props) && (this.features[t] = new s(this)), this.features[t]) {
          const i = this.features[t];
          i.isMounted ? i.update() : (i.mount(), i.isMounted = true);
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Re();
    }
    getStaticValue(t) {
      return this.latestValues[t];
    }
    setStaticValue(t, n) {
      this.latestValues[t] = n;
    }
    update(t, n) {
      (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
      for (let r = 0; r < Gy.length; r++) {
        const s = Gy[r];
        this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
        const i = "on" + s, o = t[i];
        o && (this.propEventSubscriptions[s] = this.on(s, o));
      }
      this.prevMotionValues = eI(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
    }
    getProps() {
      return this.props;
    }
    getVariant(t) {
      return this.props.variants ? this.props.variants[t] : void 0;
    }
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    addVariantChild(t) {
      const n = this.getClosestVariantNode();
      if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
    }
    addValue(t, n) {
      const r = this.values.get(t);
      n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
    }
    removeValue(t) {
      this.values.delete(t);
      const n = this.valueSubscriptions.get(t);
      n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
    }
    hasValue(t) {
      return this.values.has(t);
    }
    getValue(t, n) {
      if (this.props.values && this.props.values[t]) return this.props.values[t];
      let r = this.values.get(t);
      return r === void 0 && n !== void 0 && (r = mo(n === null ? void 0 : n, {
        owner: this
      }), this.addValue(t, r)), r;
    }
    readValue(t, n) {
      var r;
      let s = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options);
      return s != null && (typeof s == "string" && (v1(s) || u1(s)) ? s = parseFloat(s) : !JO(s) && mr.test(n) && (s = m1(t, n)), this.setBaseTarget(t, et(s) ? s.get() : s)), et(s) ? s.get() : s;
    }
    setBaseTarget(t, n) {
      this.baseTarget[t] = n;
    }
    getBaseTarget(t) {
      var n;
      const { initial: r } = this.props;
      let s;
      if (typeof r == "string" || typeof r == "object") {
        const o = ep(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
        o && (s = o[t]);
      }
      if (r && s !== void 0) return s;
      const i = this.getBaseTargetFromProps(this.props, t);
      return i !== void 0 && !et(i) ? i : this.initialValues[t] !== void 0 && s === void 0 ? void 0 : this.baseTarget[t];
    }
    on(t, n) {
      return this.events[t] || (this.events[t] = new pp()), this.events[t].add(n);
    }
    notify(t, ...n) {
      this.events[t] && this.events[t].notify(...n);
    }
  }
  class Y1 extends tI {
    constructor() {
      super(...arguments), this.KeyframeResolver = b1;
    }
    sortInstanceNodePosition(t, n) {
      return t.compareDocumentPosition(n) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(t, n) {
      return t.style ? t.style[n] : void 0;
    }
    removeValueFromRenderState(t, { vars: n, style: r }) {
      delete n[t], delete r[t];
    }
    handleChildMotionValue() {
      this.childSubscription && (this.childSubscription(), delete this.childSubscription);
      const { children: t } = this.props;
      et(t) && (this.childSubscription = t.on("change", (n) => {
        this.current && (this.current.textContent = `${n}`);
      }));
    }
  }
  function nI(e) {
    return window.getComputedStyle(e);
  }
  class rI extends Y1 {
    constructor() {
      super(...arguments), this.type = "html", this.renderInstance = VS;
    }
    readValueFromInstance(t, n) {
      if (es.has(n)) {
        const r = wp(n);
        return r && r.default || 0;
      } else {
        const r = nI(t), s = (IS(n) ? r.getPropertyValue(n) : r[n]) || 0;
        return typeof s == "string" ? s.trim() : s;
      }
    }
    measureInstanceViewportBox(t, { transformPagePoint: n }) {
      return F1(t, n);
    }
    build(t, n, r) {
      rp(t, n, r.transformTemplate);
    }
    scrapeMotionValuesFromProps(t, n, r) {
      return ap(t, n, r);
    }
  }
  class sI extends Y1 {
    constructor() {
      super(...arguments), this.type = "svg", this.isSVGTag = false, this.measureInstanceViewportBox = Re;
    }
    getBaseTargetFromProps(t, n) {
      return t[n];
    }
    readValueFromInstance(t, n) {
      if (es.has(n)) {
        const r = wp(n);
        return r && r.default || 0;
      }
      return n = FS.has(n) ? n : Yh(n), t.getAttribute(n);
    }
    scrapeMotionValuesFromProps(t, n, r) {
      return US(t, n, r);
    }
    build(t, n, r) {
      sp(t, n, this.isSVGTag, r.transformTemplate);
    }
    renderInstance(t, n, r, s) {
      zS(t, n, r, s);
    }
    mount(t) {
      this.isSVGTag = op(t.tagName), super.mount(t);
    }
  }
  let iI, oI, Sa;
  iI = (e, t) => Jh(e) ? new sI(t) : new rI(t, {
    allowProjection: e !== h.Fragment
  });
  oI = N2({
    ...AM,
    ...qO,
    ...VO,
    ...ZO
  }, iI);
  ft = KN(oI);
  Sa = {
    light: 10,
    medium: 30,
    heavy: 50
  };
  function aI() {
    const e = typeof window < "u" && "vibrate" in navigator, t = h.useCallback((n) => {
      if (e) try {
        navigator.vibrate(n);
      } catch {
      }
    }, [
      e
    ]);
    return h.useEffect(() => {
      if (!e) return;
      const n = (l) => {
        const c = l.target.closest('button, a, input, select, textarea, [role="button"], [tabindex="0"]');
        t(c ? Sa.medium : Sa.light);
      };
      window.addEventListener("pointerup", n, {
        capture: true,
        passive: true
      });
      let r, s = window.scrollY, i = 0;
      const o = 300, a = () => {
        const l = window.scrollY, u = Math.abs(l - s);
        i += u, s = l, i > o && (t(Sa.light), i = 0), r && clearTimeout(r), r = setTimeout(() => {
          i = 0;
        }, 150);
      };
      return window.addEventListener("scroll", a, {
        passive: true
      }), () => {
        window.removeEventListener("pointerup", n, {
          capture: true
        }), window.removeEventListener("scroll", a), r && clearTimeout(r);
      };
    }, [
      e,
      t
    ]), {
      triggerHaptic: t,
      HAPTIC: Sa
    };
  }
  var lI = Object.defineProperty, Nl = Object.getOwnPropertySymbols, X1 = Object.prototype.hasOwnProperty, J1 = Object.prototype.propertyIsEnumerable, qy = (e, t, n) => t in e ? lI(e, t, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: n
  }) : e[t] = n, uf = (e, t) => {
    for (var n in t || (t = {})) X1.call(t, n) && qy(e, n, t[n]);
    if (Nl) for (var n of Nl(t)) J1.call(t, n) && qy(e, n, t[n]);
    return e;
  }, cf = (e, t) => {
    var n = {};
    for (var r in e) X1.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && Nl) for (var r of Nl(e)) t.indexOf(r) < 0 && J1.call(e, r) && (n[r] = e[r]);
    return n;
  };
  var Qr;
  ((e) => {
    const t = class te {
      constructor(l, u, c, d) {
        if (this.version = l, this.errorCorrectionLevel = u, this.modules = [], this.isFunction = [], l < te.MIN_VERSION || l > te.MAX_VERSION) throw new RangeError("Version value out of range");
        if (d < -1 || d > 7) throw new RangeError("Mask value out of range");
        this.size = l * 4 + 17;
        let f = [];
        for (let w = 0; w < this.size; w++) f.push(false);
        for (let w = 0; w < this.size; w++) this.modules.push(f.slice()), this.isFunction.push(f.slice());
        this.drawFunctionPatterns();
        const p = this.addEccAndInterleave(c);
        if (this.drawCodewords(p), d == -1) {
          let w = 1e9;
          for (let g = 0; g < 8; g++) {
            this.applyMask(g), this.drawFormatBits(g);
            const x = this.getPenaltyScore();
            x < w && (d = g, w = x), this.applyMask(g);
          }
        }
        s(0 <= d && d <= 7), this.mask = d, this.applyMask(d), this.drawFormatBits(d), this.isFunction = [];
      }
      static encodeText(l, u) {
        const c = e.QrSegment.makeSegments(l);
        return te.encodeSegments(c, u);
      }
      static encodeBinary(l, u) {
        const c = e.QrSegment.makeBytes(l);
        return te.encodeSegments([
          c
        ], u);
      }
      static encodeSegments(l, u, c = 1, d = 40, f = -1, p = true) {
        if (!(te.MIN_VERSION <= c && c <= d && d <= te.MAX_VERSION) || f < -1 || f > 7) throw new RangeError("Invalid value");
        let w, g;
        for (w = c; ; w++) {
          const v = te.getNumDataCodewords(w, u) * 8, b = o.getTotalBits(l, w);
          if (b <= v) {
            g = b;
            break;
          }
          if (w >= d) throw new RangeError("Data too long");
        }
        for (const v of [
          te.Ecc.MEDIUM,
          te.Ecc.QUARTILE,
          te.Ecc.HIGH
        ]) p && g <= te.getNumDataCodewords(w, v) * 8 && (u = v);
        let x = [];
        for (const v of l) {
          n(v.mode.modeBits, 4, x), n(v.numChars, v.mode.numCharCountBits(w), x);
          for (const b of v.getData()) x.push(b);
        }
        s(x.length == g);
        const m = te.getNumDataCodewords(w, u) * 8;
        s(x.length <= m), n(0, Math.min(4, m - x.length), x), n(0, (8 - x.length % 8) % 8, x), s(x.length % 8 == 0);
        for (let v = 236; x.length < m; v ^= 253) n(v, 8, x);
        let y = [];
        for (; y.length * 8 < x.length; ) y.push(0);
        return x.forEach((v, b) => y[b >>> 3] |= v << 7 - (b & 7)), new te(w, u, y, f);
      }
      getModule(l, u) {
        return 0 <= l && l < this.size && 0 <= u && u < this.size && this.modules[u][l];
      }
      getModules() {
        return this.modules;
      }
      drawFunctionPatterns() {
        for (let c = 0; c < this.size; c++) this.setFunctionModule(6, c, c % 2 == 0), this.setFunctionModule(c, 6, c % 2 == 0);
        this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4);
        const l = this.getAlignmentPatternPositions(), u = l.length;
        for (let c = 0; c < u; c++) for (let d = 0; d < u; d++) c == 0 && d == 0 || c == 0 && d == u - 1 || c == u - 1 && d == 0 || this.drawAlignmentPattern(l[c], l[d]);
        this.drawFormatBits(0), this.drawVersion();
      }
      drawFormatBits(l) {
        const u = this.errorCorrectionLevel.formatBits << 3 | l;
        let c = u;
        for (let f = 0; f < 10; f++) c = c << 1 ^ (c >>> 9) * 1335;
        const d = (u << 10 | c) ^ 21522;
        s(d >>> 15 == 0);
        for (let f = 0; f <= 5; f++) this.setFunctionModule(8, f, r(d, f));
        this.setFunctionModule(8, 7, r(d, 6)), this.setFunctionModule(8, 8, r(d, 7)), this.setFunctionModule(7, 8, r(d, 8));
        for (let f = 9; f < 15; f++) this.setFunctionModule(14 - f, 8, r(d, f));
        for (let f = 0; f < 8; f++) this.setFunctionModule(this.size - 1 - f, 8, r(d, f));
        for (let f = 8; f < 15; f++) this.setFunctionModule(8, this.size - 15 + f, r(d, f));
        this.setFunctionModule(8, this.size - 8, true);
      }
      drawVersion() {
        if (this.version < 7) return;
        let l = this.version;
        for (let c = 0; c < 12; c++) l = l << 1 ^ (l >>> 11) * 7973;
        const u = this.version << 12 | l;
        s(u >>> 18 == 0);
        for (let c = 0; c < 18; c++) {
          const d = r(u, c), f = this.size - 11 + c % 3, p = Math.floor(c / 3);
          this.setFunctionModule(f, p, d), this.setFunctionModule(p, f, d);
        }
      }
      drawFinderPattern(l, u) {
        for (let c = -4; c <= 4; c++) for (let d = -4; d <= 4; d++) {
          const f = Math.max(Math.abs(d), Math.abs(c)), p = l + d, w = u + c;
          0 <= p && p < this.size && 0 <= w && w < this.size && this.setFunctionModule(p, w, f != 2 && f != 4);
        }
      }
      drawAlignmentPattern(l, u) {
        for (let c = -2; c <= 2; c++) for (let d = -2; d <= 2; d++) this.setFunctionModule(l + d, u + c, Math.max(Math.abs(d), Math.abs(c)) != 1);
      }
      setFunctionModule(l, u, c) {
        this.modules[u][l] = c, this.isFunction[u][l] = true;
      }
      addEccAndInterleave(l) {
        const u = this.version, c = this.errorCorrectionLevel;
        if (l.length != te.getNumDataCodewords(u, c)) throw new RangeError("Invalid argument");
        const d = te.NUM_ERROR_CORRECTION_BLOCKS[c.ordinal][u], f = te.ECC_CODEWORDS_PER_BLOCK[c.ordinal][u], p = Math.floor(te.getNumRawDataModules(u) / 8), w = d - p % d, g = Math.floor(p / d);
        let x = [];
        const m = te.reedSolomonComputeDivisor(f);
        for (let v = 0, b = 0; v < d; v++) {
          let T = l.slice(b, b + g - f + (v < w ? 0 : 1));
          b += T.length;
          const C = te.reedSolomonComputeRemainder(T, m);
          v < w && T.push(0), x.push(T.concat(C));
        }
        let y = [];
        for (let v = 0; v < x[0].length; v++) x.forEach((b, T) => {
          (v != g - f || T >= w) && y.push(b[v]);
        });
        return s(y.length == p), y;
      }
      drawCodewords(l) {
        if (l.length != Math.floor(te.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
        let u = 0;
        for (let c = this.size - 1; c >= 1; c -= 2) {
          c == 6 && (c = 5);
          for (let d = 0; d < this.size; d++) for (let f = 0; f < 2; f++) {
            const p = c - f, g = (c + 1 & 2) == 0 ? this.size - 1 - d : d;
            !this.isFunction[g][p] && u < l.length * 8 && (this.modules[g][p] = r(l[u >>> 3], 7 - (u & 7)), u++);
          }
        }
        s(u == l.length * 8);
      }
      applyMask(l) {
        if (l < 0 || l > 7) throw new RangeError("Mask value out of range");
        for (let u = 0; u < this.size; u++) for (let c = 0; c < this.size; c++) {
          let d;
          switch (l) {
            case 0:
              d = (c + u) % 2 == 0;
              break;
            case 1:
              d = u % 2 == 0;
              break;
            case 2:
              d = c % 3 == 0;
              break;
            case 3:
              d = (c + u) % 3 == 0;
              break;
            case 4:
              d = (Math.floor(c / 3) + Math.floor(u / 2)) % 2 == 0;
              break;
            case 5:
              d = c * u % 2 + c * u % 3 == 0;
              break;
            case 6:
              d = (c * u % 2 + c * u % 3) % 2 == 0;
              break;
            case 7:
              d = ((c + u) % 2 + c * u % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          !this.isFunction[u][c] && d && (this.modules[u][c] = !this.modules[u][c]);
        }
      }
      getPenaltyScore() {
        let l = 0;
        for (let f = 0; f < this.size; f++) {
          let p = false, w = 0, g = [
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          for (let x = 0; x < this.size; x++) this.modules[f][x] == p ? (w++, w == 5 ? l += te.PENALTY_N1 : w > 5 && l++) : (this.finderPenaltyAddHistory(w, g), p || (l += this.finderPenaltyCountPatterns(g) * te.PENALTY_N3), p = this.modules[f][x], w = 1);
          l += this.finderPenaltyTerminateAndCount(p, w, g) * te.PENALTY_N3;
        }
        for (let f = 0; f < this.size; f++) {
          let p = false, w = 0, g = [
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          for (let x = 0; x < this.size; x++) this.modules[x][f] == p ? (w++, w == 5 ? l += te.PENALTY_N1 : w > 5 && l++) : (this.finderPenaltyAddHistory(w, g), p || (l += this.finderPenaltyCountPatterns(g) * te.PENALTY_N3), p = this.modules[x][f], w = 1);
          l += this.finderPenaltyTerminateAndCount(p, w, g) * te.PENALTY_N3;
        }
        for (let f = 0; f < this.size - 1; f++) for (let p = 0; p < this.size - 1; p++) {
          const w = this.modules[f][p];
          w == this.modules[f][p + 1] && w == this.modules[f + 1][p] && w == this.modules[f + 1][p + 1] && (l += te.PENALTY_N2);
        }
        let u = 0;
        for (const f of this.modules) u = f.reduce((p, w) => p + (w ? 1 : 0), u);
        const c = this.size * this.size, d = Math.ceil(Math.abs(u * 20 - c * 10) / c) - 1;
        return s(0 <= d && d <= 9), l += d * te.PENALTY_N4, s(0 <= l && l <= 2568888), l;
      }
      getAlignmentPatternPositions() {
        if (this.version == 1) return [];
        {
          const l = Math.floor(this.version / 7) + 2, u = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (l * 2 - 2)) * 2;
          let c = [
            6
          ];
          for (let d = this.size - 7; c.length < l; d -= u) c.splice(1, 0, d);
          return c;
        }
      }
      static getNumRawDataModules(l) {
        if (l < te.MIN_VERSION || l > te.MAX_VERSION) throw new RangeError("Version number out of range");
        let u = (16 * l + 128) * l + 64;
        if (l >= 2) {
          const c = Math.floor(l / 7) + 2;
          u -= (25 * c - 10) * c - 55, l >= 7 && (u -= 36);
        }
        return s(208 <= u && u <= 29648), u;
      }
      static getNumDataCodewords(l, u) {
        return Math.floor(te.getNumRawDataModules(l) / 8) - te.ECC_CODEWORDS_PER_BLOCK[u.ordinal][l] * te.NUM_ERROR_CORRECTION_BLOCKS[u.ordinal][l];
      }
      static reedSolomonComputeDivisor(l) {
        if (l < 1 || l > 255) throw new RangeError("Degree out of range");
        let u = [];
        for (let d = 0; d < l - 1; d++) u.push(0);
        u.push(1);
        let c = 1;
        for (let d = 0; d < l; d++) {
          for (let f = 0; f < u.length; f++) u[f] = te.reedSolomonMultiply(u[f], c), f + 1 < u.length && (u[f] ^= u[f + 1]);
          c = te.reedSolomonMultiply(c, 2);
        }
        return u;
      }
      static reedSolomonComputeRemainder(l, u) {
        let c = u.map((d) => 0);
        for (const d of l) {
          const f = d ^ c.shift();
          c.push(0), u.forEach((p, w) => c[w] ^= te.reedSolomonMultiply(p, f));
        }
        return c;
      }
      static reedSolomonMultiply(l, u) {
        if (l >>> 8 || u >>> 8) throw new RangeError("Byte out of range");
        let c = 0;
        for (let d = 7; d >= 0; d--) c = c << 1 ^ (c >>> 7) * 285, c ^= (u >>> d & 1) * l;
        return s(c >>> 8 == 0), c;
      }
      finderPenaltyCountPatterns(l) {
        const u = l[1];
        s(u <= this.size * 3);
        const c = u > 0 && l[2] == u && l[3] == u * 3 && l[4] == u && l[5] == u;
        return (c && l[0] >= u * 4 && l[6] >= u ? 1 : 0) + (c && l[6] >= u * 4 && l[0] >= u ? 1 : 0);
      }
      finderPenaltyTerminateAndCount(l, u, c) {
        return l && (this.finderPenaltyAddHistory(u, c), u = 0), u += this.size, this.finderPenaltyAddHistory(u, c), this.finderPenaltyCountPatterns(c);
      }
      finderPenaltyAddHistory(l, u) {
        u[0] == 0 && (l += this.size), u.pop(), u.unshift(l);
      }
    };
    t.MIN_VERSION = 1, t.MAX_VERSION = 40, t.PENALTY_N1 = 3, t.PENALTY_N2 = 3, t.PENALTY_N3 = 40, t.PENALTY_N4 = 10, t.ECC_CODEWORDS_PER_BLOCK = [
      [
        -1,
        7,
        10,
        15,
        20,
        26,
        18,
        20,
        24,
        30,
        18,
        20,
        24,
        26,
        30,
        22,
        24,
        28,
        30,
        28,
        28,
        28,
        28,
        30,
        30,
        26,
        28,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
      ],
      [
        -1,
        10,
        16,
        26,
        18,
        24,
        16,
        18,
        22,
        22,
        26,
        30,
        22,
        22,
        24,
        24,
        28,
        28,
        26,
        26,
        26,
        26,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28
      ],
      [
        -1,
        13,
        22,
        18,
        26,
        18,
        24,
        18,
        22,
        20,
        24,
        28,
        26,
        24,
        20,
        30,
        24,
        28,
        28,
        26,
        30,
        28,
        30,
        30,
        30,
        30,
        28,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
      ],
      [
        -1,
        17,
        28,
        22,
        16,
        22,
        28,
        26,
        26,
        24,
        28,
        24,
        28,
        22,
        24,
        24,
        30,
        28,
        28,
        26,
        28,
        30,
        24,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
      ]
    ], t.NUM_ERROR_CORRECTION_BLOCKS = [
      [
        -1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        4,
        4,
        4,
        4,
        4,
        6,
        6,
        6,
        6,
        7,
        8,
        8,
        9,
        9,
        10,
        12,
        12,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        19,
        20,
        21,
        22,
        24,
        25
      ],
      [
        -1,
        1,
        1,
        1,
        2,
        2,
        4,
        4,
        4,
        5,
        5,
        5,
        8,
        9,
        9,
        10,
        10,
        11,
        13,
        14,
        16,
        17,
        17,
        18,
        20,
        21,
        23,
        25,
        26,
        28,
        29,
        31,
        33,
        35,
        37,
        38,
        40,
        43,
        45,
        47,
        49
      ],
      [
        -1,
        1,
        1,
        2,
        2,
        4,
        4,
        6,
        6,
        8,
        8,
        8,
        10,
        12,
        16,
        12,
        17,
        16,
        18,
        21,
        20,
        23,
        23,
        25,
        27,
        29,
        34,
        34,
        35,
        38,
        40,
        43,
        45,
        48,
        51,
        53,
        56,
        59,
        62,
        65,
        68
      ],
      [
        -1,
        1,
        1,
        2,
        4,
        4,
        4,
        5,
        6,
        8,
        8,
        11,
        11,
        16,
        16,
        18,
        16,
        19,
        21,
        25,
        25,
        25,
        34,
        30,
        32,
        35,
        37,
        40,
        42,
        45,
        48,
        51,
        54,
        57,
        60,
        63,
        66,
        70,
        74,
        77,
        81
      ]
    ], e.QrCode = t;
    function n(a, l, u) {
      if (l < 0 || l > 31 || a >>> l) throw new RangeError("Value out of range");
      for (let c = l - 1; c >= 0; c--) u.push(a >>> c & 1);
    }
    function r(a, l) {
      return (a >>> l & 1) != 0;
    }
    function s(a) {
      if (!a) throw new Error("Assertion error");
    }
    const i = class Ee {
      constructor(l, u, c) {
        if (this.mode = l, this.numChars = u, this.bitData = c, u < 0) throw new RangeError("Invalid argument");
        this.bitData = c.slice();
      }
      static makeBytes(l) {
        let u = [];
        for (const c of l) n(c, 8, u);
        return new Ee(Ee.Mode.BYTE, l.length, u);
      }
      static makeNumeric(l) {
        if (!Ee.isNumeric(l)) throw new RangeError("String contains non-numeric characters");
        let u = [];
        for (let c = 0; c < l.length; ) {
          const d = Math.min(l.length - c, 3);
          n(parseInt(l.substring(c, c + d), 10), d * 3 + 1, u), c += d;
        }
        return new Ee(Ee.Mode.NUMERIC, l.length, u);
      }
      static makeAlphanumeric(l) {
        if (!Ee.isAlphanumeric(l)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
        let u = [], c;
        for (c = 0; c + 2 <= l.length; c += 2) {
          let d = Ee.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c)) * 45;
          d += Ee.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c + 1)), n(d, 11, u);
        }
        return c < l.length && n(Ee.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c)), 6, u), new Ee(Ee.Mode.ALPHANUMERIC, l.length, u);
      }
      static makeSegments(l) {
        return l == "" ? [] : Ee.isNumeric(l) ? [
          Ee.makeNumeric(l)
        ] : Ee.isAlphanumeric(l) ? [
          Ee.makeAlphanumeric(l)
        ] : [
          Ee.makeBytes(Ee.toUtf8ByteArray(l))
        ];
      }
      static makeEci(l) {
        let u = [];
        if (l < 0) throw new RangeError("ECI assignment value out of range");
        if (l < 128) n(l, 8, u);
        else if (l < 16384) n(2, 2, u), n(l, 14, u);
        else if (l < 1e6) n(6, 3, u), n(l, 21, u);
        else throw new RangeError("ECI assignment value out of range");
        return new Ee(Ee.Mode.ECI, 0, u);
      }
      static isNumeric(l) {
        return Ee.NUMERIC_REGEX.test(l);
      }
      static isAlphanumeric(l) {
        return Ee.ALPHANUMERIC_REGEX.test(l);
      }
      getData() {
        return this.bitData.slice();
      }
      static getTotalBits(l, u) {
        let c = 0;
        for (const d of l) {
          const f = d.mode.numCharCountBits(u);
          if (d.numChars >= 1 << f) return 1 / 0;
          c += 4 + f + d.bitData.length;
        }
        return c;
      }
      static toUtf8ByteArray(l) {
        l = encodeURI(l);
        let u = [];
        for (let c = 0; c < l.length; c++) l.charAt(c) != "%" ? u.push(l.charCodeAt(c)) : (u.push(parseInt(l.substring(c + 1, c + 3), 16)), c += 2);
        return u;
      }
    };
    i.NUMERIC_REGEX = /^[0-9]*$/, i.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, i.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    let o = i;
    e.QrSegment = i;
  })(Qr || (Qr = {}));
  ((e) => {
    ((t) => {
      const n = class {
        constructor(s, i) {
          this.ordinal = s, this.formatBits = i;
        }
      };
      n.LOW = new n(0, 1), n.MEDIUM = new n(1, 0), n.QUARTILE = new n(2, 3), n.HIGH = new n(3, 2), t.Ecc = n;
    })(e.QrCode || (e.QrCode = {}));
  })(Qr || (Qr = {}));
  ((e) => {
    ((t) => {
      const n = class {
        constructor(s, i) {
          this.modeBits = s, this.numBitsCharCount = i;
        }
        numCharCountBits(s) {
          return this.numBitsCharCount[Math.floor((s + 7) / 17)];
        }
      };
      n.NUMERIC = new n(1, [
        10,
        12,
        14
      ]), n.ALPHANUMERIC = new n(2, [
        9,
        11,
        13
      ]), n.BYTE = new n(4, [
        8,
        16,
        16
      ]), n.KANJI = new n(8, [
        8,
        10,
        12
      ]), n.ECI = new n(7, [
        0,
        0,
        0
      ]), t.Mode = n;
    })(e.QrSegment || (e.QrSegment = {}));
  })(Qr || (Qr = {}));
  var Ts = Qr;
  var uI = {
    L: Ts.QrCode.Ecc.LOW,
    M: Ts.QrCode.Ecc.MEDIUM,
    Q: Ts.QrCode.Ecc.QUARTILE,
    H: Ts.QrCode.Ecc.HIGH
  }, eb = 128, tb = "L", nb = "#FFFFFF", rb = "#000000", sb = false, ib = 1, cI = 4, dI = 0, fI = 0.1;
  function ob(e, t = 0) {
    const n = [];
    return e.forEach(function(r, s) {
      let i = null;
      r.forEach(function(o, a) {
        if (!o && i !== null) {
          n.push(`M${i + t} ${s + t}h${a - i}v1H${i + t}z`), i = null;
          return;
        }
        if (a === r.length - 1) {
          if (!o) return;
          i === null ? n.push(`M${a + t},${s + t} h1v1H${a + t}z`) : n.push(`M${i + t},${s + t} h${a + 1 - i}v1H${i + t}z`);
          return;
        }
        o && i === null && (i = a);
      });
    }), n.join("");
  }
  function ab(e, t) {
    return e.slice().map((n, r) => r < t.y || r >= t.y + t.h ? n : n.map((s, i) => i < t.x || i >= t.x + t.w ? s : false));
  }
  function hI(e, t, n, r) {
    if (r == null) return null;
    const s = e.length + n * 2, i = Math.floor(t * fI), o = s / t, a = (r.width || i) * o, l = (r.height || i) * o, u = r.x == null ? e.length / 2 - a / 2 : r.x * o, c = r.y == null ? e.length / 2 - l / 2 : r.y * o, d = r.opacity == null ? 1 : r.opacity;
    let f = null;
    if (r.excavate) {
      let w = Math.floor(u), g = Math.floor(c), x = Math.ceil(a + u - w), m = Math.ceil(l + c - g);
      f = {
        x: w,
        y: g,
        w: x,
        h: m
      };
    }
    const p = r.crossOrigin;
    return {
      x: u,
      y: c,
      h: l,
      w: a,
      excavation: f,
      opacity: d,
      crossOrigin: p
    };
  }
  function pI(e, t) {
    return t != null ? Math.max(Math.floor(t), 0) : e ? cI : dI;
  }
  function lb({ value: e, level: t, minVersion: n, includeMargin: r, marginSize: s, imageSettings: i, size: o, boostLevel: a }) {
    let l = ce.useMemo(() => {
      const w = (Array.isArray(e) ? e : [
        e
      ]).reduce((g, x) => (g.push(...Ts.QrSegment.makeSegments(x)), g), []);
      return Ts.QrCode.encodeSegments(w, uI[t], n, void 0, void 0, a);
    }, [
      e,
      t,
      n,
      a
    ]);
    const { cells: u, margin: c, numCells: d, calculatedImageSettings: f } = ce.useMemo(() => {
      let p = l.getModules();
      const w = pI(r, s), g = p.length + w * 2, x = hI(p, o, w, i);
      return {
        cells: p,
        margin: w,
        numCells: g,
        calculatedImageSettings: x
      };
    }, [
      l,
      o,
      i,
      r,
      s
    ]);
    return {
      qrcode: l,
      margin: c,
      cells: u,
      numCells: d,
      calculatedImageSettings: f
    };
  }
  var mI = function() {
    try {
      new Path2D().addPath(new Path2D());
    } catch {
      return false;
    }
    return true;
  }(), gI = ce.forwardRef(function(t, n) {
    const r = t, { value: s, size: i = eb, level: o = tb, bgColor: a = nb, fgColor: l = rb, includeMargin: u = sb, minVersion: c = ib, boostLevel: d, marginSize: f, imageSettings: p } = r, g = cf(r, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "marginSize",
      "imageSettings"
    ]), { style: x } = g, m = cf(g, [
      "style"
    ]), y = p?.src, v = ce.useRef(null), b = ce.useRef(null), T = ce.useCallback((L) => {
      v.current = L, typeof n == "function" ? n(L) : n && (n.current = L);
    }, [
      n
    ]), [C, E] = ce.useState(false), { margin: P, cells: D, numCells: A, calculatedImageSettings: M } = lb({
      value: s,
      level: o,
      minVersion: c,
      boostLevel: d,
      includeMargin: u,
      marginSize: f,
      imageSettings: p,
      size: i
    });
    ce.useEffect(() => {
      if (v.current != null) {
        const L = v.current, Z = L.getContext("2d");
        if (!Z) return;
        let W = D;
        const B = b.current, k = M != null && B !== null && B.complete && B.naturalHeight !== 0 && B.naturalWidth !== 0;
        k && M.excavation != null && (W = ab(D, M.excavation));
        const O = window.devicePixelRatio || 1;
        L.height = L.width = i * O;
        const I = i / A * O;
        Z.scale(I, I), Z.fillStyle = a, Z.fillRect(0, 0, A, A), Z.fillStyle = l, mI ? Z.fill(new Path2D(ob(W, P))) : D.forEach(function($, le) {
          $.forEach(function(rt, qe) {
            rt && Z.fillRect(qe + P, le + P, 1, 1);
          });
        }), M && (Z.globalAlpha = M.opacity), k && Z.drawImage(B, M.x + P, M.y + P, M.w, M.h);
      }
    }), ce.useEffect(() => {
      E(false);
    }, [
      y
    ]);
    const j = uf({
      height: i,
      width: i
    }, x);
    let Q = null;
    return y != null && (Q = ce.createElement("img", {
      src: y,
      key: y,
      style: {
        display: "none"
      },
      onLoad: () => {
        E(true);
      },
      ref: b,
      crossOrigin: M?.crossOrigin
    })), ce.createElement(ce.Fragment, null, ce.createElement("canvas", uf({
      style: j,
      height: i,
      width: i,
      ref: T,
      role: "img"
    }, m)), Q);
  });
  gI.displayName = "QRCodeCanvas";
  ub = ce.forwardRef(function(t, n) {
    const r = t, { value: s, size: i = eb, level: o = tb, bgColor: a = nb, fgColor: l = rb, includeMargin: u = sb, minVersion: c = ib, boostLevel: d, title: f, marginSize: p, imageSettings: w } = r, g = cf(r, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "title",
      "marginSize",
      "imageSettings"
    ]), { margin: x, cells: m, numCells: y, calculatedImageSettings: v } = lb({
      value: s,
      level: o,
      minVersion: c,
      boostLevel: d,
      includeMargin: u,
      marginSize: p,
      imageSettings: w,
      size: i
    });
    let b = m, T = null;
    w != null && v != null && (v.excavation != null && (b = ab(m, v.excavation)), T = ce.createElement("image", {
      href: w.src,
      height: v.h,
      width: v.w,
      x: v.x + x,
      y: v.y + x,
      preserveAspectRatio: "none",
      opacity: v.opacity,
      crossOrigin: v.crossOrigin
    }));
    const C = ob(b, x);
    return ce.createElement("svg", uf({
      height: i,
      width: i,
      viewBox: `0 0 ${y} ${y}`,
      ref: n,
      role: "img"
    }, g), !!f && ce.createElement("title", null, f), ce.createElement("path", {
      fill: a,
      d: `M0,0 h${y}v${y}H0z`,
      shapeRendering: "crispEdges"
    }), ce.createElement("path", {
      fill: l,
      d: C,
      shapeRendering: "crispEdges"
    }), T);
  });
  ub.displayName = "QRCodeSVG";
  cb = h.forwardRef(({ className: e, ...t }, n) => S.jsx("textarea", {
    className: ct("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e),
    ref: n,
    ...t
  }));
  cb.displayName = "Textarea";
  function db(e, [t, n]) {
    return Math.min(n, Math.max(t, e));
  }
  var yI = h.createContext(void 0);
  vI = function(e) {
    const t = h.useContext(yI);
    return e || t || "ltr";
  };
  function wI(e) {
    const t = h.useRef({
      value: e,
      previous: e
    });
    return h.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [
      e
    ]);
  }
  var fb = [
    "PageUp",
    "PageDown"
  ], hb = [
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
  ], pb = {
    "from-left": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowLeft"
    ],
    "from-right": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowRight"
    ],
    "from-bottom": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowLeft"
    ],
    "from-top": [
      "Home",
      "PageDown",
      "ArrowUp",
      "ArrowLeft"
    ]
  }, fi = "Slider", [df, xI, SI] = tx(fi), [mb] = ii(fi, [
    SI
  ]), [bI, Tu] = mb(fi), gb = h.forwardRef((e, t) => {
    const { name: n, min: r = 0, max: s = 100, step: i = 1, orientation: o = "horizontal", disabled: a = false, minStepsBetweenThumbs: l = 0, defaultValue: u = [
      r
    ], value: c, onValueChange: d = () => {
    }, onValueCommit: f = () => {
    }, inverted: p = false, form: w, ...g } = e, x = h.useRef(/* @__PURE__ */ new Set()), m = h.useRef(0), v = o === "horizontal" ? TI : CI, [b = [], T] = Rh({
      prop: c,
      defaultProp: u,
      onChange: (M) => {
        [
          ...x.current
        ][m.current]?.focus(), d(M);
      }
    }), C = h.useRef(b);
    function E(M) {
      const j = AI(b, M);
      A(M, j);
    }
    function P(M) {
      A(M, m.current);
    }
    function D() {
      const M = C.current[m.current];
      b[m.current] !== M && f(b);
    }
    function A(M, j, { commit: Q } = {
      commit: false
    }) {
      const L = MI(i), Z = OI(Math.round((M - r) / i) * i + r, L), W = db(Z, [
        r,
        s
      ]);
      T((B = []) => {
        const k = kI(B, W, j);
        if (DI(k, l * i)) {
          m.current = k.indexOf(W);
          const O = String(k) !== String(B);
          return O && Q && f(k), O ? k : B;
        } else return B;
      });
    }
    return S.jsx(bI, {
      scope: e.__scopeSlider,
      name: n,
      disabled: a,
      min: r,
      max: s,
      valueIndexToChangeRef: m,
      thumbs: x.current,
      values: b,
      orientation: o,
      form: w,
      children: S.jsx(df.Provider, {
        scope: e.__scopeSlider,
        children: S.jsx(df.Slot, {
          scope: e.__scopeSlider,
          children: S.jsx(v, {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...g,
            ref: t,
            onPointerDown: ae(g.onPointerDown, () => {
              a || (C.current = b);
            }),
            min: r,
            max: s,
            inverted: p,
            onSlideStart: a ? void 0 : E,
            onSlideMove: a ? void 0 : P,
            onSlideEnd: a ? void 0 : D,
            onHomeKeyDown: () => !a && A(r, 0, {
              commit: true
            }),
            onEndKeyDown: () => !a && A(s, b.length - 1, {
              commit: true
            }),
            onStepKeyDown: ({ event: M, direction: j }) => {
              if (!a) {
                const Z = fb.includes(M.key) || M.shiftKey && hb.includes(M.key) ? 10 : 1, W = m.current, B = b[W], k = i * Z * j;
                A(B + k, W, {
                  commit: true
                });
              }
            }
          })
        })
      })
    });
  });
  gb.displayName = fi;
  var [yb, vb] = mb(fi, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }), TI = h.forwardRef((e, t) => {
    const { min: n, max: r, dir: s, inverted: i, onSlideStart: o, onSlideMove: a, onSlideEnd: l, onStepKeyDown: u, ...c } = e, [d, f] = h.useState(null), p = Me(t, (v) => f(v)), w = h.useRef(void 0), g = vI(s), x = g === "ltr", m = x && !i || !x && i;
    function y(v) {
      const b = w.current || d.getBoundingClientRect(), T = [
        0,
        b.width
      ], E = Cp(T, m ? [
        n,
        r
      ] : [
        r,
        n
      ]);
      return w.current = b, E(v - b.left);
    }
    return S.jsx(yb, {
      scope: e.__scopeSlider,
      startEdge: m ? "left" : "right",
      endEdge: m ? "right" : "left",
      direction: m ? 1 : -1,
      size: "width",
      children: S.jsx(wb, {
        dir: g,
        "data-orientation": "horizontal",
        ...c,
        ref: p,
        style: {
          ...c.style,
          "--radix-slider-thumb-transform": "translateX(-50%)"
        },
        onSlideStart: (v) => {
          const b = y(v.clientX);
          o?.(b);
        },
        onSlideMove: (v) => {
          const b = y(v.clientX);
          a?.(b);
        },
        onSlideEnd: () => {
          w.current = void 0, l?.();
        },
        onStepKeyDown: (v) => {
          const T = pb[m ? "from-left" : "from-right"].includes(v.key);
          u?.({
            event: v,
            direction: T ? -1 : 1
          });
        }
      })
    });
  }), CI = h.forwardRef((e, t) => {
    const { min: n, max: r, inverted: s, onSlideStart: i, onSlideMove: o, onSlideEnd: a, onStepKeyDown: l, ...u } = e, c = h.useRef(null), d = Me(t, c), f = h.useRef(void 0), p = !s;
    function w(g) {
      const x = f.current || c.current.getBoundingClientRect(), m = [
        0,
        x.height
      ], v = Cp(m, p ? [
        r,
        n
      ] : [
        n,
        r
      ]);
      return f.current = x, v(g - x.top);
    }
    return S.jsx(yb, {
      scope: e.__scopeSlider,
      startEdge: p ? "bottom" : "top",
      endEdge: p ? "top" : "bottom",
      size: "height",
      direction: p ? 1 : -1,
      children: S.jsx(wb, {
        "data-orientation": "vertical",
        ...u,
        ref: d,
        style: {
          ...u.style,
          "--radix-slider-thumb-transform": "translateY(50%)"
        },
        onSlideStart: (g) => {
          const x = w(g.clientY);
          i?.(x);
        },
        onSlideMove: (g) => {
          const x = w(g.clientY);
          o?.(x);
        },
        onSlideEnd: () => {
          f.current = void 0, a?.();
        },
        onStepKeyDown: (g) => {
          const m = pb[p ? "from-bottom" : "from-top"].includes(g.key);
          l?.({
            event: g,
            direction: m ? -1 : 1
          });
        }
      })
    });
  }), wb = h.forwardRef((e, t) => {
    const { __scopeSlider: n, onSlideStart: r, onSlideMove: s, onSlideEnd: i, onHomeKeyDown: o, onEndKeyDown: a, onStepKeyDown: l, ...u } = e, c = Tu(fi, n);
    return S.jsx(ye.span, {
      ...u,
      ref: t,
      onKeyDown: ae(e.onKeyDown, (d) => {
        d.key === "Home" ? (o(d), d.preventDefault()) : d.key === "End" ? (a(d), d.preventDefault()) : fb.concat(hb).includes(d.key) && (l(d), d.preventDefault());
      }),
      onPointerDown: ae(e.onPointerDown, (d) => {
        const f = d.target;
        f.setPointerCapture(d.pointerId), d.preventDefault(), c.thumbs.has(f) ? f.focus() : r(d);
      }),
      onPointerMove: ae(e.onPointerMove, (d) => {
        d.target.hasPointerCapture(d.pointerId) && s(d);
      }),
      onPointerUp: ae(e.onPointerUp, (d) => {
        const f = d.target;
        f.hasPointerCapture(d.pointerId) && (f.releasePointerCapture(d.pointerId), i(d));
      })
    });
  }), xb = "SliderTrack", Sb = h.forwardRef((e, t) => {
    const { __scopeSlider: n, ...r } = e, s = Tu(xb, n);
    return S.jsx(ye.span, {
      "data-disabled": s.disabled ? "" : void 0,
      "data-orientation": s.orientation,
      ...r,
      ref: t
    });
  });
  Sb.displayName = xb;
  var ff = "SliderRange", bb = h.forwardRef((e, t) => {
    const { __scopeSlider: n, ...r } = e, s = Tu(ff, n), i = vb(ff, n), o = h.useRef(null), a = Me(t, o), l = s.values.length, u = s.values.map((f) => Eb(f, s.min, s.max)), c = l > 1 ? Math.min(...u) : 0, d = 100 - Math.max(...u);
    return S.jsx(ye.span, {
      "data-orientation": s.orientation,
      "data-disabled": s.disabled ? "" : void 0,
      ...r,
      ref: a,
      style: {
        ...e.style,
        [i.startEdge]: c + "%",
        [i.endEdge]: d + "%"
      }
    });
  });
  bb.displayName = ff;
  var hf = "SliderThumb", Tb = h.forwardRef((e, t) => {
    const n = xI(e.__scopeSlider), [r, s] = h.useState(null), i = Me(t, (a) => s(a)), o = h.useMemo(() => r ? n().findIndex((a) => a.ref.current === r) : -1, [
      n,
      r
    ]);
    return S.jsx(EI, {
      ...e,
      ref: i,
      index: o
    });
  }), EI = h.forwardRef((e, t) => {
    const { __scopeSlider: n, index: r, name: s, ...i } = e, o = Tu(hf, n), a = vb(hf, n), [l, u] = h.useState(null), c = Me(t, (y) => u(y)), d = l ? o.form || !!l.closest("form") : true, f = Jx(l), p = o.values[r], w = p === void 0 ? 0 : Eb(p, o.min, o.max), g = _I(r, o.values.length), x = f?.[a.size], m = x ? RI(x, w, a.direction) : 0;
    return h.useEffect(() => {
      if (l) return o.thumbs.add(l), () => {
        o.thumbs.delete(l);
      };
    }, [
      l,
      o.thumbs
    ]), S.jsxs("span", {
      style: {
        transform: "var(--radix-slider-thumb-transform)",
        position: "absolute",
        [a.startEdge]: `calc(${w}% + ${m}px)`
      },
      children: [
        S.jsx(df.ItemSlot, {
          scope: e.__scopeSlider,
          children: S.jsx(ye.span, {
            role: "slider",
            "aria-label": e["aria-label"] || g,
            "aria-valuemin": o.min,
            "aria-valuenow": p,
            "aria-valuemax": o.max,
            "aria-orientation": o.orientation,
            "data-orientation": o.orientation,
            "data-disabled": o.disabled ? "" : void 0,
            tabIndex: o.disabled ? void 0 : 0,
            ...i,
            ref: c,
            style: p === void 0 ? {
              display: "none"
            } : e.style,
            onFocus: ae(e.onFocus, () => {
              o.valueIndexToChangeRef.current = r;
            })
          })
        }),
        d && S.jsx(Cb, {
          name: s ?? (o.name ? o.name + (o.values.length > 1 ? "[]" : "") : void 0),
          form: o.form,
          value: p
        }, r)
      ]
    });
  });
  Tb.displayName = hf;
  var PI = "RadioBubbleInput", Cb = h.forwardRef(({ __scopeSlider: e, value: t, ...n }, r) => {
    const s = h.useRef(null), i = Me(s, r), o = wI(t);
    return h.useEffect(() => {
      const a = s.current;
      if (!a) return;
      const l = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(l, "value").set;
      if (o !== t && c) {
        const d = new Event("input", {
          bubbles: true
        });
        c.call(a, t), a.dispatchEvent(d);
      }
    }, [
      o,
      t
    ]), S.jsx(ye.input, {
      style: {
        display: "none"
      },
      ...n,
      ref: i,
      defaultValue: t
    });
  });
  Cb.displayName = PI;
  function kI(e = [], t, n) {
    const r = [
      ...e
    ];
    return r[n] = t, r.sort((s, i) => s - i);
  }
  function Eb(e, t, n) {
    const i = 100 / (n - t) * (e - t);
    return db(i, [
      0,
      100
    ]);
  }
  function _I(e, t) {
    return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? [
      "Minimum",
      "Maximum"
    ][e] : void 0;
  }
  function AI(e, t) {
    if (e.length === 1) return 0;
    const n = e.map((s) => Math.abs(s - t)), r = Math.min(...n);
    return n.indexOf(r);
  }
  function RI(e, t, n) {
    const r = e / 2, i = Cp([
      0,
      50
    ], [
      0,
      r
    ]);
    return (r - i(t) * n) * n;
  }
  function NI(e) {
    return e.slice(0, -1).map((t, n) => e[n + 1] - t);
  }
  function DI(e, t) {
    if (t > 0) {
      const n = NI(e);
      return Math.min(...n) >= t;
    }
    return true;
  }
  function Cp(e, t) {
    return (n) => {
      if (e[0] === e[1] || t[0] === t[1]) return t[0];
      const r = (t[1] - t[0]) / (e[1] - e[0]);
      return t[0] + r * (n - e[0]);
    };
  }
  function MI(e) {
    return (String(e).split(".")[1] || "").length;
  }
  function OI(e, t) {
    const n = Math.pow(10, t);
    return Math.round(e * n) / n;
  }
  var Pb = gb, II = Sb, LI = bb, jI = Tb;
  kb = h.forwardRef(({ className: e, ...t }, n) => S.jsxs(Pb, {
    ref: n,
    className: ct("relative flex w-full touch-none select-none items-center", e),
    ...t,
    children: [
      S.jsx(II, {
        className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary",
        children: S.jsx(LI, {
          className: "absolute h-full bg-primary"
        })
      }),
      S.jsx(jI, {
        className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
      })
    ]
  }));
  kb.displayName = Pb.displayName;
  const Zy = () => typeof window > "u" ? null : new (window.AudioContext || window.webkitAudioContext)(), VI = {
    click: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.frequency.setValueAtTime(800, e.currentTime), n.frequency.exponentialRampToValueAtTime(600, e.currentTime + 0.05), r.gain.setValueAtTime(t * 0.3, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.05), n.start(e.currentTime), n.stop(e.currentTime + 0.05);
    },
    success: (e, t) => {
      [
        523.25,
        659.25,
        783.99
      ].forEach((r, s) => {
        const i = e.createOscillator(), o = e.createGain();
        i.connect(o), o.connect(e.destination), i.type = "sine", i.frequency.setValueAtTime(r, e.currentTime + s * 0.1), o.gain.setValueAtTime(0, e.currentTime + s * 0.1), o.gain.linearRampToValueAtTime(t * 0.2, e.currentTime + s * 0.1 + 0.02), o.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + s * 0.1 + 0.3), i.start(e.currentTime + s * 0.1), i.stop(e.currentTime + s * 0.1 + 0.3);
      });
    },
    error: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "sawtooth", n.frequency.setValueAtTime(200, e.currentTime), n.frequency.linearRampToValueAtTime(150, e.currentTime + 0.15), r.gain.setValueAtTime(t * 0.15, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.15), n.start(e.currentTime), n.stop(e.currentTime + 0.15);
    },
    unlock: (e, t) => {
      [
        300,
        400,
        500,
        700
      ].forEach((r, s) => {
        const i = e.createOscillator(), o = e.createGain();
        i.connect(o), o.connect(e.destination), i.type = "sine", i.frequency.setValueAtTime(r, e.currentTime + s * 0.08), o.gain.setValueAtTime(t * 0.15, e.currentTime + s * 0.08), o.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + s * 0.08 + 0.15), i.start(e.currentTime + s * 0.08), i.stop(e.currentTime + s * 0.08 + 0.15);
      });
    },
    lock: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "triangle", n.frequency.setValueAtTime(600, e.currentTime), n.frequency.exponentialRampToValueAtTime(200, e.currentTime + 0.2), r.gain.setValueAtTime(t * 0.2, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.2), n.start(e.currentTime), n.stop(e.currentTime + 0.2);
    },
    drop: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "sine", n.frequency.setValueAtTime(400, e.currentTime), n.frequency.exponentialRampToValueAtTime(100, e.currentTime + 0.15), r.gain.setValueAtTime(t * 0.25, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.15), n.start(e.currentTime), n.stop(e.currentTime + 0.15);
    },
    whoosh: (e, t) => {
      const n = e.sampleRate * 0.2, r = e.createBuffer(1, n, e.sampleRate), s = r.getChannelData(0);
      for (let l = 0; l < n; l++) s[l] = (Math.random() * 2 - 1) * (1 - l / n);
      const i = e.createBufferSource(), o = e.createGain(), a = e.createBiquadFilter();
      i.buffer = r, a.type = "bandpass", a.frequency.setValueAtTime(1e3, e.currentTime), a.frequency.exponentialRampToValueAtTime(3e3, e.currentTime + 0.1), i.connect(a), a.connect(o), o.connect(e.destination), o.gain.setValueAtTime(t * 0.1, e.currentTime), o.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.2), i.start(e.currentTime);
    },
    tick: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "sine", n.frequency.setValueAtTime(1e3, e.currentTime), r.gain.setValueAtTime(t * 0.1, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.02), n.start(e.currentTime), n.stop(e.currentTime + 0.02);
    },
    pop: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "sine", n.frequency.setValueAtTime(400, e.currentTime), n.frequency.exponentialRampToValueAtTime(150, e.currentTime + 0.08), r.gain.setValueAtTime(t * 0.3, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.08), n.start(e.currentTime), n.stop(e.currentTime + 0.08);
    },
    chime: (e, t) => {
      [
        880,
        1100,
        1320
      ].forEach((r, s) => {
        const i = e.createOscillator(), o = e.createGain();
        i.connect(o), o.connect(e.destination), i.type = "sine", i.frequency.setValueAtTime(r, e.currentTime);
        const a = t * (0.2 / (s + 1));
        o.gain.setValueAtTime(a, e.currentTime), o.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.5), i.start(e.currentTime), i.stop(e.currentTime + 0.5);
      });
    },
    off: (e, t) => {
      const n = e.createOscillator(), r = e.createGain();
      n.connect(r), r.connect(e.destination), n.type = "triangle", n.frequency.setValueAtTime(300, e.currentTime), n.frequency.exponentialRampToValueAtTime(50, e.currentTime + 0.3), r.gain.setValueAtTime(t * 0.2, e.currentTime), r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.3), n.start(e.currentTime), n.stop(e.currentTime + 0.3);
    }
  }, FI = () => typeof window > "u" ? false : window.matchMedia("(prefers-reduced-motion: reduce)").matches, zI = () => {
    if (typeof window > "u") return true;
    const e = localStorage.getItem("vaultbridge-sounds");
    return e === null ? true : e === "true";
  }, BI = (e) => {
    typeof window < "u" && localStorage.setItem("vaultbridge-sounds", String(e));
  };
  UI = function() {
    const e = h.useRef(null), t = h.useRef(zI());
    h.useEffect(() => {
      const o = () => {
        e.current || (e.current = Zy());
      }, a = () => {
        e.current?.state === "suspended" && e.current.resume(), o();
      };
      return window.addEventListener("click", a, {
        once: true
      }), window.addEventListener("touchstart", a, {
        once: true
      }), window.addEventListener("keydown", a, {
        once: true
      }), () => {
        window.removeEventListener("click", a), window.removeEventListener("touchstart", a), window.removeEventListener("keydown", a);
      };
    }, []);
    const n = h.useCallback((o, a = 1) => {
      if (!t.current || FI()) return;
      e.current || (e.current = Zy());
      const l = e.current;
      if (l) {
        l.state === "suspended" && l.resume();
        try {
          VI[o](l, Math.min(1, Math.max(0, a)));
        } catch (u) {
          console.warn("Sound playback failed:", u);
        }
      }
    }, []), r = h.useCallback((o) => {
      t.current = o, BI(o);
    }, []), s = h.useCallback(() => t.current, []), i = h.useCallback(() => {
      const o = !t.current;
      return r(o), o;
    }, [
      r
    ]);
    return {
      play: n,
      setEnabled: r,
      isEnabled: s,
      toggle: i
    };
  };
  var re;
  (function(e) {
    e.assertEqual = (s) => {
    };
    function t(s) {
    }
    e.assertIs = t;
    function n(s) {
      throw new Error();
    }
    e.assertNever = n, e.arrayToEnum = (s) => {
      const i = {};
      for (const o of s) i[o] = o;
      return i;
    }, e.getValidEnumValues = (s) => {
      const i = e.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
      for (const a of i) o[a] = s[a];
      return e.objectValues(o);
    }, e.objectValues = (s) => e.objectKeys(s).map(function(i) {
      return s[i];
    }), e.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
      const i = [];
      for (const o in s) Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
      return i;
    }, e.find = (s, i) => {
      for (const o of s) if (i(o)) return o;
    }, e.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
    function r(s, i = " | ") {
      return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
    }
    e.joinValues = r, e.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
  })(re || (re = {}));
  var pf;
  (function(e) {
    e.mergeShapes = (t, n) => ({
      ...t,
      ...n
    });
  })(pf || (pf = {}));
  const F = re.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]), Pn = (e) => {
    switch (typeof e) {
      case "undefined":
        return F.undefined;
      case "string":
        return F.string;
      case "number":
        return Number.isNaN(e) ? F.nan : F.number;
      case "boolean":
        return F.boolean;
      case "function":
        return F.function;
      case "bigint":
        return F.bigint;
      case "symbol":
        return F.symbol;
      case "object":
        return Array.isArray(e) ? F.array : e === null ? F.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? F.promise : typeof Map < "u" && e instanceof Map ? F.map : typeof Set < "u" && e instanceof Set ? F.set : typeof Date < "u" && e instanceof Date ? F.date : F.object;
      default:
        return F.unknown;
    }
  }, R = re.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]), $I = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
  class Pt extends Error {
    get errors() {
      return this.issues;
    }
    constructor(t) {
      super(), this.issues = [], this.addIssue = (r) => {
        this.issues = [
          ...this.issues,
          r
        ];
      }, this.addIssues = (r = []) => {
        this.issues = [
          ...this.issues,
          ...r
        ];
      };
      const n = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
    }
    format(t) {
      const n = t || function(i) {
        return i.message;
      }, r = {
        _errors: []
      }, s = (i) => {
        for (const o of i.issues) if (o.code === "invalid_union") o.unionErrors.map(s);
        else if (o.code === "invalid_return_type") s(o.returnTypeError);
        else if (o.code === "invalid_arguments") s(o.argumentsError);
        else if (o.path.length === 0) r._errors.push(n(o));
        else {
          let a = r, l = 0;
          for (; l < o.path.length; ) {
            const u = o.path[l];
            l === o.path.length - 1 ? (a[u] = a[u] || {
              _errors: []
            }, a[u]._errors.push(n(o))) : a[u] = a[u] || {
              _errors: []
            }, a = a[u], l++;
          }
        }
      };
      return s(this), r;
    }
    static assert(t) {
      if (!(t instanceof Pt)) throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, re.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(t = (n) => n.message) {
      const n = {}, r = [];
      for (const s of this.issues) if (s.path.length > 0) {
        const i = s.path[0];
        n[i] = n[i] || [], n[i].push(t(s));
      } else r.push(t(s));
      return {
        formErrors: r,
        fieldErrors: n
      };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  Pt.create = (e) => new Pt(e);
  const Ys = (e, t) => {
    let n;
    switch (e.code) {
      case R.invalid_type:
        e.received === F.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
        break;
      case R.invalid_literal:
        n = `Invalid literal value, expected ${JSON.stringify(e.expected, re.jsonStringifyReplacer)}`;
        break;
      case R.unrecognized_keys:
        n = `Unrecognized key(s) in object: ${re.joinValues(e.keys, ", ")}`;
        break;
      case R.invalid_union:
        n = "Invalid input";
        break;
      case R.invalid_union_discriminator:
        n = `Invalid discriminator value. Expected ${re.joinValues(e.options)}`;
        break;
      case R.invalid_enum_value:
        n = `Invalid enum value. Expected ${re.joinValues(e.options)}, received '${e.received}'`;
        break;
      case R.invalid_arguments:
        n = "Invalid function arguments";
        break;
      case R.invalid_return_type:
        n = "Invalid function return type";
        break;
      case R.invalid_date:
        n = "Invalid date";
        break;
      case R.invalid_string:
        typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : re.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
        break;
      case R.too_small:
        e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "bigint" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
        break;
      case R.too_big:
        e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
        break;
      case R.custom:
        n = "Invalid input";
        break;
      case R.invalid_intersection_types:
        n = "Intersection results could not be merged";
        break;
      case R.not_multiple_of:
        n = `Number must be a multiple of ${e.multipleOf}`;
        break;
      case R.not_finite:
        n = "Number must be finite";
        break;
      default:
        n = t.defaultError, re.assertNever(e);
    }
    return {
      message: n
    };
  };
  let _b = Ys;
  function WI(e) {
    _b = e;
  }
  function Dl() {
    return _b;
  }
  const Ml = (e) => {
    const { data: t, path: n, errorMaps: r, issueData: s } = e, i = [
      ...n,
      ...s.path || []
    ], o = {
      ...s,
      path: i
    };
    if (s.message !== void 0) return {
      ...s,
      path: i,
      message: s.message
    };
    let a = "";
    const l = r.filter((u) => !!u).slice().reverse();
    for (const u of l) a = u(o, {
      data: t,
      defaultError: a
    }).message;
    return {
      ...s,
      path: i,
      message: a
    };
  }, HI = [];
  function V(e, t) {
    const n = Dl(), r = Ml({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        e.schemaErrorMap,
        n,
        n === Ys ? void 0 : Ys
      ].filter((s) => !!s)
    });
    e.common.issues.push(r);
  }
  class nt {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, n) {
      const r = [];
      for (const s of n) {
        if (s.status === "aborted") return K;
        s.status === "dirty" && t.dirty(), r.push(s.value);
      }
      return {
        status: t.value,
        value: r
      };
    }
    static async mergeObjectAsync(t, n) {
      const r = [];
      for (const s of n) {
        const i = await s.key, o = await s.value;
        r.push({
          key: i,
          value: o
        });
      }
      return nt.mergeObjectSync(t, r);
    }
    static mergeObjectSync(t, n) {
      const r = {};
      for (const s of n) {
        const { key: i, value: o } = s;
        if (i.status === "aborted" || o.status === "aborted") return K;
        i.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
      }
      return {
        status: t.value,
        value: r
      };
    }
  }
  const K = Object.freeze({
    status: "aborted"
  }), Cs = (e) => ({
    status: "dirty",
    value: e
  }), at = (e) => ({
    status: "valid",
    value: e
  }), mf = (e) => e.status === "aborted", gf = (e) => e.status === "dirty", Gr = (e) => e.status === "valid", vo = (e) => typeof Promise < "u" && e instanceof Promise;
  var U;
  (function(e) {
    e.errToObj = (t) => typeof t == "string" ? {
      message: t
    } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
  })(U || (U = {}));
  class yn {
    constructor(t, n, r, s) {
      this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s;
    }
    get path() {
      return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const Yy = (e, t) => {
    if (Gr(t)) return {
      success: true,
      data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
      success: false,
      get error() {
        if (this._error) return this._error;
        const n = new Pt(e.common.issues);
        return this._error = n, this._error;
      }
    };
  };
  function Y(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: n, required_error: r, description: s } = e;
    if (t && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
      errorMap: t,
      description: s
    } : {
      errorMap: (o, a) => {
        const { message: l } = e;
        return o.code === "invalid_enum_value" ? {
          message: l ?? a.defaultError
        } : typeof a.data > "u" ? {
          message: l ?? r ?? a.defaultError
        } : o.code !== "invalid_type" ? {
          message: a.defaultError
        } : {
          message: l ?? n ?? a.defaultError
        };
      },
      description: s
    };
  }
  class ee {
    get description() {
      return this._def.description;
    }
    _getType(t) {
      return Pn(t.data);
    }
    _getOrReturnCtx(t, n) {
      return n || {
        common: t.parent.common,
        data: t.data,
        parsedType: Pn(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      };
    }
    _processInputParams(t) {
      return {
        status: new nt(),
        ctx: {
          common: t.parent.common,
          data: t.data,
          parsedType: Pn(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent
        }
      };
    }
    _parseSync(t) {
      const n = this._parse(t);
      if (vo(n)) throw new Error("Synchronous parse encountered promise.");
      return n;
    }
    _parseAsync(t) {
      const n = this._parse(t);
      return Promise.resolve(n);
    }
    parse(t, n) {
      const r = this.safeParse(t, n);
      if (r.success) return r.data;
      throw r.error;
    }
    safeParse(t, n) {
      const r = {
        common: {
          issues: [],
          async: n?.async ?? false,
          contextualErrorMap: n?.errorMap
        },
        path: n?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Pn(t)
      }, s = this._parseSync({
        data: t,
        path: r.path,
        parent: r
      });
      return Yy(r, s);
    }
    "~validate"(t) {
      const n = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Pn(t)
      };
      if (!this["~standard"].async) try {
        const r = this._parseSync({
          data: t,
          path: [],
          parent: n
        });
        return Gr(r) ? {
          value: r.value
        } : {
          issues: n.common.issues
        };
      } catch (r) {
        r?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = true), n.common = {
          issues: [],
          async: true
        };
      }
      return this._parseAsync({
        data: t,
        path: [],
        parent: n
      }).then((r) => Gr(r) ? {
        value: r.value
      } : {
        issues: n.common.issues
      });
    }
    async parseAsync(t, n) {
      const r = await this.safeParseAsync(t, n);
      if (r.success) return r.data;
      throw r.error;
    }
    async safeParseAsync(t, n) {
      const r = {
        common: {
          issues: [],
          contextualErrorMap: n?.errorMap,
          async: true
        },
        path: n?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Pn(t)
      }, s = this._parse({
        data: t,
        path: r.path,
        parent: r
      }), i = await (vo(s) ? s : Promise.resolve(s));
      return Yy(r, i);
    }
    refine(t, n) {
      const r = (s) => typeof n == "string" || typeof n > "u" ? {
        message: n
      } : typeof n == "function" ? n(s) : n;
      return this._refinement((s, i) => {
        const o = t(s), a = () => i.addIssue({
          code: R.custom,
          ...r(s)
        });
        return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? true : (a(), false)) : o ? true : (a(), false);
      });
    }
    refinement(t, n) {
      return this._refinement((r, s) => t(r) ? true : (s.addIssue(typeof n == "function" ? n(r, s) : n), false));
    }
    _refinement(t) {
      return new en({
        schema: this,
        typeName: G.ZodEffects,
        effect: {
          type: "refinement",
          refinement: t
        }
      });
    }
    superRefine(t) {
      return this._refinement(t);
    }
    constructor(t) {
      this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (n) => this["~validate"](n)
      };
    }
    optional() {
      return pn.create(this, this._def);
    }
    nullable() {
      return wr.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Zt.create(this);
    }
    promise() {
      return Js.create(this, this._def);
    }
    or(t) {
      return bo.create([
        this,
        t
      ], this._def);
    }
    and(t) {
      return To.create(this, t, this._def);
    }
    transform(t) {
      return new en({
        ...Y(this._def),
        schema: this,
        typeName: G.ZodEffects,
        effect: {
          type: "transform",
          transform: t
        }
      });
    }
    default(t) {
      const n = typeof t == "function" ? t : () => t;
      return new _o({
        ...Y(this._def),
        innerType: this,
        defaultValue: n,
        typeName: G.ZodDefault
      });
    }
    brand() {
      return new Ep({
        typeName: G.ZodBranded,
        type: this,
        ...Y(this._def)
      });
    }
    catch(t) {
      const n = typeof t == "function" ? t : () => t;
      return new Ao({
        ...Y(this._def),
        innerType: this,
        catchValue: n,
        typeName: G.ZodCatch
      });
    }
    describe(t) {
      const n = this.constructor;
      return new n({
        ...this._def,
        description: t
      });
    }
    pipe(t) {
      return Qo.create(this, t);
    }
    readonly() {
      return Ro.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const KI = /^c[^\s-]{8,}$/i, QI = /^[0-9a-z]+$/, GI = /^[0-9A-HJKMNP-TV-Z]{26}$/i, qI = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, ZI = /^[a-z0-9_-]{21}$/i, YI = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, XI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, JI = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, eL = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let Pc;
  const tL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, nL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, rL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, sL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, iL = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, oL = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Ab = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", aL = new RegExp(`^${Ab}$`);
  function Rb(e) {
    let t = "[0-5]\\d";
    e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`);
    const n = e.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${n}`;
  }
  function lL(e) {
    return new RegExp(`^${Rb(e)}$`);
  }
  function Nb(e) {
    let t = `${Ab}T${Rb(e)}`;
    const n = [];
    return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
  }
  function uL(e, t) {
    return !!((t === "v4" || !t) && tL.test(e) || (t === "v6" || !t) && rL.test(e));
  }
  function cL(e, t) {
    if (!YI.test(e)) return false;
    try {
      const [n] = e.split(".");
      if (!n) return false;
      const r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r));
      return !(typeof s != "object" || s === null || "typ" in s && s?.typ !== "JWT" || !s.alg || t && s.alg !== t);
    } catch {
      return false;
    }
  }
  function dL(e, t) {
    return !!((t === "v4" || !t) && nL.test(e) || (t === "v6" || !t) && sL.test(e));
  }
  class Qt extends ee {
    _parse(t) {
      if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== F.string) {
        const i = this._getOrReturnCtx(t);
        return V(i, {
          code: R.invalid_type,
          expected: F.string,
          received: i.parsedType
        }), K;
      }
      const r = new nt();
      let s;
      for (const i of this._def.checks) if (i.kind === "min") t.data.length < i.value && (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.too_small,
        minimum: i.value,
        type: "string",
        inclusive: true,
        exact: false,
        message: i.message
      }), r.dirty());
      else if (i.kind === "max") t.data.length > i.value && (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.too_big,
        maximum: i.value,
        type: "string",
        inclusive: true,
        exact: false,
        message: i.message
      }), r.dirty());
      else if (i.kind === "length") {
        const o = t.data.length > i.value, a = t.data.length < i.value;
        (o || a) && (s = this._getOrReturnCtx(t, s), o ? V(s, {
          code: R.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }) : a && V(s, {
          code: R.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email") JI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "email",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "emoji") Pc || (Pc = new RegExp(eL, "u")), Pc.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "emoji",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "uuid") qI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "uuid",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "nanoid") ZI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "nanoid",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "cuid") KI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "cuid",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "cuid2") QI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "cuid2",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "ulid") GI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "ulid",
        code: R.invalid_string,
        message: i.message
      }), r.dirty());
      else if (i.kind === "url") try {
        new URL(t.data);
      } catch {
        s = this._getOrReturnCtx(t, s), V(s, {
          validation: "url",
          code: R.invalid_string,
          message: i.message
        }), r.dirty();
      }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "regex",
        code: R.invalid_string,
        message: i.message
      }), r.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: {
          includes: i.value,
          position: i.position
        },
        message: i.message
      }), r.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: {
          startsWith: i.value
        },
        message: i.message
      }), r.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: {
          endsWith: i.value
        },
        message: i.message
      }), r.dirty()) : i.kind === "datetime" ? Nb(i).test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: "datetime",
        message: i.message
      }), r.dirty()) : i.kind === "date" ? aL.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: "date",
        message: i.message
      }), r.dirty()) : i.kind === "time" ? lL(i).test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.invalid_string,
        validation: "time",
        message: i.message
      }), r.dirty()) : i.kind === "duration" ? XI.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "duration",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "ip" ? uL(t.data, i.version) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "ip",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "jwt" ? cL(t.data, i.alg) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "jwt",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "cidr" ? dL(t.data, i.version) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "cidr",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64" ? iL.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "base64",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64url" ? oL.test(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        validation: "base64url",
        code: R.invalid_string,
        message: i.message
      }), r.dirty()) : re.assertNever(i);
      return {
        status: r.value,
        value: t.data
      };
    }
    _regex(t, n, r) {
      return this.refinement((s) => t.test(s), {
        validation: n,
        code: R.invalid_string,
        ...U.errToObj(r)
      });
    }
    _addCheck(t) {
      return new Qt({
        ...this._def,
        checks: [
          ...this._def.checks,
          t
        ]
      });
    }
    email(t) {
      return this._addCheck({
        kind: "email",
        ...U.errToObj(t)
      });
    }
    url(t) {
      return this._addCheck({
        kind: "url",
        ...U.errToObj(t)
      });
    }
    emoji(t) {
      return this._addCheck({
        kind: "emoji",
        ...U.errToObj(t)
      });
    }
    uuid(t) {
      return this._addCheck({
        kind: "uuid",
        ...U.errToObj(t)
      });
    }
    nanoid(t) {
      return this._addCheck({
        kind: "nanoid",
        ...U.errToObj(t)
      });
    }
    cuid(t) {
      return this._addCheck({
        kind: "cuid",
        ...U.errToObj(t)
      });
    }
    cuid2(t) {
      return this._addCheck({
        kind: "cuid2",
        ...U.errToObj(t)
      });
    }
    ulid(t) {
      return this._addCheck({
        kind: "ulid",
        ...U.errToObj(t)
      });
    }
    base64(t) {
      return this._addCheck({
        kind: "base64",
        ...U.errToObj(t)
      });
    }
    base64url(t) {
      return this._addCheck({
        kind: "base64url",
        ...U.errToObj(t)
      });
    }
    jwt(t) {
      return this._addCheck({
        kind: "jwt",
        ...U.errToObj(t)
      });
    }
    ip(t) {
      return this._addCheck({
        kind: "ip",
        ...U.errToObj(t)
      });
    }
    cidr(t) {
      return this._addCheck({
        kind: "cidr",
        ...U.errToObj(t)
      });
    }
    datetime(t) {
      return typeof t == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: t
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        offset: t?.offset ?? false,
        local: t?.local ?? false,
        ...U.errToObj(t?.message)
      });
    }
    date(t) {
      return this._addCheck({
        kind: "date",
        message: t
      });
    }
    time(t) {
      return typeof t == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: t
      }) : this._addCheck({
        kind: "time",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        ...U.errToObj(t?.message)
      });
    }
    duration(t) {
      return this._addCheck({
        kind: "duration",
        ...U.errToObj(t)
      });
    }
    regex(t, n) {
      return this._addCheck({
        kind: "regex",
        regex: t,
        ...U.errToObj(n)
      });
    }
    includes(t, n) {
      return this._addCheck({
        kind: "includes",
        value: t,
        position: n?.position,
        ...U.errToObj(n?.message)
      });
    }
    startsWith(t, n) {
      return this._addCheck({
        kind: "startsWith",
        value: t,
        ...U.errToObj(n)
      });
    }
    endsWith(t, n) {
      return this._addCheck({
        kind: "endsWith",
        value: t,
        ...U.errToObj(n)
      });
    }
    min(t, n) {
      return this._addCheck({
        kind: "min",
        value: t,
        ...U.errToObj(n)
      });
    }
    max(t, n) {
      return this._addCheck({
        kind: "max",
        value: t,
        ...U.errToObj(n)
      });
    }
    length(t, n) {
      return this._addCheck({
        kind: "length",
        value: t,
        ...U.errToObj(n)
      });
    }
    nonempty(t) {
      return this.min(1, U.errToObj(t));
    }
    trim() {
      return new Qt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "trim"
          }
        ]
      });
    }
    toLowerCase() {
      return new Qt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "toLowerCase"
          }
        ]
      });
    }
    toUpperCase() {
      return new Qt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "toUpperCase"
          }
        ]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((t) => t.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((t) => t.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((t) => t.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((t) => t.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((t) => t.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((t) => t.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((t) => t.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((t) => t.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((t) => t.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((t) => t.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((t) => t.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((t) => t.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((t) => t.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((t) => t.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((t) => t.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((t) => t.kind === "base64url");
    }
    get minLength() {
      let t = null;
      for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
      return t;
    }
    get maxLength() {
      let t = null;
      for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      return t;
    }
  }
  Qt.create = (e) => new Qt({
    checks: [],
    typeName: G.ZodString,
    coerce: e?.coerce ?? false,
    ...Y(e)
  });
  function fL(e, t) {
    const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, s = n > r ? n : r, i = Number.parseInt(e.toFixed(s).replace(".", "")), o = Number.parseInt(t.toFixed(s).replace(".", ""));
    return i % o / 10 ** s;
  }
  class gr extends ee {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
      if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== F.number) {
        const i = this._getOrReturnCtx(t);
        return V(i, {
          code: R.invalid_type,
          expected: F.number,
          received: i.parsedType
        }), K;
      }
      let r;
      const s = new nt();
      for (const i of this._def.checks) i.kind === "int" ? re.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? fL(t.data, i.value) !== 0 && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.not_finite,
        message: i.message
      }), s.dirty()) : re.assertNever(i);
      return {
        status: s.value,
        value: t.data
      };
    }
    gte(t, n) {
      return this.setLimit("min", t, true, U.toString(n));
    }
    gt(t, n) {
      return this.setLimit("min", t, false, U.toString(n));
    }
    lte(t, n) {
      return this.setLimit("max", t, true, U.toString(n));
    }
    lt(t, n) {
      return this.setLimit("max", t, false, U.toString(n));
    }
    setLimit(t, n, r, s) {
      return new gr({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: n,
            inclusive: r,
            message: U.toString(s)
          }
        ]
      });
    }
    _addCheck(t) {
      return new gr({
        ...this._def,
        checks: [
          ...this._def.checks,
          t
        ]
      });
    }
    int(t) {
      return this._addCheck({
        kind: "int",
        message: U.toString(t)
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: U.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: U.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: U.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: U.toString(t)
      });
    }
    multipleOf(t, n) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: U.toString(n)
      });
    }
    finite(t) {
      return this._addCheck({
        kind: "finite",
        message: U.toString(t)
      });
    }
    safe(t) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: U.toString(t)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: U.toString(t)
      });
    }
    get minValue() {
      let t = null;
      for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      return t;
    }
    get isInt() {
      return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && re.isInteger(t.value));
    }
    get isFinite() {
      let t = null, n = null;
      for (const r of this._def.checks) {
        if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return true;
        r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      }
      return Number.isFinite(n) && Number.isFinite(t);
    }
  }
  gr.create = (e) => new gr({
    checks: [],
    typeName: G.ZodNumber,
    coerce: e?.coerce || false,
    ...Y(e)
  });
  class yr extends ee {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
      if (this._def.coerce) try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
      if (this._getType(t) !== F.bigint) return this._getInvalidInput(t);
      let r;
      const s = new nt();
      for (const i of this._def.checks) i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), V(r, {
        code: R.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : re.assertNever(i);
      return {
        status: s.value,
        value: t.data
      };
    }
    _getInvalidInput(t) {
      const n = this._getOrReturnCtx(t);
      return V(n, {
        code: R.invalid_type,
        expected: F.bigint,
        received: n.parsedType
      }), K;
    }
    gte(t, n) {
      return this.setLimit("min", t, true, U.toString(n));
    }
    gt(t, n) {
      return this.setLimit("min", t, false, U.toString(n));
    }
    lte(t, n) {
      return this.setLimit("max", t, true, U.toString(n));
    }
    lt(t, n) {
      return this.setLimit("max", t, false, U.toString(n));
    }
    setLimit(t, n, r, s) {
      return new yr({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: n,
            inclusive: r,
            message: U.toString(s)
          }
        ]
      });
    }
    _addCheck(t) {
      return new yr({
        ...this._def,
        checks: [
          ...this._def.checks,
          t
        ]
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: U.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: U.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: U.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: U.toString(t)
      });
    }
    multipleOf(t, n) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: U.toString(n)
      });
    }
    get minValue() {
      let t = null;
      for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      return t;
    }
  }
  yr.create = (e) => new yr({
    checks: [],
    typeName: G.ZodBigInt,
    coerce: e?.coerce ?? false,
    ...Y(e)
  });
  class wo extends ee {
    _parse(t) {
      if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== F.boolean) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.boolean,
          received: r.parsedType
        }), K;
      }
      return at(t.data);
    }
  }
  wo.create = (e) => new wo({
    typeName: G.ZodBoolean,
    coerce: e?.coerce || false,
    ...Y(e)
  });
  class qr extends ee {
    _parse(t) {
      if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== F.date) {
        const i = this._getOrReturnCtx(t);
        return V(i, {
          code: R.invalid_type,
          expected: F.date,
          received: i.parsedType
        }), K;
      }
      if (Number.isNaN(t.data.getTime())) {
        const i = this._getOrReturnCtx(t);
        return V(i, {
          code: R.invalid_date
        }), K;
      }
      const r = new nt();
      let s;
      for (const i of this._def.checks) i.kind === "min" ? t.data.getTime() < i.value && (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.too_small,
        message: i.message,
        inclusive: true,
        exact: false,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (s = this._getOrReturnCtx(t, s), V(s, {
        code: R.too_big,
        message: i.message,
        inclusive: true,
        exact: false,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : re.assertNever(i);
      return {
        status: r.value,
        value: new Date(t.data.getTime())
      };
    }
    _addCheck(t) {
      return new qr({
        ...this._def,
        checks: [
          ...this._def.checks,
          t
        ]
      });
    }
    min(t, n) {
      return this._addCheck({
        kind: "min",
        value: t.getTime(),
        message: U.toString(n)
      });
    }
    max(t, n) {
      return this._addCheck({
        kind: "max",
        value: t.getTime(),
        message: U.toString(n)
      });
    }
    get minDate() {
      let t = null;
      for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
      return t != null ? new Date(t) : null;
    }
    get maxDate() {
      let t = null;
      for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      return t != null ? new Date(t) : null;
    }
  }
  qr.create = (e) => new qr({
    checks: [],
    coerce: e?.coerce || false,
    typeName: G.ZodDate,
    ...Y(e)
  });
  class Ol extends ee {
    _parse(t) {
      if (this._getType(t) !== F.symbol) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.symbol,
          received: r.parsedType
        }), K;
      }
      return at(t.data);
    }
  }
  Ol.create = (e) => new Ol({
    typeName: G.ZodSymbol,
    ...Y(e)
  });
  class xo extends ee {
    _parse(t) {
      if (this._getType(t) !== F.undefined) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.undefined,
          received: r.parsedType
        }), K;
      }
      return at(t.data);
    }
  }
  xo.create = (e) => new xo({
    typeName: G.ZodUndefined,
    ...Y(e)
  });
  class So extends ee {
    _parse(t) {
      if (this._getType(t) !== F.null) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.null,
          received: r.parsedType
        }), K;
      }
      return at(t.data);
    }
  }
  So.create = (e) => new So({
    typeName: G.ZodNull,
    ...Y(e)
  });
  class Xs extends ee {
    constructor() {
      super(...arguments), this._any = true;
    }
    _parse(t) {
      return at(t.data);
    }
  }
  Xs.create = (e) => new Xs({
    typeName: G.ZodAny,
    ...Y(e)
  });
  class Vr extends ee {
    constructor() {
      super(...arguments), this._unknown = true;
    }
    _parse(t) {
      return at(t.data);
    }
  }
  Vr.create = (e) => new Vr({
    typeName: G.ZodUnknown,
    ...Y(e)
  });
  class Bn extends ee {
    _parse(t) {
      const n = this._getOrReturnCtx(t);
      return V(n, {
        code: R.invalid_type,
        expected: F.never,
        received: n.parsedType
      }), K;
    }
  }
  Bn.create = (e) => new Bn({
    typeName: G.ZodNever,
    ...Y(e)
  });
  class Il extends ee {
    _parse(t) {
      if (this._getType(t) !== F.undefined) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.void,
          received: r.parsedType
        }), K;
      }
      return at(t.data);
    }
  }
  Il.create = (e) => new Il({
    typeName: G.ZodVoid,
    ...Y(e)
  });
  class Zt extends ee {
    _parse(t) {
      const { ctx: n, status: r } = this._processInputParams(t), s = this._def;
      if (n.parsedType !== F.array) return V(n, {
        code: R.invalid_type,
        expected: F.array,
        received: n.parsedType
      }), K;
      if (s.exactLength !== null) {
        const o = n.data.length > s.exactLength.value, a = n.data.length < s.exactLength.value;
        (o || a) && (V(n, {
          code: o ? R.too_big : R.too_small,
          minimum: a ? s.exactLength.value : void 0,
          maximum: o ? s.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: s.exactLength.message
        }), r.dirty());
      }
      if (s.minLength !== null && n.data.length < s.minLength.value && (V(n, {
        code: R.too_small,
        minimum: s.minLength.value,
        type: "array",
        inclusive: true,
        exact: false,
        message: s.minLength.message
      }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (V(n, {
        code: R.too_big,
        maximum: s.maxLength.value,
        type: "array",
        inclusive: true,
        exact: false,
        message: s.maxLength.message
      }), r.dirty()), n.common.async) return Promise.all([
        ...n.data
      ].map((o, a) => s.type._parseAsync(new yn(n, o, n.path, a)))).then((o) => nt.mergeArray(r, o));
      const i = [
        ...n.data
      ].map((o, a) => s.type._parseSync(new yn(n, o, n.path, a)));
      return nt.mergeArray(r, i);
    }
    get element() {
      return this._def.type;
    }
    min(t, n) {
      return new Zt({
        ...this._def,
        minLength: {
          value: t,
          message: U.toString(n)
        }
      });
    }
    max(t, n) {
      return new Zt({
        ...this._def,
        maxLength: {
          value: t,
          message: U.toString(n)
        }
      });
    }
    length(t, n) {
      return new Zt({
        ...this._def,
        exactLength: {
          value: t,
          message: U.toString(n)
        }
      });
    }
    nonempty(t) {
      return this.min(1, t);
    }
  }
  Zt.create = (e, t) => new Zt({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: G.ZodArray,
    ...Y(t)
  });
  function is(e) {
    if (e instanceof xe) {
      const t = {};
      for (const n in e.shape) {
        const r = e.shape[n];
        t[n] = pn.create(is(r));
      }
      return new xe({
        ...e._def,
        shape: () => t
      });
    } else return e instanceof Zt ? new Zt({
      ...e._def,
      type: is(e.element)
    }) : e instanceof pn ? pn.create(is(e.unwrap())) : e instanceof wr ? wr.create(is(e.unwrap())) : e instanceof vn ? vn.create(e.items.map((t) => is(t))) : e;
  }
  class xe extends ee {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const t = this._def.shape(), n = re.objectKeys(t);
      return this._cached = {
        shape: t,
        keys: n
      }, this._cached;
    }
    _parse(t) {
      if (this._getType(t) !== F.object) {
        const u = this._getOrReturnCtx(t);
        return V(u, {
          code: R.invalid_type,
          expected: F.object,
          received: u.parsedType
        }), K;
      }
      const { status: r, ctx: s } = this._processInputParams(t), { shape: i, keys: o } = this._getCached(), a = [];
      if (!(this._def.catchall instanceof Bn && this._def.unknownKeys === "strip")) for (const u in s.data) o.includes(u) || a.push(u);
      const l = [];
      for (const u of o) {
        const c = i[u], d = s.data[u];
        l.push({
          key: {
            status: "valid",
            value: u
          },
          value: c._parse(new yn(s, d, s.path, u)),
          alwaysSet: u in s.data
        });
      }
      if (this._def.catchall instanceof Bn) {
        const u = this._def.unknownKeys;
        if (u === "passthrough") for (const c of a) l.push({
          key: {
            status: "valid",
            value: c
          },
          value: {
            status: "valid",
            value: s.data[c]
          }
        });
        else if (u === "strict") a.length > 0 && (V(s, {
          code: R.unrecognized_keys,
          keys: a
        }), r.dirty());
        else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const u = this._def.catchall;
        for (const c of a) {
          const d = s.data[c];
          l.push({
            key: {
              status: "valid",
              value: c
            },
            value: u._parse(new yn(s, d, s.path, c)),
            alwaysSet: c in s.data
          });
        }
      }
      return s.common.async ? Promise.resolve().then(async () => {
        const u = [];
        for (const c of l) {
          const d = await c.key, f = await c.value;
          u.push({
            key: d,
            value: f,
            alwaysSet: c.alwaysSet
          });
        }
        return u;
      }).then((u) => nt.mergeObjectSync(r, u)) : nt.mergeObjectSync(r, l);
    }
    get shape() {
      return this._def.shape();
    }
    strict(t) {
      return U.errToObj, new xe({
        ...this._def,
        unknownKeys: "strict",
        ...t !== void 0 ? {
          errorMap: (n, r) => {
            const s = this._def.errorMap?.(n, r).message ?? r.defaultError;
            return n.code === "unrecognized_keys" ? {
              message: U.errToObj(t).message ?? s
            } : {
              message: s
            };
          }
        } : {}
      });
    }
    strip() {
      return new xe({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new xe({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(t) {
      return new xe({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...t
        })
      });
    }
    merge(t) {
      return new xe({
        unknownKeys: t._def.unknownKeys,
        catchall: t._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...t._def.shape()
        }),
        typeName: G.ZodObject
      });
    }
    setKey(t, n) {
      return this.augment({
        [t]: n
      });
    }
    catchall(t) {
      return new xe({
        ...this._def,
        catchall: t
      });
    }
    pick(t) {
      const n = {};
      for (const r of re.objectKeys(t)) t[r] && this.shape[r] && (n[r] = this.shape[r]);
      return new xe({
        ...this._def,
        shape: () => n
      });
    }
    omit(t) {
      const n = {};
      for (const r of re.objectKeys(this.shape)) t[r] || (n[r] = this.shape[r]);
      return new xe({
        ...this._def,
        shape: () => n
      });
    }
    deepPartial() {
      return is(this);
    }
    partial(t) {
      const n = {};
      for (const r of re.objectKeys(this.shape)) {
        const s = this.shape[r];
        t && !t[r] ? n[r] = s : n[r] = s.optional();
      }
      return new xe({
        ...this._def,
        shape: () => n
      });
    }
    required(t) {
      const n = {};
      for (const r of re.objectKeys(this.shape)) if (t && !t[r]) n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof pn; ) i = i._def.innerType;
        n[r] = i;
      }
      return new xe({
        ...this._def,
        shape: () => n
      });
    }
    keyof() {
      return Db(re.objectKeys(this.shape));
    }
  }
  xe.create = (e, t) => new xe({
    shape: () => e,
    unknownKeys: "strip",
    catchall: Bn.create(),
    typeName: G.ZodObject,
    ...Y(t)
  });
  xe.strictCreate = (e, t) => new xe({
    shape: () => e,
    unknownKeys: "strict",
    catchall: Bn.create(),
    typeName: G.ZodObject,
    ...Y(t)
  });
  xe.lazycreate = (e, t) => new xe({
    shape: e,
    unknownKeys: "strip",
    catchall: Bn.create(),
    typeName: G.ZodObject,
    ...Y(t)
  });
  class bo extends ee {
    _parse(t) {
      const { ctx: n } = this._processInputParams(t), r = this._def.options;
      function s(i) {
        for (const a of i) if (a.result.status === "valid") return a.result;
        for (const a of i) if (a.result.status === "dirty") return n.common.issues.push(...a.ctx.common.issues), a.result;
        const o = i.map((a) => new Pt(a.ctx.common.issues));
        return V(n, {
          code: R.invalid_union,
          unionErrors: o
        }), K;
      }
      if (n.common.async) return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
      {
        let i;
        const o = [];
        for (const l of r) {
          const u = {
            ...n,
            common: {
              ...n.common,
              issues: []
            },
            parent: null
          }, c = l._parseSync({
            data: n.data,
            path: n.path,
            parent: u
          });
          if (c.status === "valid") return c;
          c.status === "dirty" && !i && (i = {
            result: c,
            ctx: u
          }), u.common.issues.length && o.push(u.common.issues);
        }
        if (i) return n.common.issues.push(...i.ctx.common.issues), i.result;
        const a = o.map((l) => new Pt(l));
        return V(n, {
          code: R.invalid_union,
          unionErrors: a
        }), K;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  bo.create = (e, t) => new bo({
    options: e,
    typeName: G.ZodUnion,
    ...Y(t)
  });
  const bn = (e) => e instanceof Eo ? bn(e.schema) : e instanceof en ? bn(e.innerType()) : e instanceof Po ? [
    e.value
  ] : e instanceof vr ? e.options : e instanceof ko ? re.objectValues(e.enum) : e instanceof _o ? bn(e._def.innerType) : e instanceof xo ? [
    void 0
  ] : e instanceof So ? [
    null
  ] : e instanceof pn ? [
    void 0,
    ...bn(e.unwrap())
  ] : e instanceof wr ? [
    null,
    ...bn(e.unwrap())
  ] : e instanceof Ep || e instanceof Ro ? bn(e.unwrap()) : e instanceof Ao ? bn(e._def.innerType) : [];
  class Cu extends ee {
    _parse(t) {
      const { ctx: n } = this._processInputParams(t);
      if (n.parsedType !== F.object) return V(n, {
        code: R.invalid_type,
        expected: F.object,
        received: n.parsedType
      }), K;
      const r = this.discriminator, s = n.data[r], i = this.optionsMap.get(s);
      return i ? n.common.async ? i._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }) : i._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      }) : (V(n, {
        code: R.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [
          r
        ]
      }), K);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(t, n, r) {
      const s = /* @__PURE__ */ new Map();
      for (const i of n) {
        const o = bn(i.shape[t]);
        if (!o.length) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
        for (const a of o) {
          if (s.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
          s.set(a, i);
        }
      }
      return new Cu({
        typeName: G.ZodDiscriminatedUnion,
        discriminator: t,
        options: n,
        optionsMap: s,
        ...Y(r)
      });
    }
  }
  function yf(e, t) {
    const n = Pn(e), r = Pn(t);
    if (e === t) return {
      valid: true,
      data: e
    };
    if (n === F.object && r === F.object) {
      const s = re.objectKeys(t), i = re.objectKeys(e).filter((a) => s.indexOf(a) !== -1), o = {
        ...e,
        ...t
      };
      for (const a of i) {
        const l = yf(e[a], t[a]);
        if (!l.valid) return {
          valid: false
        };
        o[a] = l.data;
      }
      return {
        valid: true,
        data: o
      };
    } else if (n === F.array && r === F.array) {
      if (e.length !== t.length) return {
        valid: false
      };
      const s = [];
      for (let i = 0; i < e.length; i++) {
        const o = e[i], a = t[i], l = yf(o, a);
        if (!l.valid) return {
          valid: false
        };
        s.push(l.data);
      }
      return {
        valid: true,
        data: s
      };
    } else return n === F.date && r === F.date && +e == +t ? {
      valid: true,
      data: e
    } : {
      valid: false
    };
  }
  class To extends ee {
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t), s = (i, o) => {
        if (mf(i) || mf(o)) return K;
        const a = yf(i.value, o.value);
        return a.valid ? ((gf(i) || gf(o)) && n.dirty(), {
          status: n.value,
          value: a.data
        }) : (V(r, {
          code: R.invalid_intersection_types
        }), K);
      };
      return r.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        }),
        this._def.right._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        })
      ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }), this._def.right._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }));
    }
  }
  To.create = (e, t, n) => new To({
    left: e,
    right: t,
    typeName: G.ZodIntersection,
    ...Y(n)
  });
  class vn extends ee {
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t);
      if (r.parsedType !== F.array) return V(r, {
        code: R.invalid_type,
        expected: F.array,
        received: r.parsedType
      }), K;
      if (r.data.length < this._def.items.length) return V(r, {
        code: R.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), K;
      !this._def.rest && r.data.length > this._def.items.length && (V(r, {
        code: R.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), n.dirty());
      const i = [
        ...r.data
      ].map((o, a) => {
        const l = this._def.items[a] || this._def.rest;
        return l ? l._parse(new yn(r, o, r.path, a)) : null;
      }).filter((o) => !!o);
      return r.common.async ? Promise.all(i).then((o) => nt.mergeArray(n, o)) : nt.mergeArray(n, i);
    }
    get items() {
      return this._def.items;
    }
    rest(t) {
      return new vn({
        ...this._def,
        rest: t
      });
    }
  }
  vn.create = (e, t) => {
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new vn({
      items: e,
      typeName: G.ZodTuple,
      rest: null,
      ...Y(t)
    });
  };
  class Co extends ee {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t);
      if (r.parsedType !== F.object) return V(r, {
        code: R.invalid_type,
        expected: F.object,
        received: r.parsedType
      }), K;
      const s = [], i = this._def.keyType, o = this._def.valueType;
      for (const a in r.data) s.push({
        key: i._parse(new yn(r, a, r.path, a)),
        value: o._parse(new yn(r, r.data[a], r.path, a)),
        alwaysSet: a in r.data
      });
      return r.common.async ? nt.mergeObjectAsync(n, s) : nt.mergeObjectSync(n, s);
    }
    get element() {
      return this._def.valueType;
    }
    static create(t, n, r) {
      return n instanceof ee ? new Co({
        keyType: t,
        valueType: n,
        typeName: G.ZodRecord,
        ...Y(r)
      }) : new Co({
        keyType: Qt.create(),
        valueType: t,
        typeName: G.ZodRecord,
        ...Y(n)
      });
    }
  }
  class Ll extends ee {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t);
      if (r.parsedType !== F.map) return V(r, {
        code: R.invalid_type,
        expected: F.map,
        received: r.parsedType
      }), K;
      const s = this._def.keyType, i = this._def.valueType, o = [
        ...r.data.entries()
      ].map(([a, l], u) => ({
        key: s._parse(new yn(r, a, r.path, [
          u,
          "key"
        ])),
        value: i._parse(new yn(r, l, r.path, [
          u,
          "value"
        ]))
      }));
      if (r.common.async) {
        const a = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const l of o) {
            const u = await l.key, c = await l.value;
            if (u.status === "aborted" || c.status === "aborted") return K;
            (u.status === "dirty" || c.status === "dirty") && n.dirty(), a.set(u.value, c.value);
          }
          return {
            status: n.value,
            value: a
          };
        });
      } else {
        const a = /* @__PURE__ */ new Map();
        for (const l of o) {
          const u = l.key, c = l.value;
          if (u.status === "aborted" || c.status === "aborted") return K;
          (u.status === "dirty" || c.status === "dirty") && n.dirty(), a.set(u.value, c.value);
        }
        return {
          status: n.value,
          value: a
        };
      }
    }
  }
  Ll.create = (e, t, n) => new Ll({
    valueType: t,
    keyType: e,
    typeName: G.ZodMap,
    ...Y(n)
  });
  class Zr extends ee {
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t);
      if (r.parsedType !== F.set) return V(r, {
        code: R.invalid_type,
        expected: F.set,
        received: r.parsedType
      }), K;
      const s = this._def;
      s.minSize !== null && r.data.size < s.minSize.value && (V(r, {
        code: R.too_small,
        minimum: s.minSize.value,
        type: "set",
        inclusive: true,
        exact: false,
        message: s.minSize.message
      }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (V(r, {
        code: R.too_big,
        maximum: s.maxSize.value,
        type: "set",
        inclusive: true,
        exact: false,
        message: s.maxSize.message
      }), n.dirty());
      const i = this._def.valueType;
      function o(l) {
        const u = /* @__PURE__ */ new Set();
        for (const c of l) {
          if (c.status === "aborted") return K;
          c.status === "dirty" && n.dirty(), u.add(c.value);
        }
        return {
          status: n.value,
          value: u
        };
      }
      const a = [
        ...r.data.values()
      ].map((l, u) => i._parse(new yn(r, l, r.path, u)));
      return r.common.async ? Promise.all(a).then((l) => o(l)) : o(a);
    }
    min(t, n) {
      return new Zr({
        ...this._def,
        minSize: {
          value: t,
          message: U.toString(n)
        }
      });
    }
    max(t, n) {
      return new Zr({
        ...this._def,
        maxSize: {
          value: t,
          message: U.toString(n)
        }
      });
    }
    size(t, n) {
      return this.min(t, n).max(t, n);
    }
    nonempty(t) {
      return this.min(1, t);
    }
  }
  Zr.create = (e, t) => new Zr({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: G.ZodSet,
    ...Y(t)
  });
  class Ms extends ee {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
      const { ctx: n } = this._processInputParams(t);
      if (n.parsedType !== F.function) return V(n, {
        code: R.invalid_type,
        expected: F.function,
        received: n.parsedType
      }), K;
      function r(a, l) {
        return Ml({
          data: a,
          path: n.path,
          errorMaps: [
            n.common.contextualErrorMap,
            n.schemaErrorMap,
            Dl(),
            Ys
          ].filter((u) => !!u),
          issueData: {
            code: R.invalid_arguments,
            argumentsError: l
          }
        });
      }
      function s(a, l) {
        return Ml({
          data: a,
          path: n.path,
          errorMaps: [
            n.common.contextualErrorMap,
            n.schemaErrorMap,
            Dl(),
            Ys
          ].filter((u) => !!u),
          issueData: {
            code: R.invalid_return_type,
            returnTypeError: l
          }
        });
      }
      const i = {
        errorMap: n.common.contextualErrorMap
      }, o = n.data;
      if (this._def.returns instanceof Js) {
        const a = this;
        return at(async function(...l) {
          const u = new Pt([]), c = await a._def.args.parseAsync(l, i).catch((p) => {
            throw u.addIssue(r(l, p)), u;
          }), d = await Reflect.apply(o, this, c);
          return await a._def.returns._def.type.parseAsync(d, i).catch((p) => {
            throw u.addIssue(s(d, p)), u;
          });
        });
      } else {
        const a = this;
        return at(function(...l) {
          const u = a._def.args.safeParse(l, i);
          if (!u.success) throw new Pt([
            r(l, u.error)
          ]);
          const c = Reflect.apply(o, this, u.data), d = a._def.returns.safeParse(c, i);
          if (!d.success) throw new Pt([
            s(c, d.error)
          ]);
          return d.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...t) {
      return new Ms({
        ...this._def,
        args: vn.create(t).rest(Vr.create())
      });
    }
    returns(t) {
      return new Ms({
        ...this._def,
        returns: t
      });
    }
    implement(t) {
      return this.parse(t);
    }
    strictImplement(t) {
      return this.parse(t);
    }
    static create(t, n, r) {
      return new Ms({
        args: t || vn.create([]).rest(Vr.create()),
        returns: n || Vr.create(),
        typeName: G.ZodFunction,
        ...Y(r)
      });
    }
  }
  class Eo extends ee {
    get schema() {
      return this._def.getter();
    }
    _parse(t) {
      const { ctx: n } = this._processInputParams(t);
      return this._def.getter()._parse({
        data: n.data,
        path: n.path,
        parent: n
      });
    }
  }
  Eo.create = (e, t) => new Eo({
    getter: e,
    typeName: G.ZodLazy,
    ...Y(t)
  });
  class Po extends ee {
    _parse(t) {
      if (t.data !== this._def.value) {
        const n = this._getOrReturnCtx(t);
        return V(n, {
          received: n.data,
          code: R.invalid_literal,
          expected: this._def.value
        }), K;
      }
      return {
        status: "valid",
        value: t.data
      };
    }
    get value() {
      return this._def.value;
    }
  }
  Po.create = (e, t) => new Po({
    value: e,
    typeName: G.ZodLiteral,
    ...Y(t)
  });
  function Db(e, t) {
    return new vr({
      values: e,
      typeName: G.ZodEnum,
      ...Y(t)
    });
  }
  class vr extends ee {
    _parse(t) {
      if (typeof t.data != "string") {
        const n = this._getOrReturnCtx(t), r = this._def.values;
        return V(n, {
          expected: re.joinValues(r),
          received: n.parsedType,
          code: R.invalid_type
        }), K;
      }
      if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(t.data)) {
        const n = this._getOrReturnCtx(t), r = this._def.values;
        return V(n, {
          received: n.data,
          code: R.invalid_enum_value,
          options: r
        }), K;
      }
      return at(t.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const t = {};
      for (const n of this._def.values) t[n] = n;
      return t;
    }
    get Values() {
      const t = {};
      for (const n of this._def.values) t[n] = n;
      return t;
    }
    get Enum() {
      const t = {};
      for (const n of this._def.values) t[n] = n;
      return t;
    }
    extract(t, n = this._def) {
      return vr.create(t, {
        ...this._def,
        ...n
      });
    }
    exclude(t, n = this._def) {
      return vr.create(this.options.filter((r) => !t.includes(r)), {
        ...this._def,
        ...n
      });
    }
  }
  vr.create = Db;
  class ko extends ee {
    _parse(t) {
      const n = re.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
      if (r.parsedType !== F.string && r.parsedType !== F.number) {
        const s = re.objectValues(n);
        return V(r, {
          expected: re.joinValues(s),
          received: r.parsedType,
          code: R.invalid_type
        }), K;
      }
      if (this._cache || (this._cache = new Set(re.getValidEnumValues(this._def.values))), !this._cache.has(t.data)) {
        const s = re.objectValues(n);
        return V(r, {
          received: r.data,
          code: R.invalid_enum_value,
          options: s
        }), K;
      }
      return at(t.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ko.create = (e, t) => new ko({
    values: e,
    typeName: G.ZodNativeEnum,
    ...Y(t)
  });
  class Js extends ee {
    unwrap() {
      return this._def.type;
    }
    _parse(t) {
      const { ctx: n } = this._processInputParams(t);
      if (n.parsedType !== F.promise && n.common.async === false) return V(n, {
        code: R.invalid_type,
        expected: F.promise,
        received: n.parsedType
      }), K;
      const r = n.parsedType === F.promise ? n.data : Promise.resolve(n.data);
      return at(r.then((s) => this._def.type.parseAsync(s, {
        path: n.path,
        errorMap: n.common.contextualErrorMap
      })));
    }
  }
  Js.create = (e, t) => new Js({
    type: e,
    typeName: G.ZodPromise,
    ...Y(t)
  });
  class en extends ee {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === G.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t), s = this._def.effect || null, i = {
        addIssue: (o) => {
          V(r, o), o.fatal ? n.abort() : n.dirty();
        },
        get path() {
          return r.path;
        }
      };
      if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
        const o = s.transform(r.data, i);
        if (r.common.async) return Promise.resolve(o).then(async (a) => {
          if (n.value === "aborted") return K;
          const l = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? K : l.status === "dirty" || n.value === "dirty" ? Cs(l.value) : l;
        });
        {
          if (n.value === "aborted") return K;
          const a = this._def.schema._parseSync({
            data: o,
            path: r.path,
            parent: r
          });
          return a.status === "aborted" ? K : a.status === "dirty" || n.value === "dirty" ? Cs(a.value) : a;
        }
      }
      if (s.type === "refinement") {
        const o = (a) => {
          const l = s.refinement(a, i);
          if (r.common.async) return Promise.resolve(l);
          if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return a;
        };
        if (r.common.async === false) {
          const a = this._def.schema._parseSync({
            data: r.data,
            path: r.path,
            parent: r
          });
          return a.status === "aborted" ? K : (a.status === "dirty" && n.dirty(), o(a.value), {
            status: n.value,
            value: a.value
          });
        } else return this._def.schema._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        }).then((a) => a.status === "aborted" ? K : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({
          status: n.value,
          value: a.value
        }))));
      }
      if (s.type === "transform") if (r.common.async === false) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Gr(o)) return K;
        const a = s.transform(o.value, i);
        if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {
          status: n.value,
          value: a
        };
      } else return this._def.schema._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }).then((o) => Gr(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({
        status: n.value,
        value: a
      })) : K);
      re.assertNever(s);
    }
  }
  en.create = (e, t, n) => new en({
    schema: e,
    typeName: G.ZodEffects,
    effect: t,
    ...Y(n)
  });
  en.createWithPreprocess = (e, t, n) => new en({
    schema: t,
    effect: {
      type: "preprocess",
      transform: e
    },
    typeName: G.ZodEffects,
    ...Y(n)
  });
  class pn extends ee {
    _parse(t) {
      return this._getType(t) === F.undefined ? at(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  pn.create = (e, t) => new pn({
    innerType: e,
    typeName: G.ZodOptional,
    ...Y(t)
  });
  class wr extends ee {
    _parse(t) {
      return this._getType(t) === F.null ? at(null) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  wr.create = (e, t) => new wr({
    innerType: e,
    typeName: G.ZodNullable,
    ...Y(t)
  });
  class _o extends ee {
    _parse(t) {
      const { ctx: n } = this._processInputParams(t);
      let r = n.data;
      return n.parsedType === F.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
        data: r,
        path: n.path,
        parent: n
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  _o.create = (e, t) => new _o({
    innerType: e,
    typeName: G.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...Y(t)
  });
  class Ao extends ee {
    _parse(t) {
      const { ctx: n } = this._processInputParams(t), r = {
        ...n,
        common: {
          ...n.common,
          issues: []
        }
      }, s = this._def.innerType._parse({
        data: r.data,
        path: r.path,
        parent: {
          ...r
        }
      });
      return vo(s) ? s.then((i) => ({
        status: "valid",
        value: i.status === "valid" ? i.value : this._def.catchValue({
          get error() {
            return new Pt(r.common.issues);
          },
          input: r.data
        })
      })) : {
        status: "valid",
        value: s.status === "valid" ? s.value : this._def.catchValue({
          get error() {
            return new Pt(r.common.issues);
          },
          input: r.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  Ao.create = (e, t) => new Ao({
    innerType: e,
    typeName: G.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...Y(t)
  });
  class jl extends ee {
    _parse(t) {
      if (this._getType(t) !== F.nan) {
        const r = this._getOrReturnCtx(t);
        return V(r, {
          code: R.invalid_type,
          expected: F.nan,
          received: r.parsedType
        }), K;
      }
      return {
        status: "valid",
        value: t.data
      };
    }
  }
  jl.create = (e) => new jl({
    typeName: G.ZodNaN,
    ...Y(e)
  });
  const hL = Symbol("zod_brand");
  class Ep extends ee {
    _parse(t) {
      const { ctx: n } = this._processInputParams(t), r = n.data;
      return this._def.type._parse({
        data: r,
        path: n.path,
        parent: n
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class Qo extends ee {
    _parse(t) {
      const { status: n, ctx: r } = this._processInputParams(t);
      if (r.common.async) return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? K : i.status === "dirty" ? (n.dirty(), Cs(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
      {
        const s = this._def.in._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? K : s.status === "dirty" ? (n.dirty(), {
          status: "dirty",
          value: s.value
        }) : this._def.out._parseSync({
          data: s.value,
          path: r.path,
          parent: r
        });
      }
    }
    static create(t, n) {
      return new Qo({
        in: t,
        out: n,
        typeName: G.ZodPipeline
      });
    }
  }
  class Ro extends ee {
    _parse(t) {
      const n = this._def.innerType._parse(t), r = (s) => (Gr(s) && (s.value = Object.freeze(s.value)), s);
      return vo(n) ? n.then((s) => r(s)) : r(n);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  Ro.create = (e, t) => new Ro({
    innerType: e,
    typeName: G.ZodReadonly,
    ...Y(t)
  });
  function Xy(e, t) {
    const n = typeof e == "function" ? e(t) : typeof e == "string" ? {
      message: e
    } : e;
    return typeof n == "string" ? {
      message: n
    } : n;
  }
  function Eu(e, t = {}, n) {
    return e ? Xs.create().superRefine((r, s) => {
      const i = e(r);
      if (i instanceof Promise) return i.then((o) => {
        if (!o) {
          const a = Xy(t, r), l = a.fatal ?? n ?? true;
          s.addIssue({
            code: "custom",
            ...a,
            fatal: l
          });
        }
      });
      if (!i) {
        const o = Xy(t, r), a = o.fatal ?? n ?? true;
        s.addIssue({
          code: "custom",
          ...o,
          fatal: a
        });
      }
    }) : Xs.create();
  }
  const pL = {
    object: xe.lazycreate
  };
  var G;
  (function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
  })(G || (G = {}));
  const mL = (e, t = {
    message: `Input not instance of ${e.name}`
  }) => Eu((n) => n instanceof e, t), q = Qt.create, Pe = gr.create, gL = jl.create, yL = yr.create, Ht = wo.create, vL = qr.create, wL = Ol.create, xL = xo.create, Mb = So.create, Vl = Xs.create, SL = Vr.create, bL = Bn.create, TL = Il.create, Os = Zt.create, se = xe.create, CL = xe.strictCreate, Pp = bo.create, EL = Cu.create, PL = To.create, kL = vn.create, Ob = Co.create, _L = Ll.create, AL = Zr.create, RL = Ms.create, NL = Eo.create, DL = Po.create, ML = vr.create, OL = ko.create, IL = Js.create, Jy = en.create, LL = pn.create, jL = wr.create, VL = en.createWithPreprocess, FL = Qo.create, zL = () => q().optional(), BL = () => Pe().optional(), UL = () => Ht().optional(), $L = {
    string: (e) => Qt.create({
      ...e,
      coerce: true
    }),
    number: (e) => gr.create({
      ...e,
      coerce: true
    }),
    boolean: (e) => wo.create({
      ...e,
      coerce: true
    }),
    bigint: (e) => yr.create({
      ...e,
      coerce: true
    }),
    date: (e) => qr.create({
      ...e,
      coerce: true
    })
  }, WL = K, HL = Object.freeze(Object.defineProperty({
    __proto__: null,
    BRAND: hL,
    DIRTY: Cs,
    EMPTY_PATH: HI,
    INVALID: K,
    NEVER: WL,
    OK: at,
    ParseStatus: nt,
    Schema: ee,
    ZodAny: Xs,
    ZodArray: Zt,
    ZodBigInt: yr,
    ZodBoolean: wo,
    ZodBranded: Ep,
    ZodCatch: Ao,
    ZodDate: qr,
    ZodDefault: _o,
    ZodDiscriminatedUnion: Cu,
    ZodEffects: en,
    ZodEnum: vr,
    ZodError: Pt,
    get ZodFirstPartyTypeKind() {
      return G;
    },
    ZodFunction: Ms,
    ZodIntersection: To,
    ZodIssueCode: R,
    ZodLazy: Eo,
    ZodLiteral: Po,
    ZodMap: Ll,
    ZodNaN: jl,
    ZodNativeEnum: ko,
    ZodNever: Bn,
    ZodNull: So,
    ZodNullable: wr,
    ZodNumber: gr,
    ZodObject: xe,
    ZodOptional: pn,
    ZodParsedType: F,
    ZodPipeline: Qo,
    ZodPromise: Js,
    ZodReadonly: Ro,
    ZodRecord: Co,
    ZodSchema: ee,
    ZodSet: Zr,
    ZodString: Qt,
    ZodSymbol: Ol,
    ZodTransformer: en,
    ZodTuple: vn,
    ZodType: ee,
    ZodUndefined: xo,
    ZodUnion: bo,
    ZodUnknown: Vr,
    ZodVoid: Il,
    addIssueToContext: V,
    any: Vl,
    array: Os,
    bigint: yL,
    boolean: Ht,
    coerce: $L,
    custom: Eu,
    date: vL,
    datetimeRegex: Nb,
    defaultErrorMap: Ys,
    discriminatedUnion: EL,
    effect: Jy,
    enum: ML,
    function: RL,
    getErrorMap: Dl,
    getParsedType: Pn,
    instanceof: mL,
    intersection: PL,
    isAborted: mf,
    isAsync: vo,
    isDirty: gf,
    isValid: Gr,
    late: pL,
    lazy: NL,
    literal: DL,
    makeIssue: Ml,
    map: _L,
    nan: gL,
    nativeEnum: OL,
    never: bL,
    null: Mb,
    nullable: jL,
    number: Pe,
    object: se,
    get objectUtil() {
      return pf;
    },
    oboolean: UL,
    onumber: BL,
    optional: LL,
    ostring: zL,
    pipeline: FL,
    preprocess: VL,
    promise: IL,
    quotelessJson: $I,
    record: Ob,
    set: AL,
    setErrorMap: WI,
    strictObject: CL,
    string: q,
    symbol: wL,
    transformer: Jy,
    tuple: kL,
    undefined: xL,
    union: Pp,
    unknown: SL,
    get util() {
      return re;
    },
    void: TL
  }, Symbol.toStringTag, {
    value: "Module"
  })), _ = Symbol.for("drizzle:entityKind");
  function He(e, t) {
    if (!e || typeof e != "object") return false;
    if (e instanceof t) return true;
    if (!Object.prototype.hasOwnProperty.call(t, _)) throw new Error(`Class "${t.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
    let n = Object.getPrototypeOf(e).constructor;
    if (n) for (; n; ) {
      if (_ in n && n[_] === t[_]) return true;
      n = Object.getPrototypeOf(n);
    }
    return false;
  }
  _l3 = _;
  class No {
    constructor(t, n) {
      this.table = t, this.config = n, this.name = n.name, this.keyAsName = n.keyAsName, this.notNull = n.notNull, this.default = n.default, this.defaultFn = n.defaultFn, this.onUpdateFn = n.onUpdateFn, this.hasDefault = n.hasDefault, this.primary = n.primaryKey, this.isUnique = n.isUnique, this.uniqueName = n.uniqueName, this.uniqueType = n.uniqueType, this.dataType = n.dataType, this.columnType = n.columnType, this.generated = n.generated, this.generatedIdentity = n.generatedIdentity;
    }
    name;
    keyAsName;
    primary;
    notNull;
    default;
    defaultFn;
    onUpdateFn;
    hasDefault;
    isUnique;
    uniqueName;
    uniqueType;
    dataType;
    columnType;
    enumValues = void 0;
    generated = void 0;
    generatedIdentity = void 0;
    config;
    mapFromDriverValue(t) {
      return t;
    }
    mapToDriverValue(t) {
      return t;
    }
    shouldDisableInsert() {
      return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
    }
  }
  __publicField(No, _l3, "Column");
  _m3 = _;
  class KL {
    config;
    constructor(t, n, r) {
      this.config = {
        name: t,
        keyAsName: t === "",
        notNull: false,
        default: void 0,
        hasDefault: false,
        primaryKey: false,
        isUnique: false,
        uniqueName: void 0,
        uniqueType: void 0,
        dataType: n,
        columnType: r,
        generated: void 0
      };
    }
    $type() {
      return this;
    }
    notNull() {
      return this.config.notNull = true, this;
    }
    default(t) {
      return this.config.default = t, this.config.hasDefault = true, this;
    }
    $defaultFn(t) {
      return this.config.defaultFn = t, this.config.hasDefault = true, this;
    }
    $default = this.$defaultFn;
    $onUpdateFn(t) {
      return this.config.onUpdateFn = t, this.config.hasDefault = true, this;
    }
    $onUpdate = this.$onUpdateFn;
    primaryKey() {
      return this.config.primaryKey = true, this.config.notNull = true, this;
    }
    setName(t) {
      this.config.name === "" && (this.config.name = t);
    }
  }
  __publicField(KL, _m3, "ColumnBuilder");
  const Is = Symbol.for("drizzle:Name");
  _n10 = _;
  class QL {
    reference;
    _onUpdate = "no action";
    _onDelete = "no action";
    constructor(t, n) {
      this.reference = () => {
        const { name: r, columns: s, foreignColumns: i } = t();
        return {
          name: r,
          columns: s,
          foreignTable: i[0].table,
          foreignColumns: i
        };
      }, n && (this._onUpdate = n.onUpdate, this._onDelete = n.onDelete);
    }
    onUpdate(t) {
      return this._onUpdate = t === void 0 ? "no action" : t, this;
    }
    onDelete(t) {
      return this._onDelete = t === void 0 ? "no action" : t, this;
    }
    build(t) {
      return new GL(t, this);
    }
  }
  __publicField(QL, _n10, "PgForeignKeyBuilder");
  _o5 = _;
  class GL {
    constructor(t, n) {
      this.table = t, this.reference = n.reference, this.onUpdate = n._onUpdate, this.onDelete = n._onDelete;
    }
    reference;
    onUpdate;
    onDelete;
    getName() {
      const { name: t, columns: n, foreignColumns: r } = this.reference(), s = n.map((a) => a.name), i = r.map((a) => a.name), o = [
        this.table[Is],
        ...s,
        r[0].table[Is],
        ...i
      ];
      return t ?? `${o.join("_")}_fk`;
    }
  }
  __publicField(GL, _o5, "PgForeignKey");
  function qL(e, ...t) {
    return e(...t);
  }
  function ZL(e, t) {
    return `${e[Is]}_${t.join("_")}_unique`;
  }
  function ev(e, t, n) {
    for (let r = t; r < e.length; r++) {
      const s = e[r];
      if (s === "\\") {
        r++;
        continue;
      }
      if (s === '"') return [
        e.slice(t, r).replace(/\\/g, ""),
        r + 1
      ];
      if (!n && (s === "," || s === "}")) return [
        e.slice(t, r).replace(/\\/g, ""),
        r
      ];
    }
    return [
      e.slice(t).replace(/\\/g, ""),
      e.length
    ];
  }
  function Ib(e, t = 0) {
    const n = [];
    let r = t, s = false;
    for (; r < e.length; ) {
      const i = e[r];
      if (i === ",") {
        (s || r === t) && n.push(""), s = true, r++;
        continue;
      }
      if (s = false, i === "\\") {
        r += 2;
        continue;
      }
      if (i === '"') {
        const [l, u] = ev(e, r + 1, true);
        n.push(l), r = u;
        continue;
      }
      if (i === "}") return [
        n,
        r + 1
      ];
      if (i === "{") {
        const [l, u] = Ib(e, r + 1);
        n.push(l), r = u;
        continue;
      }
      const [o, a] = ev(e, r, false);
      n.push(o), r = a;
    }
    return [
      n,
      r
    ];
  }
  function YL(e) {
    const [t] = Ib(e, 1);
    return t;
  }
  function Lb(e) {
    return `{${e.map((t) => Array.isArray(t) ? Lb(t) : typeof t == "string" ? `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` : `${t}`).join(",")}}`;
  }
  class oe extends (_q = KL, _p3 = _, _q) {
    foreignKeyConfigs = [];
    array(t) {
      return new JL(this.config.name, this, t);
    }
    references(t, n = {}) {
      return this.foreignKeyConfigs.push({
        ref: t,
        actions: n
      }), this;
    }
    unique(t, n) {
      return this.config.isUnique = true, this.config.uniqueName = t, this.config.uniqueType = n?.nulls, this;
    }
    generatedAlwaysAs(t) {
      return this.config.generated = {
        as: t,
        type: "always",
        mode: "stored"
      }, this;
    }
    buildForeignKeys(t, n) {
      return this.foreignKeyConfigs.map(({ ref: r, actions: s }) => qL((i, o) => {
        const a = new QL(() => {
          const l = i();
          return {
            columns: [
              t
            ],
            foreignColumns: [
              l
            ]
          };
        });
        return o.onUpdate && a.onUpdate(o.onUpdate), o.onDelete && a.onDelete(o.onDelete), a.build(n);
      }, r, s));
    }
    buildExtraConfigColumn(t) {
      return new XL(t, this.config);
    }
  }
  __publicField(oe, _p3, "PgColumnBuilder");
  class J extends (_s7 = No, _r5 = _, _s7) {
    constructor(t, n) {
      n.uniqueName || (n.uniqueName = ZL(t, [
        n.name
      ])), super(t, n), this.table = t;
    }
  }
  __publicField(J, _r5, "PgColumn");
  class XL extends (_u3 = J, _t11 = _, _u3) {
    getSQLType() {
      return this.getSQLType();
    }
    indexConfig = {
      order: this.config.order ?? "asc",
      nulls: this.config.nulls ?? "last",
      opClass: this.config.opClass
    };
    defaultConfig = {
      order: "asc",
      nulls: "last",
      opClass: void 0
    };
    asc() {
      return this.indexConfig.order = "asc", this;
    }
    desc() {
      return this.indexConfig.order = "desc", this;
    }
    nullsFirst() {
      return this.indexConfig.nulls = "first", this;
    }
    nullsLast() {
      return this.indexConfig.nulls = "last", this;
    }
    op(t) {
      return this.indexConfig.opClass = t, this;
    }
  }
  __publicField(XL, _t11, "ExtraConfigColumn");
  class JL extends (_w2 = oe, _v2 = _, _w2) {
    constructor(t, n, r) {
      super(t, "array", "PgArray"), this.config.baseBuilder = n, this.config.size = r;
    }
    build(t) {
      const n = this.config.baseBuilder.build(t);
      return new kp(t, this.config, n);
    }
  }
  __publicField(JL, _v2, "PgArrayBuilder");
  const _kp = class _kp extends (_y2 = J, _x2 = _, _y2) {
    constructor(t, n, r, s) {
      super(t, n), this.baseColumn = r, this.range = s, this.size = n.size;
    }
    size;
    getSQLType() {
      return `${this.baseColumn.getSQLType()}[${typeof this.size == "number" ? this.size : ""}]`;
    }
    mapFromDriverValue(t) {
      return typeof t == "string" && (t = YL(t)), t.map((n) => this.baseColumn.mapFromDriverValue(n));
    }
    mapToDriverValue(t, n = false) {
      const r = t.map((s) => s === null ? null : He(this.baseColumn, _kp) ? this.baseColumn.mapToDriverValue(s, true) : this.baseColumn.mapToDriverValue(s));
      return n ? r : Lb(r);
    }
  };
  __publicField(_kp, _x2, "PgArray");
  let kp = _kp;
  const tv = Symbol.for("drizzle:isPgEnum");
  function ej(e) {
    return !!e && typeof e == "function" && tv in e && e[tv] === true;
  }
  _z = _;
  class jb {
    constructor(t, n, r, s = false) {
      this._ = {
        brand: "Subquery",
        sql: t,
        selectedFields: n,
        alias: r,
        isWith: s
      };
    }
  }
  __publicField(jb, _z, "Subquery");
  const tj = {
    startActiveSpan(e, t) {
      return t();
    }
  }, Ls = Symbol.for("drizzle:ViewBaseConfig"), kc = Symbol.for("drizzle:Schema"), nv = Symbol.for("drizzle:Columns"), rv = Symbol.for("drizzle:ExtraConfigColumns"), _c = Symbol.for("drizzle:OriginalName"), Ac = Symbol.for("drizzle:BaseName"), Fl = Symbol.for("drizzle:IsAlias"), sv = Symbol.for("drizzle:ExtraConfigBuilder"), Vb = Symbol.for("drizzle:IsDrizzleTable");
  class St {
    [(_A2 = _, Is)];
    [_c];
    [kc];
    [nv];
    [rv];
    [Ac];
    [Fl] = false;
    [Vb] = true;
    [sv] = void 0;
    constructor(t, n, r) {
      this[Is] = this[_c] = t, this[kc] = n, this[Ac] = r;
    }
  }
  __publicField(St, _A2, "Table");
  __publicField(St, "Symbol", {
    Name: Is,
    Schema: kc,
    OriginalName: _c,
    Columns: nv,
    ExtraConfigColumns: rv,
    BaseName: Ac,
    IsAlias: Fl,
    ExtraConfigBuilder: sv
  });
  function Fb(e) {
    return typeof e == "object" && e !== null && Vb in e;
  }
  function nj(e) {
    return e != null && typeof e.getSQL == "function";
  }
  function rj(e) {
    const t = {
      sql: "",
      params: []
    };
    for (const n of e) t.sql += n.sql, t.params.push(...n.params), n.typings?.length && (t.typings || (t.typings = []), t.typings.push(...n.typings));
    return t;
  }
  _B = _;
  class $t {
    value;
    constructor(t) {
      this.value = Array.isArray(t) ? t : [
        t
      ];
    }
    getSQL() {
      return new Ae([
        this
      ]);
    }
  }
  __publicField($t, _B, "StringChunk");
  _C2 = _;
  const _Ae = class _Ae {
    constructor(t) {
      this.queryChunks = t;
    }
    decoder = zb;
    shouldInlineParams = false;
    append(t) {
      return this.queryChunks.push(...t.queryChunks), this;
    }
    toQuery(t) {
      return tj.startActiveSpan("drizzle.buildSQL", (n) => {
        const r = this.buildQueryFromSourceParams(this.queryChunks, t);
        return n?.setAttributes({
          "drizzle.query.text": r.sql,
          "drizzle.query.params": JSON.stringify(r.params)
        }), r;
      });
    }
    buildQueryFromSourceParams(t, n) {
      const r = Object.assign({}, n, {
        inlineParams: n.inlineParams || this.shouldInlineParams,
        paramStartIndex: n.paramStartIndex || {
          value: 0
        }
      }), { casing: s, escapeName: i, escapeParam: o, prepareTyping: a, inlineParams: l, paramStartIndex: u } = r;
      return rj(t.map((c) => {
        if (He(c, $t)) return {
          sql: c.value.join(""),
          params: []
        };
        if (He(c, vf)) return {
          sql: i(c.value),
          params: []
        };
        if (c === void 0) return {
          sql: "",
          params: []
        };
        if (Array.isArray(c)) {
          const d = [
            new $t("(")
          ];
          for (const [f, p] of c.entries()) d.push(p), f < c.length - 1 && d.push(new $t(", "));
          return d.push(new $t(")")), this.buildQueryFromSourceParams(d, r);
        }
        if (He(c, _Ae)) return this.buildQueryFromSourceParams(c.queryChunks, {
          ...r,
          inlineParams: l || c.shouldInlineParams
        });
        if (He(c, St)) {
          const d = c[St.Symbol.Schema], f = c[St.Symbol.Name];
          return {
            sql: d === void 0 || c[Fl] ? i(f) : i(d) + "." + i(f),
            params: []
          };
        }
        if (He(c, No)) {
          const d = s.getColumnCasing(c);
          if (n.invokeSource === "indexes") return {
            sql: i(d),
            params: []
          };
          const f = c.table[St.Symbol.Schema];
          return {
            sql: c.table[Fl] || f === void 0 ? i(c.table[St.Symbol.Name]) + "." + i(d) : i(f) + "." + i(c.table[St.Symbol.Name]) + "." + i(d),
            params: []
          };
        }
        if (He(c, sj)) {
          const d = c[Ls].schema, f = c[Ls].name;
          return {
            sql: d === void 0 || c[Ls].isAlias ? i(f) : i(d) + "." + i(f),
            params: []
          };
        }
        if (He(c, Ub)) {
          if (He(c.value, wf)) return {
            sql: o(u.value++, c),
            params: [
              c
            ],
            typings: [
              "none"
            ]
          };
          const d = c.value === null ? null : c.encoder.mapToDriverValue(c.value);
          if (He(d, _Ae)) return this.buildQueryFromSourceParams([
            d
          ], r);
          if (l) return {
            sql: this.mapInlineParam(d, r),
            params: []
          };
          let f = [
            "none"
          ];
          return a && (f = [
            a(c.encoder)
          ]), {
            sql: o(u.value++, d),
            params: [
              d
            ],
            typings: f
          };
        }
        return He(c, wf) ? {
          sql: o(u.value++, c),
          params: [
            c
          ],
          typings: [
            "none"
          ]
        } : He(c, _Ae.Aliased) && c.fieldAlias !== void 0 ? {
          sql: i(c.fieldAlias),
          params: []
        } : He(c, jb) ? c._.isWith ? {
          sql: i(c._.alias),
          params: []
        } : this.buildQueryFromSourceParams([
          new $t("("),
          c._.sql,
          new $t(") "),
          new vf(c._.alias)
        ], r) : ej(c) ? c.schema ? {
          sql: i(c.schema) + "." + i(c.enumName),
          params: []
        } : {
          sql: i(c.enumName),
          params: []
        } : nj(c) ? c.shouldOmitSQLParens?.() ? this.buildQueryFromSourceParams([
          c.getSQL()
        ], r) : this.buildQueryFromSourceParams([
          new $t("("),
          c.getSQL(),
          new $t(")")
        ], r) : l ? {
          sql: this.mapInlineParam(c, r),
          params: []
        } : {
          sql: o(u.value++, c),
          params: [
            c
          ],
          typings: [
            "none"
          ]
        };
      }));
    }
    mapInlineParam(t, { escapeString: n }) {
      if (t === null) return "null";
      if (typeof t == "number" || typeof t == "boolean") return t.toString();
      if (typeof t == "string") return n(t);
      if (typeof t == "object") {
        const r = t.toString();
        return n(r === "[object Object]" ? JSON.stringify(t) : r);
      }
      throw new Error("Unexpected param value: " + t);
    }
    getSQL() {
      return this;
    }
    as(t) {
      return t === void 0 ? this : new _Ae.Aliased(this, t);
    }
    mapWith(t) {
      return this.decoder = typeof t == "function" ? {
        mapFromDriverValue: t
      } : t, this;
    }
    inlineParams() {
      return this.shouldInlineParams = true, this;
    }
    if(t) {
      return t ? this : void 0;
    }
  };
  __publicField(_Ae, _C2, "SQL");
  let Ae = _Ae;
  _D2 = _;
  class vf {
    constructor(t) {
      this.value = t;
    }
    brand;
    getSQL() {
      return new Ae([
        this
      ]);
    }
  }
  __publicField(vf, _D2, "Name");
  const zb = {
    mapFromDriverValue: (e) => e
  }, Bb = {
    mapToDriverValue: (e) => e
  };
  ({
    ...zb,
    ...Bb
  });
  _E2 = _;
  class Ub {
    constructor(t, n = Bb) {
      this.value = t, this.encoder = n;
    }
    brand;
    getSQL() {
      return new Ae([
        this
      ]);
    }
  }
  __publicField(Ub, _E2, "Param");
  function zl(e, ...t) {
    const n = [];
    (t.length > 0 || e.length > 0 && e[0] !== "") && n.push(new $t(e[0]));
    for (const [r, s] of t.entries()) n.push(s, new $t(e[r + 1]));
    return new Ae(n);
  }
  ((e) => {
    function t() {
      return new Ae([]);
    }
    e.empty = t;
    function n(l) {
      return new Ae(l);
    }
    e.fromList = n;
    function r(l) {
      return new Ae([
        new $t(l)
      ]);
    }
    e.raw = r;
    function s(l, u) {
      const c = [];
      for (const [d, f] of l.entries()) d > 0 && u !== void 0 && c.push(u), c.push(f);
      return new Ae(c);
    }
    e.join = s;
    function i(l) {
      return new vf(l);
    }
    e.identifier = i;
    function o(l) {
      return new wf(l);
    }
    e.placeholder = o;
    function a(l, u) {
      return new Ub(l, u);
    }
    e.param = a;
  })(zl || (zl = {}));
  ((e) => {
    var _a6;
    _a6 = _;
    const _t12 = class _t12 {
      constructor(r, s) {
        this.sql = r, this.fieldAlias = s;
      }
      isSelectionField = false;
      getSQL() {
        return this.sql;
      }
      clone() {
        return new _t12(this.sql, this.fieldAlias);
      }
    };
    __publicField(_t12, _a6, "SQL.Aliased");
    let t = _t12;
    e.Aliased = t;
  })(Ae || (Ae = {}));
  _F2 = _;
  class wf {
    constructor(t) {
      this.name = t;
    }
    getSQL() {
      return new Ae([
        this
      ]);
    }
  }
  __publicField(wf, _F2, "Placeholder");
  const $b = Symbol.for("drizzle:IsDrizzleView");
  class sj {
    [(_G = _, Ls)];
    [$b] = true;
    constructor({ name: t, schema: n, selectedFields: r, query: s }) {
      this[Ls] = {
        name: t,
        originalName: t,
        schema: n,
        selectedFields: r,
        query: s,
        isExisting: !s,
        isAlias: false
      };
    }
    getSQL() {
      return new Ae([
        this
      ]);
    }
  }
  __publicField(sj, _G, "View");
  function ij(e) {
    return typeof e == "object" && e !== null && $b in e;
  }
  No.prototype.getSQL = function() {
    return new Ae([
      this
    ]);
  };
  St.prototype.getSQL = function() {
    return new Ae([
      this
    ]);
  };
  jb.prototype.getSQL = function() {
    return new Ae([
      this
    ]);
  };
  function oj(e) {
    return e[St.Symbol.Columns];
  }
  function aj(e) {
    return e[Ls].selectedFields;
  }
  function $e(e, t) {
    return {
      name: typeof e == "string" && e.length > 0 ? e : "",
      config: typeof e == "object" ? e : t
    };
  }
  class Pu extends (_I2 = oe, _H = _, _I2) {
    generatedAlwaysAsIdentity(t) {
      if (t) {
        const { name: n, ...r } = t;
        this.config.generatedIdentity = {
          type: "always",
          sequenceName: n,
          sequenceOptions: r
        };
      } else this.config.generatedIdentity = {
        type: "always"
      };
      return this.config.hasDefault = true, this.config.notNull = true, this;
    }
    generatedByDefaultAsIdentity(t) {
      if (t) {
        const { name: n, ...r } = t;
        this.config.generatedIdentity = {
          type: "byDefault",
          sequenceName: n,
          sequenceOptions: r
        };
      } else this.config.generatedIdentity = {
        type: "byDefault"
      };
      return this.config.hasDefault = true, this.config.notNull = true, this;
    }
  }
  __publicField(Pu, _H, "PgIntColumnBaseBuilder");
  class lj extends (_K = Pu, _J = _, _K) {
    constructor(t) {
      super(t, "number", "PgBigInt53");
    }
    build(t) {
      return new uj(t, this.config);
    }
  }
  __publicField(lj, _J, "PgBigInt53Builder");
  class uj extends (_M2 = J, _L2 = _, _M2) {
    getSQLType() {
      return "bigint";
    }
    mapFromDriverValue(t) {
      return typeof t == "number" ? t : Number(t);
    }
  }
  __publicField(uj, _L2, "PgBigInt53");
  class cj extends (_O2 = Pu, _N2 = _, _O2) {
    constructor(t) {
      super(t, "bigint", "PgBigInt64");
    }
    build(t) {
      return new dj(t, this.config);
    }
  }
  __publicField(cj, _N2, "PgBigInt64Builder");
  class dj extends (_Q = J, _P2 = _, _Q) {
    getSQLType() {
      return "bigint";
    }
    mapFromDriverValue(t) {
      return BigInt(t);
    }
  }
  __publicField(dj, _P2, "PgBigInt64");
  function fj(e, t) {
    const { name: n, config: r } = $e(e, t);
    return r.mode === "number" ? new lj(n) : new cj(n);
  }
  class hj extends (_S2 = oe, _R2 = _, _S2) {
    constructor(t) {
      super(t, "number", "PgBigSerial53"), this.config.hasDefault = true, this.config.notNull = true;
    }
    build(t) {
      return new pj(t, this.config);
    }
  }
  __publicField(hj, _R2, "PgBigSerial53Builder");
  class pj extends (_U = J, _T2 = _, _U) {
    getSQLType() {
      return "bigserial";
    }
    mapFromDriverValue(t) {
      return typeof t == "number" ? t : Number(t);
    }
  }
  __publicField(pj, _T2, "PgBigSerial53");
  class mj extends (_W = oe, _V2 = _, _W) {
    constructor(t) {
      super(t, "bigint", "PgBigSerial64"), this.config.hasDefault = true;
    }
    build(t) {
      return new gj(t, this.config);
    }
  }
  __publicField(mj, _V2, "PgBigSerial64Builder");
  class gj extends (_Y = J, _X = _, _Y) {
    getSQLType() {
      return "bigserial";
    }
    mapFromDriverValue(t) {
      return BigInt(t);
    }
  }
  __publicField(gj, _X, "PgBigSerial64");
  function yj(e, t) {
    const { name: n, config: r } = $e(e, t);
    return r.mode === "number" ? new hj(n) : new mj(n);
  }
  class vj extends (__2 = oe, _Z = _, __2) {
    constructor(t) {
      super(t, "boolean", "PgBoolean");
    }
    build(t) {
      return new wj(t, this.config);
    }
  }
  __publicField(vj, _Z, "PgBooleanBuilder");
  class wj extends (_aa = J, _$ = _, _aa) {
    getSQLType() {
      return "boolean";
    }
  }
  __publicField(wj, _$, "PgBoolean");
  function ku(e) {
    return new vj(e ?? "");
  }
  class xj extends (_ca = oe, _ba = _, _ca) {
    constructor(t, n) {
      super(t, "string", "PgChar"), this.config.length = n.length, this.config.enumValues = n.enum;
    }
    build(t) {
      return new Sj(t, this.config);
    }
  }
  __publicField(xj, _ba, "PgCharBuilder");
  class Sj extends (_ea = J, _da = _, _ea) {
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
      return this.length === void 0 ? "char" : `char(${this.length})`;
    }
  }
  __publicField(Sj, _da, "PgChar");
  function bj(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return new xj(n, r);
  }
  class Tj extends (_ga = oe, _fa = _, _ga) {
    constructor(t) {
      super(t, "string", "PgCidr");
    }
    build(t) {
      return new Cj(t, this.config);
    }
  }
  __publicField(Tj, _fa, "PgCidrBuilder");
  class Cj extends (_ia = J, _ha = _, _ia) {
    getSQLType() {
      return "cidr";
    }
  }
  __publicField(Cj, _ha, "PgCidr");
  function Ej(e) {
    return new Tj(e ?? "");
  }
  class Pj extends (_ka = oe, _ja = _, _ka) {
    constructor(t, n, r) {
      super(t, "custom", "PgCustomColumn"), this.config.fieldConfig = n, this.config.customTypeParams = r;
    }
    build(t) {
      return new kj(t, this.config);
    }
  }
  __publicField(Pj, _ja, "PgCustomColumnBuilder");
  class kj extends (_ma = J, _la = _, _ma) {
    sqlName;
    mapTo;
    mapFrom;
    constructor(t, n) {
      super(t, n), this.sqlName = n.customTypeParams.dataType(n.fieldConfig), this.mapTo = n.customTypeParams.toDriver, this.mapFrom = n.customTypeParams.fromDriver;
    }
    getSQLType() {
      return this.sqlName;
    }
    mapFromDriverValue(t) {
      return typeof this.mapFrom == "function" ? this.mapFrom(t) : t;
    }
    mapToDriverValue(t) {
      return typeof this.mapTo == "function" ? this.mapTo(t) : t;
    }
  }
  __publicField(kj, _la, "PgCustomColumn");
  function _j(e) {
    return (t, n) => {
      const { name: r, config: s } = $e(t, n);
      return new Pj(r, s, e);
    };
  }
  class Go extends (_oa = oe, _na = _, _oa) {
    defaultNow() {
      return this.default(zl`now()`);
    }
  }
  __publicField(Go, _na, "PgDateColumnBaseBuilder");
  class Aj extends (_qa = Go, _pa = _, _qa) {
    constructor(t) {
      super(t, "date", "PgDate");
    }
    build(t) {
      return new Rj(t, this.config);
    }
  }
  __publicField(Aj, _pa, "PgDateBuilder");
  class Rj extends (_sa = J, _ra = _, _sa) {
    getSQLType() {
      return "date";
    }
    mapFromDriverValue(t) {
      return new Date(t);
    }
    mapToDriverValue(t) {
      return t.toISOString();
    }
  }
  __publicField(Rj, _ra, "PgDate");
  class Nj extends (_ua = Go, _ta = _, _ua) {
    constructor(t) {
      super(t, "string", "PgDateString");
    }
    build(t) {
      return new Dj(t, this.config);
    }
  }
  __publicField(Nj, _ta, "PgDateStringBuilder");
  class Dj extends (_wa = J, _va = _, _wa) {
    getSQLType() {
      return "date";
    }
  }
  __publicField(Dj, _va, "PgDateString");
  function Mj(e, t) {
    const { name: n, config: r } = $e(e, t);
    return r?.mode === "date" ? new Aj(n) : new Nj(n);
  }
  class Oj extends (_ya = oe, _xa = _, _ya) {
    constructor(t) {
      super(t, "number", "PgDoublePrecision");
    }
    build(t) {
      return new Ij(t, this.config);
    }
  }
  __publicField(Oj, _xa, "PgDoublePrecisionBuilder");
  class Ij extends (_Aa = J, _za = _, _Aa) {
    getSQLType() {
      return "double precision";
    }
    mapFromDriverValue(t) {
      return typeof t == "string" ? Number.parseFloat(t) : t;
    }
  }
  __publicField(Ij, _za, "PgDoublePrecision");
  function Lj(e) {
    return new Oj(e ?? "");
  }
  class jj extends (_Ca = oe, _Ba = _, _Ca) {
    constructor(t) {
      super(t, "string", "PgInet");
    }
    build(t) {
      return new Vj(t, this.config);
    }
  }
  __publicField(jj, _Ba, "PgInetBuilder");
  class Vj extends (_Ea = J, _Da = _, _Ea) {
    getSQLType() {
      return "inet";
    }
  }
  __publicField(Vj, _Da, "PgInet");
  function Fj(e) {
    return new jj(e ?? "");
  }
  class zj extends (_Ga = Pu, _Fa = _, _Ga) {
    constructor(t) {
      super(t, "number", "PgInteger");
    }
    build(t) {
      return new Bj(t, this.config);
    }
  }
  __publicField(zj, _Fa, "PgIntegerBuilder");
  class Bj extends (_Ia = J, _Ha = _, _Ia) {
    getSQLType() {
      return "integer";
    }
    mapFromDriverValue(t) {
      return typeof t == "string" ? Number.parseInt(t) : t;
    }
  }
  __publicField(Bj, _Ha, "PgInteger");
  function bt(e) {
    return new zj(e ?? "");
  }
  class Uj extends (_Ka = oe, _Ja = _, _Ka) {
    constructor(t, n) {
      super(t, "string", "PgInterval"), this.config.intervalConfig = n;
    }
    build(t) {
      return new $j(t, this.config);
    }
  }
  __publicField(Uj, _Ja, "PgIntervalBuilder");
  class $j extends (_Ma = J, _La = _, _Ma) {
    fields = this.config.intervalConfig.fields;
    precision = this.config.intervalConfig.precision;
    getSQLType() {
      const t = this.fields ? ` ${this.fields}` : "", n = this.precision ? `(${this.precision})` : "";
      return `interval${t}${n}`;
    }
  }
  __publicField($j, _La, "PgInterval");
  function Wj(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return new Uj(n, r);
  }
  class Hj extends (_Oa = oe, _Na = _, _Oa) {
    constructor(t) {
      super(t, "json", "PgJson");
    }
    build(t) {
      return new Kj(t, this.config);
    }
  }
  __publicField(Hj, _Na, "PgJsonBuilder");
  class Kj extends (_Qa = J, _Pa = _, _Qa) {
    constructor(t, n) {
      super(t, n);
    }
    getSQLType() {
      return "json";
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      if (typeof t == "string") try {
        return JSON.parse(t);
      } catch {
        return t;
      }
      return t;
    }
  }
  __publicField(Kj, _Pa, "PgJson");
  function Qj(e) {
    return new Hj(e ?? "");
  }
  class Gj extends (_Sa = oe, _Ra = _, _Sa) {
    constructor(t) {
      super(t, "json", "PgJsonb");
    }
    build(t) {
      return new qj(t, this.config);
    }
  }
  __publicField(Gj, _Ra, "PgJsonbBuilder");
  class qj extends (_Ua = J, _Ta = _, _Ua) {
    constructor(t, n) {
      super(t, n);
    }
    getSQLType() {
      return "jsonb";
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      if (typeof t == "string") try {
        return JSON.parse(t);
      } catch {
        return t;
      }
      return t;
    }
  }
  __publicField(qj, _Ta, "PgJsonb");
  function Zj(e) {
    return new Gj(e ?? "");
  }
  class Yj extends (_Wa = oe, _Va = _, _Wa) {
    constructor(t) {
      super(t, "array", "PgLine");
    }
    build(t) {
      return new Xj(t, this.config);
    }
  }
  __publicField(Yj, _Va, "PgLineBuilder");
  class Xj extends (_Ya = J, _Xa = _, _Ya) {
    getSQLType() {
      return "line";
    }
    mapFromDriverValue(t) {
      const [n, r, s] = t.slice(1, -1).split(",");
      return [
        Number.parseFloat(n),
        Number.parseFloat(r),
        Number.parseFloat(s)
      ];
    }
    mapToDriverValue(t) {
      return `{${t[0]},${t[1]},${t[2]}}`;
    }
  }
  __publicField(Xj, _Xa, "PgLine");
  class Jj extends (__a = oe, _Za = _, __a) {
    constructor(t) {
      super(t, "json", "PgLineABC");
    }
    build(t) {
      return new eV(t, this.config);
    }
  }
  __publicField(Jj, _Za, "PgLineABCBuilder");
  class eV extends (_ab = J, _$a = _, _ab) {
    getSQLType() {
      return "line";
    }
    mapFromDriverValue(t) {
      const [n, r, s] = t.slice(1, -1).split(",");
      return {
        a: Number.parseFloat(n),
        b: Number.parseFloat(r),
        c: Number.parseFloat(s)
      };
    }
    mapToDriverValue(t) {
      return `{${t.a},${t.b},${t.c}}`;
    }
  }
  __publicField(eV, _$a, "PgLineABC");
  function tV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return !r?.mode || r.mode === "tuple" ? new Yj(n) : new Jj(n);
  }
  class nV extends (_cb = oe, _bb = _, _cb) {
    constructor(t) {
      super(t, "string", "PgMacaddr");
    }
    build(t) {
      return new rV(t, this.config);
    }
  }
  __publicField(nV, _bb, "PgMacaddrBuilder");
  class rV extends (_eb = J, _db = _, _eb) {
    getSQLType() {
      return "macaddr";
    }
  }
  __publicField(rV, _db, "PgMacaddr");
  function sV(e) {
    return new nV(e ?? "");
  }
  class iV extends (_gb = oe, _fb = _, _gb) {
    constructor(t) {
      super(t, "string", "PgMacaddr8");
    }
    build(t) {
      return new oV(t, this.config);
    }
  }
  __publicField(iV, _fb, "PgMacaddr8Builder");
  class oV extends (_ib = J, _hb = _, _ib) {
    getSQLType() {
      return "macaddr8";
    }
  }
  __publicField(oV, _hb, "PgMacaddr8");
  function aV(e) {
    return new iV(e ?? "");
  }
  class lV extends (_kb = oe, _jb = _, _kb) {
    constructor(t, n, r) {
      super(t, "string", "PgNumeric"), this.config.precision = n, this.config.scale = r;
    }
    build(t) {
      return new uV(t, this.config);
    }
  }
  __publicField(lV, _jb, "PgNumericBuilder");
  class uV extends (_mb = J, _lb = _, _mb) {
    precision;
    scale;
    constructor(t, n) {
      super(t, n), this.precision = n.precision, this.scale = n.scale;
    }
    getSQLType() {
      return this.precision !== void 0 && this.scale !== void 0 ? `numeric(${this.precision}, ${this.scale})` : this.precision === void 0 ? "numeric" : `numeric(${this.precision})`;
    }
  }
  __publicField(uV, _lb, "PgNumeric");
  function cV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return new lV(n, r?.precision, r?.scale);
  }
  class dV extends (_ob = oe, _nb = _, _ob) {
    constructor(t) {
      super(t, "array", "PgPointTuple");
    }
    build(t) {
      return new fV(t, this.config);
    }
  }
  __publicField(dV, _nb, "PgPointTupleBuilder");
  class fV extends (_qb = J, _pb = _, _qb) {
    getSQLType() {
      return "point";
    }
    mapFromDriverValue(t) {
      if (typeof t == "string") {
        const [n, r] = t.slice(1, -1).split(",");
        return [
          Number.parseFloat(n),
          Number.parseFloat(r)
        ];
      }
      return [
        t.x,
        t.y
      ];
    }
    mapToDriverValue(t) {
      return `(${t[0]},${t[1]})`;
    }
  }
  __publicField(fV, _pb, "PgPointTuple");
  class hV extends (_sb = oe, _rb = _, _sb) {
    constructor(t) {
      super(t, "json", "PgPointObject");
    }
    build(t) {
      return new pV(t, this.config);
    }
  }
  __publicField(hV, _rb, "PgPointObjectBuilder");
  class pV extends (_ub = J, _tb = _, _ub) {
    getSQLType() {
      return "point";
    }
    mapFromDriverValue(t) {
      if (typeof t == "string") {
        const [n, r] = t.slice(1, -1).split(",");
        return {
          x: Number.parseFloat(n),
          y: Number.parseFloat(r)
        };
      }
      return t;
    }
    mapToDriverValue(t) {
      return `(${t.x},${t.y})`;
    }
  }
  __publicField(pV, _tb, "PgPointObject");
  function mV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return !r?.mode || r.mode === "tuple" ? new dV(n) : new hV(n);
  }
  function gV(e) {
    const t = [];
    for (let n = 0; n < e.length; n += 2) t.push(Number.parseInt(e.slice(n, n + 2), 16));
    return new Uint8Array(t);
  }
  function iv(e, t) {
    const n = new ArrayBuffer(8), r = new DataView(n);
    for (let s = 0; s < 8; s++) r.setUint8(s, e[t + s]);
    return r.getFloat64(0, true);
  }
  function Wb(e) {
    const t = gV(e);
    let n = 0;
    const r = t[n];
    n += 1;
    const s = new DataView(t.buffer), i = s.getUint32(n, r === 1);
    if (n += 4, i & 536870912 && (s.getUint32(n, r === 1), n += 4), (i & 65535) === 1) {
      const o = iv(t, n);
      n += 8;
      const a = iv(t, n);
      return n += 8, [
        o,
        a
      ];
    }
    throw new Error("Unsupported geometry type");
  }
  class yV extends (_wb = oe, _vb = _, _wb) {
    constructor(t) {
      super(t, "array", "PgGeometry");
    }
    build(t) {
      return new vV(t, this.config);
    }
  }
  __publicField(yV, _vb, "PgGeometryBuilder");
  class vV extends (_yb = J, _xb = _, _yb) {
    getSQLType() {
      return "geometry(point)";
    }
    mapFromDriverValue(t) {
      return Wb(t);
    }
    mapToDriverValue(t) {
      return `point(${t[0]} ${t[1]})`;
    }
  }
  __publicField(vV, _xb, "PgGeometry");
  class wV extends (_Ab = oe, _zb = _, _Ab) {
    constructor(t) {
      super(t, "json", "PgGeometryObject");
    }
    build(t) {
      return new xV(t, this.config);
    }
  }
  __publicField(wV, _zb, "PgGeometryObjectBuilder");
  class xV extends (_Cb = J, _Bb = _, _Cb) {
    getSQLType() {
      return "geometry(point)";
    }
    mapFromDriverValue(t) {
      const n = Wb(t);
      return {
        x: n[0],
        y: n[1]
      };
    }
    mapToDriverValue(t) {
      return `point(${t.x} ${t.y})`;
    }
  }
  __publicField(xV, _Bb, "PgGeometryObject");
  function SV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return !r?.mode || r.mode === "tuple" ? new yV(n) : new wV(n);
  }
  class bV extends (_Eb = oe, _Db = _, _Eb) {
    constructor(t, n) {
      super(t, "number", "PgReal"), this.config.length = n;
    }
    build(t) {
      return new TV(t, this.config);
    }
  }
  __publicField(bV, _Db, "PgRealBuilder");
  class TV extends (_Gb = J, _Fb = _, _Gb) {
    constructor(t, n) {
      super(t, n);
    }
    getSQLType() {
      return "real";
    }
    mapFromDriverValue = (t) => typeof t == "string" ? Number.parseFloat(t) : t;
  }
  __publicField(TV, _Fb, "PgReal");
  function CV(e) {
    return new bV(e ?? "");
  }
  class EV extends (_Ib = oe, _Hb = _, _Ib) {
    constructor(t) {
      super(t, "number", "PgSerial"), this.config.hasDefault = true, this.config.notNull = true;
    }
    build(t) {
      return new PV(t, this.config);
    }
  }
  __publicField(EV, _Hb, "PgSerialBuilder");
  class PV extends (_Kb = J, _Jb = _, _Kb) {
    getSQLType() {
      return "serial";
    }
  }
  __publicField(PV, _Jb, "PgSerial");
  function Hb(e) {
    return new EV(e ?? "");
  }
  class kV extends (_Mb = Pu, _Lb = _, _Mb) {
    constructor(t) {
      super(t, "number", "PgSmallInt");
    }
    build(t) {
      return new _V(t, this.config);
    }
  }
  __publicField(kV, _Lb, "PgSmallIntBuilder");
  class _V extends (_Ob = J, _Nb = _, _Ob) {
    getSQLType() {
      return "smallint";
    }
    mapFromDriverValue = (t) => typeof t == "string" ? Number(t) : t;
  }
  __publicField(_V, _Nb, "PgSmallInt");
  function AV(e) {
    return new kV(e ?? "");
  }
  class RV extends (_Qb = oe, _Pb = _, _Qb) {
    constructor(t) {
      super(t, "number", "PgSmallSerial"), this.config.hasDefault = true, this.config.notNull = true;
    }
    build(t) {
      return new NV(t, this.config);
    }
  }
  __publicField(RV, _Pb, "PgSmallSerialBuilder");
  class NV extends (_Sb = J, _Rb = _, _Sb) {
    getSQLType() {
      return "smallserial";
    }
  }
  __publicField(NV, _Rb, "PgSmallSerial");
  function DV(e) {
    return new RV(e ?? "");
  }
  class MV extends (_Ub = oe, _Tb = _, _Ub) {
    constructor(t, n) {
      super(t, "string", "PgText"), this.config.enumValues = n.enum;
    }
    build(t) {
      return new OV(t, this.config);
    }
  }
  __publicField(MV, _Tb, "PgTextBuilder");
  class OV extends (_Wb = J, _Vb = _, _Wb) {
    enumValues = this.config.enumValues;
    getSQLType() {
      return "text";
    }
  }
  __publicField(OV, _Vb, "PgText");
  function kn(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return new MV(n, r);
  }
  class IV extends (_Yb = Go, _Xb = _, _Yb) {
    constructor(t, n, r) {
      super(t, "string", "PgTime"), this.withTimezone = n, this.precision = r, this.config.withTimezone = n, this.config.precision = r;
    }
    build(t) {
      return new LV(t, this.config);
    }
  }
  __publicField(IV, _Xb, "PgTimeBuilder");
  class LV extends (__b = J, _Zb = _, __b) {
    withTimezone;
    precision;
    constructor(t, n) {
      super(t, n), this.withTimezone = n.withTimezone, this.precision = n.precision;
    }
    getSQLType() {
      return `time${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
  }
  __publicField(LV, _Zb, "PgTime");
  function jV(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return new IV(n, r.withTimezone ?? false, r.precision);
  }
  class VV extends (_ac = Go, _$b = _, _ac) {
    constructor(t, n, r) {
      super(t, "date", "PgTimestamp"), this.config.withTimezone = n, this.config.precision = r;
    }
    build(t) {
      return new FV(t, this.config);
    }
  }
  __publicField(VV, _$b, "PgTimestampBuilder");
  class FV extends (_cc = J, _bc = _, _cc) {
    withTimezone;
    precision;
    constructor(t, n) {
      super(t, n), this.withTimezone = n.withTimezone, this.precision = n.precision;
    }
    getSQLType() {
      return `timestamp${this.precision === void 0 ? "" : ` (${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
    mapFromDriverValue = (t) => new Date(this.withTimezone ? t : t + "+0000");
    mapToDriverValue = (t) => t.toISOString();
  }
  __publicField(FV, _bc, "PgTimestamp");
  class zV extends (_ec = Go, _dc = _, _ec) {
    constructor(t, n, r) {
      super(t, "string", "PgTimestampString"), this.config.withTimezone = n, this.config.precision = r;
    }
    build(t) {
      return new BV(t, this.config);
    }
  }
  __publicField(zV, _dc, "PgTimestampStringBuilder");
  class BV extends (_gc = J, _fc = _, _gc) {
    withTimezone;
    precision;
    constructor(t, n) {
      super(t, n), this.withTimezone = n.withTimezone, this.precision = n.precision;
    }
    getSQLType() {
      return `timestamp${this.precision === void 0 ? "" : `(${this.precision})`}${this.withTimezone ? " with time zone" : ""}`;
    }
  }
  __publicField(BV, _fc, "PgTimestampString");
  function Bl(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return r?.mode === "string" ? new zV(n, r.withTimezone ?? false, r.precision) : new VV(n, r?.withTimezone ?? false, r?.precision);
  }
  class UV extends (_ic = oe, _hc = _, _ic) {
    constructor(t) {
      super(t, "string", "PgUUID");
    }
    defaultRandom() {
      return this.default(zl`gen_random_uuid()`);
    }
    build(t) {
      return new $V(t, this.config);
    }
  }
  __publicField(UV, _hc, "PgUUIDBuilder");
  class $V extends (_kc = J, _jc = _, _kc) {
    getSQLType() {
      return "uuid";
    }
  }
  __publicField($V, _jc, "PgUUID");
  function Do(e) {
    return new UV(e ?? "");
  }
  class WV extends (_mc = oe, _lc = _, _mc) {
    constructor(t, n) {
      super(t, "string", "PgVarchar"), this.config.length = n.length, this.config.enumValues = n.enum;
    }
    build(t) {
      return new HV(t, this.config);
    }
  }
  __publicField(WV, _lc, "PgVarcharBuilder");
  class HV extends (_oc = J, _nc = _, _oc) {
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
      return this.length === void 0 ? "varchar" : `varchar(${this.length})`;
    }
  }
  __publicField(HV, _nc, "PgVarchar");
  function KV(e, t = {}) {
    const { name: n, config: r } = $e(e, t);
    return new WV(n, r);
  }
  class QV extends (_qc = oe, _pc = _, _qc) {
    constructor(t, n) {
      super(t, "string", "PgBinaryVector"), this.config.dimensions = n.dimensions;
    }
    build(t) {
      return new GV(t, this.config);
    }
  }
  __publicField(QV, _pc, "PgBinaryVectorBuilder");
  class GV extends (_sc = J, _rc = _, _sc) {
    dimensions = this.config.dimensions;
    getSQLType() {
      return `bit(${this.dimensions})`;
    }
  }
  __publicField(GV, _rc, "PgBinaryVector");
  function qV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return new QV(n, r);
  }
  class ZV extends (_uc = oe, _tc = _, _uc) {
    constructor(t, n) {
      super(t, "array", "PgHalfVector"), this.config.dimensions = n.dimensions;
    }
    build(t) {
      return new YV(t, this.config);
    }
  }
  __publicField(ZV, _tc, "PgHalfVectorBuilder");
  class YV extends (_wc = J, _vc = _, _wc) {
    dimensions = this.config.dimensions;
    getSQLType() {
      return `halfvec(${this.dimensions})`;
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      return t.slice(1, -1).split(",").map((n) => Number.parseFloat(n));
    }
  }
  __publicField(YV, _vc, "PgHalfVector");
  function XV(e, t) {
    const { name: n, config: r } = $e(e, t);
    return new ZV(n, r);
  }
  class JV extends (_yc = oe, _xc = _, _yc) {
    constructor(t, n) {
      super(t, "string", "PgSparseVector"), this.config.dimensions = n.dimensions;
    }
    build(t) {
      return new eF(t, this.config);
    }
  }
  __publicField(JV, _xc, "PgSparseVectorBuilder");
  class eF extends (_Ac = J, _zc = _, _Ac) {
    dimensions = this.config.dimensions;
    getSQLType() {
      return `sparsevec(${this.dimensions})`;
    }
  }
  __publicField(eF, _zc, "PgSparseVector");
  function tF(e, t) {
    const { name: n, config: r } = $e(e, t);
    return new JV(n, r);
  }
  class nF extends (_Cc = oe, _Bc = _, _Cc) {
    constructor(t, n) {
      super(t, "array", "PgVector"), this.config.dimensions = n.dimensions;
    }
    build(t) {
      return new rF(t, this.config);
    }
  }
  __publicField(nF, _Bc, "PgVectorBuilder");
  class rF extends (_Ec = J, _Dc = _, _Ec) {
    dimensions = this.config.dimensions;
    getSQLType() {
      return `vector(${this.dimensions})`;
    }
    mapToDriverValue(t) {
      return JSON.stringify(t);
    }
    mapFromDriverValue(t) {
      return t.slice(1, -1).split(",").map((n) => Number.parseFloat(n));
    }
  }
  __publicField(rF, _Dc, "PgVector");
  function sF(e, t) {
    const { name: n, config: r } = $e(e, t);
    return new nF(n, r);
  }
  function iF() {
    return {
      bigint: fj,
      bigserial: yj,
      boolean: ku,
      char: bj,
      cidr: Ej,
      customType: _j,
      date: Mj,
      doublePrecision: Lj,
      inet: Fj,
      integer: bt,
      interval: Wj,
      json: Qj,
      jsonb: Zj,
      line: tV,
      macaddr: sV,
      macaddr8: aV,
      numeric: cV,
      point: mV,
      geometry: SV,
      real: CV,
      serial: Hb,
      smallint: AV,
      smallserial: DV,
      text: kn,
      time: jV,
      timestamp: Bl,
      uuid: Do,
      varchar: KV,
      bit: qV,
      halfvec: XV,
      sparsevec: tF,
      vector: sF
    };
  }
  const xf = Symbol.for("drizzle:PgInlineForeignKeys"), ov = Symbol.for("drizzle:EnableRLS");
  class av extends St {
    [(_Fc = _, xf)] = [];
    [ov] = false;
    [St.Symbol.ExtraConfigBuilder] = void 0;
  }
  __publicField(av, _Fc, "PgTable");
  __publicField(av, "Symbol", Object.assign({}, St.Symbol, {
    InlineForeignKeys: xf,
    EnableRLS: ov
  }));
  function oF(e, t, n, r, s = e) {
    const i = new av(e, r, s), o = typeof t == "function" ? t(iF()) : t, a = Object.fromEntries(Object.entries(o).map(([c, d]) => {
      const f = d;
      f.setName(c);
      const p = f.build(i);
      return i[xf].push(...f.buildForeignKeys(p, i)), [
        c,
        p
      ];
    })), l = Object.fromEntries(Object.entries(o).map(([c, d]) => {
      const f = d;
      f.setName(c);
      const p = f.buildExtraConfigColumn(i);
      return [
        c,
        p
      ];
    })), u = Object.assign(i, a);
    return u[St.Symbol.Columns] = a, u[St.Symbol.ExtraConfigColumns] = l, Object.assign(u, {
      enableRLS: () => (u[av.Symbol.EnableRLS] = true, u)
    });
  }
  const _u = (e, t, n) => oF(e, t, n, void 0), we = {
    INT8_MIN: -128,
    INT8_MAX: 127,
    INT8_UNSIGNED_MAX: 255,
    INT16_MIN: -32768,
    INT16_MAX: 32767,
    INT16_UNSIGNED_MAX: 65535,
    INT24_MIN: -8388608,
    INT24_MAX: 8388607,
    INT24_UNSIGNED_MAX: 16777215,
    INT32_MIN: -2147483648,
    INT32_MAX: 2147483647,
    INT32_UNSIGNED_MAX: 4294967295,
    INT48_MIN: -140737488355328,
    INT48_MAX: 140737488355327,
    INT48_UNSIGNED_MAX: 281474976710655,
    INT64_MIN: -9223372036854775808n,
    INT64_MAX: 9223372036854775807n,
    INT64_UNSIGNED_MAX: 18446744073709551615n
  };
  function Ne(e, t) {
    return t.includes(e.columnType);
  }
  function aF(e) {
    return "enumValues" in e && Array.isArray(e.enumValues) && e.enumValues.length > 0;
  }
  const lF = Pp([
    q(),
    Pe(),
    Ht(),
    Mb()
  ]), uF = Pp([
    lF,
    Ob(Vl()),
    Os(Vl())
  ]), cF = Eu((e) => e instanceof Buffer);
  function Kb(e, t) {
    const n = t?.zodInstance ?? HL, r = t?.coerce ?? {};
    let s;
    return aF(e) && (s = e.enumValues.length ? n.enum(e.enumValues) : n.string()), s || (Ne(e, [
      "PgGeometry",
      "PgPointTuple"
    ]) ? s = n.tuple([
      n.number(),
      n.number()
    ]) : Ne(e, [
      "PgGeometryObject",
      "PgPointObject"
    ]) ? s = n.object({
      x: n.number(),
      y: n.number()
    }) : Ne(e, [
      "PgHalfVector",
      "PgVector"
    ]) ? (s = n.array(n.number()), s = e.dimensions ? s.length(e.dimensions) : s) : Ne(e, [
      "PgLine"
    ]) ? s = n.tuple([
      n.number(),
      n.number(),
      n.number()
    ]) : Ne(e, [
      "PgLineABC"
    ]) ? s = n.object({
      a: n.number(),
      b: n.number(),
      c: n.number()
    }) : Ne(e, [
      "PgArray"
    ]) ? (s = n.array(Kb(e.baseColumn, n)), s = e.size ? s.length(e.size) : s) : e.dataType === "array" ? s = n.array(n.any()) : e.dataType === "number" ? s = dF(e, n, r) : e.dataType === "bigint" ? s = fF(e, n, r) : e.dataType === "boolean" ? s = r === true || r.boolean ? n.coerce.boolean() : n.boolean() : e.dataType === "date" ? s = r === true || r.date ? n.coerce.date() : n.date() : e.dataType === "string" ? s = hF(e, n, r) : e.dataType === "json" ? s = uF : e.dataType === "custom" ? s = n.any() : e.dataType === "buffer" && (s = cF)), s || (s = n.any()), s;
  }
  function dF(e, t, n) {
    let r = e.getSQLType().includes("unsigned"), s, i, o = false;
    Ne(e, [
      "MySqlTinyInt",
      "SingleStoreTinyInt"
    ]) ? (s = r ? 0 : we.INT8_MIN, i = r ? we.INT8_UNSIGNED_MAX : we.INT8_MAX, o = true) : Ne(e, [
      "PgSmallInt",
      "PgSmallSerial",
      "MySqlSmallInt",
      "SingleStoreSmallInt"
    ]) ? (s = r ? 0 : we.INT16_MIN, i = r ? we.INT16_UNSIGNED_MAX : we.INT16_MAX, o = true) : Ne(e, [
      "PgReal",
      "MySqlFloat",
      "MySqlMediumInt",
      "SingleStoreMediumInt",
      "SingleStoreFloat"
    ]) ? (s = r ? 0 : we.INT24_MIN, i = r ? we.INT24_UNSIGNED_MAX : we.INT24_MAX, o = Ne(e, [
      "MySqlMediumInt",
      "SingleStoreMediumInt"
    ])) : Ne(e, [
      "PgInteger",
      "PgSerial",
      "MySqlInt",
      "SingleStoreInt"
    ]) ? (s = r ? 0 : we.INT32_MIN, i = r ? we.INT32_UNSIGNED_MAX : we.INT32_MAX, o = true) : Ne(e, [
      "PgDoublePrecision",
      "MySqlReal",
      "MySqlDouble",
      "SingleStoreReal",
      "SingleStoreDouble",
      "SQLiteReal"
    ]) ? (s = r ? 0 : we.INT48_MIN, i = r ? we.INT48_UNSIGNED_MAX : we.INT48_MAX) : Ne(e, [
      "PgBigInt53",
      "PgBigSerial53",
      "MySqlBigInt53",
      "MySqlSerial",
      "SingleStoreBigInt53",
      "SingleStoreSerial",
      "SQLiteInteger"
    ]) ? (r = r || Ne(e, [
      "MySqlSerial",
      "SingleStoreSerial"
    ]), s = r ? 0 : Number.MIN_SAFE_INTEGER, i = Number.MAX_SAFE_INTEGER, o = true) : Ne(e, [
      "MySqlYear",
      "SingleStoreYear"
    ]) ? (s = 1901, i = 2155, o = true) : (s = Number.MIN_SAFE_INTEGER, i = Number.MAX_SAFE_INTEGER);
    let a = n === true || n?.number ? t.coerce.number() : t.number();
    return a = a.min(s).max(i), o ? a.int() : a;
  }
  function fF(e, t, n) {
    const r = e.getSQLType().includes("unsigned"), s = r ? 0n : we.INT64_MIN, i = r ? we.INT64_UNSIGNED_MAX : we.INT64_MAX;
    return (n === true || n?.bigint ? t.coerce.bigint() : t.bigint()).min(s).max(i);
  }
  function hF(e, t, n) {
    if (Ne(e, [
      "PgUUID"
    ])) return t.string().uuid();
    let r, s, i = false;
    Ne(e, [
      "PgVarchar",
      "SQLiteText"
    ]) ? r = e.length : Ne(e, [
      "MySqlVarChar",
      "SingleStoreVarChar"
    ]) ? r = e.length ?? we.INT16_UNSIGNED_MAX : Ne(e, [
      "MySqlText",
      "SingleStoreText"
    ]) && (e.textType === "longtext" ? r = we.INT32_UNSIGNED_MAX : e.textType === "mediumtext" ? r = we.INT24_UNSIGNED_MAX : e.textType === "text" ? r = we.INT16_UNSIGNED_MAX : r = we.INT8_UNSIGNED_MAX), Ne(e, [
      "PgChar",
      "MySqlChar",
      "SingleStoreChar"
    ]) && (r = e.length, i = true), Ne(e, [
      "PgBinaryVector"
    ]) && (s = /^[01]+$/, r = e.dimensions);
    let o = n === true || n?.string ? t.coerce.string() : t.string();
    return o = s ? o.regex(s) : o, r && i ? o.length(r) : r ? o.max(r) : o;
  }
  function Qb(e) {
    return Fb(e) ? oj(e) : aj(e);
  }
  function Gb(e, t, n, r) {
    const s = {};
    for (const [i, o] of Object.entries(e)) {
      if (!He(o, No) && !He(o, Ae) && !He(o, Ae.Aliased) && typeof o == "object") {
        const d = Fb(o) || ij(o) ? Qb(o) : o;
        s[i] = Gb(d, t[i] ?? {}, n, r);
        continue;
      }
      const a = t[i];
      if (a !== void 0 && typeof a != "function") {
        s[i] = a;
        continue;
      }
      const l = He(o, No) ? o : void 0, u = l ? Kb(l, r) : Vl(), c = typeof a == "function" ? a(u) : u;
      n.never(l) || (s[i] = c, l && (n.nullable(l) && (s[i] = s[i].nullable()), n.optional(l) && (s[i] = s[i].optional())));
    }
    return se(s);
  }
  const pF = {
    never: (e) => e?.generated?.type === "always" || e?.generatedIdentity?.type === "always",
    optional: (e) => !e.notNull || e.notNull && e.hasDefault,
    nullable: (e) => !e.notNull
  }, qb = (e, t) => {
    const n = Qb(e);
    return Gb(n, {}, pF);
  }, Zb = _u("vaults", {
    id: Do("id").primaryKey().defaultRandom(),
    shortCode: kn("short_code").unique(),
    lookupId: kn("lookup_id").unique(),
    wrappedKey: kn("wrapped_key"),
    encryptedMetadata: kn("encrypted_metadata").notNull(),
    createdAt: Bl("created_at").defaultNow().notNull(),
    expiresAt: Bl("expires_at").notNull(),
    maxDownloads: bt("max_downloads").default(1).notNull(),
    downloadCount: bt("download_count").default(0).notNull(),
    isDeleted: ku("is_deleted").default(false).notNull(),
    encryptedClipboardText: kn("encrypted_clipboard_text")
  }), Yb = _u("files", {
    id: Do("id").primaryKey().defaultRandom(),
    vaultId: Do("vault_id").references(() => Zb.id, {
      onDelete: "cascade"
    }).notNull(),
    fileId: kn("file_id").notNull(),
    chunkCount: bt("chunk_count").notNull(),
    totalSize: bt("total_size").notNull(),
    isCompressed: ku("is_compressed").default(false).notNull(),
    originalSize: bt("original_size"),
    maxDownloads: bt("max_downloads").default(1).notNull(),
    downloadCount: bt("download_count").default(0).notNull()
  });
  _u("chunks", {
    id: Hb("id").primaryKey(),
    fileId: Do("file_id").references(() => Yb.id, {
      onDelete: "cascade"
    }).notNull(),
    chunkIndex: bt("chunk_index").notNull(),
    storagePath: kn("storage_path"),
    size: bt("size").notNull(),
    isUploaded: ku("is_uploaded").default(false).notNull()
  });
  _u("email_usage", {
    date: kn("date").primaryKey(),
    resendCount: bt("resend_count").default(0).notNull(),
    brevoCount: bt("brevo_count").default(0).notNull(),
    msg91Count: bt("msg91_count").default(0).notNull(),
    lastUpdated: Bl("last_updated").defaultNow()
  });
  qb(Zb).omit({
    id: true,
    shortCode: true,
    createdAt: true,
    downloadCount: true,
    isDeleted: true
  });
  qb(Yb).omit({
    id: true,
    vaultId: true
  });
  const mF = se({
    expiresIn: Pe().min(1).max(168),
    maxDownloads: Pe().min(1).max(100),
    encryptedMetadata: q(),
    lookupId: q().length(3).optional(),
    wrappedKey: q().optional(),
    files: Os(se({
      fileId: q(),
      chunks: Pe(),
      size: Pe(),
      isCompressed: Ht().default(false),
      originalSize: Pe().optional(),
      maxDownloads: Pe().min(1).max(100).optional()
    })),
    encryptedClipboardText: q().optional()
  });
  se({
    message: q(),
    field: q().optional()
  }), se({
    message: q()
  }), se({
    message: q()
  });
  const fe = {
    vaults: {
      create: {
        method: "POST",
        path: "/api/vaults",
        input: mF,
        responses: {
          201: se({
            id: q(),
            shortCode: q().optional(),
            expiresAt: q(),
            directLink: q()
          }),
          409: se({
            message: q(),
            code: q().optional()
          })
        }
      },
      get: {
        path: "/api/vaults/:id",
        responses: {
          200: Eu(),
          410: se({
            message: q()
          })
        }
      },
      resolveCode: {
        responses: {
          200: se({
            id: q()
          })
        }
      },
      download: {
        path: "/api/vaults/:id/download",
        responses: {
          200: se({
            success: Ht(),
            remainingDownloads: Pe()
          }),
          403: se({
            message: q()
          })
        }
      },
      downloadFile: {
        path: "/api/vaults/:id/files/:fileId/download",
        input: se({
          fileIds: Os(q()).optional()
        }),
        responses: {
          200: se({
            success: Ht(),
            files: Os(se({
              fileId: q(),
              downloadCount: Pe(),
              maxDownloads: Pe(),
              remainingDownloads: Pe(),
              isExhausted: Ht()
            })),
            vaultExhausted: Ht()
          }),
          403: se({
            message: q()
          })
        }
      },
      codeLookup: {
        path: "/api/vault/code/:lookupId",
        responses: {
          200: se({
            id: q(),
            wrappedKey: q(),
            encryptedMetadata: q(),
            encryptedClipboardText: q().nullish(),
            expiresAt: q(),
            maxDownloads: Pe(),
            downloadCount: Pe(),
            files: Os(se({
              fileId: q(),
              chunkCount: Pe(),
              totalSize: Pe(),
              maxDownloads: Pe(),
              downloadCount: Pe(),
              remainingDownloads: Pe()
            }))
          }),
          410: se({
            message: q()
          })
        }
      },
      email: {
        input: se({
          to: q().email(),
          senderName: q().optional()
        }),
        responses: {
          200: se({
            success: Ht(),
            remainingEmails: Pe(),
            previewUrl: q().optional()
          }),
          429: se({
            message: q()
          })
        }
      },
      updateClipboard: {
        method: "PUT",
        path: "/api/vault/code/:lookupId/clipboard",
        input: se({
          encryptedClipboardText: q(),
          wrappedKey: q()
        }),
        responses: {
          200: se({
            success: Ht(),
            updatedAt: q()
          }),
          410: se({
            message: q()
          })
        }
      },
      getClipboard: {
        path: "/api/vault/code/:lookupId/clipboard",
        responses: {
          200: se({
            encryptedClipboardText: q().nullish(),
            updatedAt: q().optional()
          }),
          410: se({
            message: q()
          })
        }
      }
    },
    chunks: {
      getUploadUrl: {
        method: "POST",
        path: "/api/vaults/:id/files/:fileId/chunks/:chunkIndex/upload-url",
        input: se({
          size: Pe()
        }),
        responses: {
          200: se({
            uploadUrl: q(),
            storagePath: q()
          })
        }
      },
      markUploaded: {
        method: "PUT",
        path: "/api/vaults/:id/files/:fileId/chunks/:chunkIndex/status",
        input: se({
          storagePath: q()
        }),
        responses: {
          200: se({
            success: Ht()
          })
        }
      },
      getDownloadUrl: {
        path: "/api/vaults/:id/files/:fileId/chunks/:chunkIndex/download-url",
        responses: {
          200: se({
            downloadUrl: q()
          })
        }
      }
    }
  };
  function $n(e, t) {
    let n = e;
    return t && Object.entries(t).forEach(([r, s]) => {
      n.includes(`:${r}`) && (n = n.replace(`:${r}`, String(s)));
    }), n;
  }
  I3 = function(e) {
    return ex({
      queryKey: [
        fe.vaults.get.path,
        e
      ],
      queryFn: async () => {
        const t = $n(fe.vaults.get.path, {
          id: e
        }), n = await fetch(t);
        if (n.status === 404) return null;
        if (n.status === 410) throw new Error("This vault has expired or been deleted.");
        if (!n.ok) throw new Error("Failed to fetch vault");
        return fe.vaults.get.responses[200].parse(await n.json());
      },
      enabled: !!e,
      retry: false
    });
  };
  gF = function() {
    kh();
    const { toast: e } = _h();
    return Tr({
      mutationFn: async (t) => {
        const n = fe.vaults.create.input.parse(t), r = await fetch(fe.vaults.create.path, {
          method: fe.vaults.create.method,
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(n)
        });
        if (!r.ok) {
          const s = await r.json().catch(() => null), i = typeof s?.message == "string" ? s.message : r.status === 400 ? "Validation failed" : "Failed to create vault", o = new Error(i);
          throw o.status = r.status, typeof s?.code == "string" && (o.code = s.code), o;
        }
        return fe.vaults.create.responses[201].parse(await r.json());
      },
      onError: (t) => {
        e({
          variant: "destructive",
          title: "Creation Failed",
          description: t.message
        });
      }
    });
  };
  L3 = function() {
    return Tr({
      mutationFn: async ({ vaultId: e, fileId: t, chunkIndex: n, size: r }) => {
        const s = $n(fe.chunks.getUploadUrl.path, {
          id: e,
          fileId: t,
          chunkIndex: n
        }), i = await fetch(s, {
          method: fe.chunks.getUploadUrl.method,
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            size: r
          })
        });
        if (!i.ok) throw new Error("Failed to get upload URL");
        return fe.chunks.getUploadUrl.responses[200].parse(await i.json());
      }
    });
  };
  j3 = function() {
    return Tr({
      mutationFn: async ({ vaultId: e, fileId: t, chunkIndex: n, storagePath: r }) => {
        const s = $n(fe.chunks.markUploaded.path, {
          id: e,
          fileId: t,
          chunkIndex: n
        }), i = await fetch(s, {
          method: fe.chunks.markUploaded.method,
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            storagePath: r
          })
        });
        if (!i.ok) throw new Error("Failed to confirm upload");
        return fe.chunks.markUploaded.responses[200].parse(await i.json());
      }
    });
  };
  V3 = function() {
    return Tr({
      mutationFn: async ({ vaultId: e, fileId: t, chunkIndex: n }) => {
        const r = $n(fe.chunks.getDownloadUrl.path, {
          id: e,
          fileId: t,
          chunkIndex: n
        }), s = await fetch(r);
        if (!s.ok) throw new Error("Failed to get download URL");
        return fe.chunks.getDownloadUrl.responses[200].parse(await s.json());
      }
    });
  };
  F3 = function() {
    return Tr({
      mutationFn: async (e) => {
        const t = $n(fe.vaults.download.path, {
          id: e
        }), n = await fetch(t, {
          method: "POST"
        });
        if (!n.ok) throw new Error("Failed to track download");
        return await n.json();
      }
    });
  };
  z3 = function() {
    return Tr({
      mutationFn: async ({ vaultId: e, fileId: t, fileIds: n }) => {
        const r = $n(fe.vaults.downloadFile.path, {
          id: e,
          fileId: t
        }), s = await fetch(r, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            fileIds: n || [
              t
            ]
          })
        });
        if (s.status === 403) {
          const i = await s.json();
          throw new Error(i.message || "Download limit exceeded for one or more files");
        }
        if (!s.ok) throw new Error("Failed to track file download");
        return fe.vaults.downloadFile.responses[200].parse(await s.json());
      }
    });
  };
  B3 = function() {
    return Tr({
      mutationFn: async (e) => {
        const t = $n(fe.vaults.codeLookup.path, {
          lookupId: e
        }), n = await fetch(t);
        if (n.status === 404) throw new Error("Invalid code or vault expired");
        if (n.status === 410) throw new Error("Vault expired or download limit reached");
        if (!n.ok) throw new Error("Failed to lookup vault");
        return fe.vaults.codeLookup.responses[200].parse(await n.json());
      }
    });
  };
  yF = function() {
    return Tr({
      mutationFn: async ({ lookupId: e, encryptedClipboardText: t, wrappedKey: n }) => {
        const r = $n(fe.vaults.updateClipboard.path, {
          lookupId: e
        }), s = await fetch(r, {
          method: fe.vaults.updateClipboard.method,
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            encryptedClipboardText: t,
            wrappedKey: n
          })
        });
        if (!s.ok) {
          const i = await s.json().catch(() => null), o = typeof i?.message == "string" ? i.message : s.status === 413 ? "Clipboard payload too large. Remove some attachments and try again." : "Failed to update clipboard";
          throw new Error(o);
        }
        return fe.vaults.updateClipboard.responses[200].parse(await s.json());
      }
    });
  };
  vF = function(e, t) {
    return ex({
      queryKey: [
        fe.vaults.getClipboard.path,
        e
      ],
      queryFn: async () => {
        const n = $n(fe.vaults.getClipboard.path, {
          lookupId: e
        }), r = await fetch(n);
        if (r.status === 404) return null;
        if (r.status === 410) throw new Error("Vault expired");
        if (!r.ok) throw new Error("Sync failed");
        return fe.vaults.getClipboard.responses[200].parse(await r.json());
      },
      enabled: t && !!e,
      refetchInterval: 3e3,
      retry: false
    });
  };
  wF = async function() {
    return window.crypto.subtle.generateKey({
      name: "AES-GCM",
      length: 256
    }, true, [
      "encrypt",
      "decrypt"
    ]);
  };
  U3 = async function(e) {
    const t = await window.crypto.subtle.exportKey("raw", e);
    return Ul(t);
  };
  $3 = async function(e) {
    const t = Mo(e);
    return window.crypto.subtle.importKey("raw", t, "AES-GCM", true, [
      "encrypt",
      "decrypt"
    ]);
  };
  xF = async function(e, t) {
    const n = window.crypto.getRandomValues(new Uint8Array(12)), r = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, t, e);
    return {
      iv: n,
      encryptedData: r
    };
  };
  SF = async function(e, t, n) {
    return window.crypto.subtle.decrypt({
      name: "AES-GCM",
      iv: t
    }, n, e);
  };
  Xb = async function(e, t) {
    const r = new TextEncoder().encode(JSON.stringify(e)), { iv: s, encryptedData: i } = await xF(r, t);
    return JSON.stringify({
      iv: Ul(s.buffer),
      data: Ul(i)
    });
  };
  bF = async function(e, t) {
    try {
      const { iv: n, data: r } = JSON.parse(e), s = Mo(n), i = Mo(r), o = await SF(i, new Uint8Array(s), t), a = new TextDecoder();
      return JSON.parse(a.decode(o));
    } catch (n) {
      throw console.error("Decryption failed", n), new Error("Failed to decrypt metadata. Invalid key or corrupted data.");
    }
  };
  function TF() {
    return {
      version: 2,
      plainText: "",
      attachments: [],
      timestamp: Date.now()
    };
  }
  function Sf(e) {
    if (!e || typeof e != "object") return null;
    const t = typeof e.dataBase64 == "string" ? e.dataBase64 : "";
    return t ? {
      id: typeof e.id == "string" && e.id.length > 0 ? e.id : _F(),
      name: typeof e.name == "string" && e.name.length > 0 ? e.name : "pasted-file",
      mimeType: typeof e.mimeType == "string" && e.mimeType.length > 0 ? e.mimeType : "application/octet-stream",
      size: typeof e.size == "number" && Number.isFinite(e.size) ? e.size : Mo(t).byteLength,
      dataBase64: t
    } : null;
  }
  function CF(e) {
    const t = TF(), n = (r) => !!r;
    if (e && typeof e.clipboardText == "string") {
      const r = Array.isArray(e.attachments) ? e.attachments.map(Sf).filter(n) : [];
      return {
        version: 2,
        plainText: e.clipboardText,
        attachments: r,
        timestamp: typeof e.timestamp == "number" ? e.timestamp : Date.now()
      };
    }
    return !e || typeof e != "object" ? t : {
      version: 2,
      plainText: typeof e.plainText == "string" ? e.plainText : "",
      attachments: Array.isArray(e.attachments) ? e.attachments.map(Sf).filter(n) : [],
      timestamp: typeof e.timestamp == "number" ? e.timestamp : Date.now()
    };
  }
  async function EF(e, t) {
    const n = {
      version: 2,
      plainText: e.plainText || "",
      attachments: Array.isArray(e.attachments) ? e.attachments.map(Sf).filter((r) => !!r) : [],
      timestamp: typeof e.timestamp == "number" ? e.timestamp : Date.now()
    };
    return Xb(n, t);
  }
  PF = async function(e, t) {
    const n = await bF(e, t);
    return CF(n);
  };
  lv = async function(e, t) {
    return EF({
      plainText: e,
      attachments: [],
      timestamp: Date.now()
    }, t);
  };
  kF = async function(e, t) {
    return (await PF(e, t)).plainText;
  };
  function Ul(e) {
    const t = new Uint8Array(e), n = 32768;
    let r = "";
    for (let s = 0; s < t.length; s += n) {
      const i = t.subarray(s, s + n);
      r += String.fromCharCode.apply(null, Array.from(i));
    }
    return window.btoa(r);
  }
  function Mo(e) {
    const t = window.atob(e), n = t.length, r = new Uint8Array(n);
    for (let s = 0; s < n; s++) r[s] = t.charCodeAt(s);
    return r.buffer;
  }
  _F = function() {
    return crypto.randomUUID();
  };
  const AF = 1e5, RF = "VaultBridge-PIN-v1";
  NF = function() {
    const e = Array.from({
      length: 6
    }, () => Math.floor(Math.random() * 10).toString()).join("");
    return {
      fullCode: e,
      lookupId: e.slice(0, 3),
      pin: e.slice(3, 6)
    };
  };
  async function Jb(e) {
    const t = new TextEncoder(), n = t.encode(e), r = await window.crypto.subtle.importKey("raw", n, "PBKDF2", false, [
      "deriveKey"
    ]), s = t.encode(`${RF}-${e}`);
    return window.crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt: s,
      iterations: AF,
      hash: "SHA-256"
    }, r, {
      name: "AES-KW",
      length: 256
    }, false, [
      "wrapKey",
      "unwrapKey"
    ]);
  }
  DF = async function(e, t) {
    const n = await Jb(t), r = await window.crypto.subtle.wrapKey("raw", e, n, "AES-KW");
    return Ul(r);
  };
  W3 = async function(e, t) {
    const n = await Jb(t), r = Mo(e);
    return window.crypto.subtle.unwrapKey("raw", r, n, "AES-KW", {
      name: "AES-GCM",
      length: 256
    }, true, [
      "encrypt",
      "decrypt"
    ]);
  };
  const _p = "vaultbridge_history", MF = 25;
  function OF() {
    const e = navigator.userAgent;
    let t = "Unknown", n = "Unknown";
    e.includes("Firefox/") ? t = "Firefox" : e.includes("Edg/") ? t = "Edge" : e.includes("OPR/") || e.includes("Opera") ? t = "Opera" : e.includes("Chrome/") && !e.includes("Edg/") ? t = "Chrome" : e.includes("Safari/") && !e.includes("Chrome/") && (t = "Safari"), e.includes("Win") ? n = "Windows" : e.includes("Mac") ? n = "macOS" : e.includes("Linux") ? n = "Linux" : e.includes("Android") ? n = "Android" : (e.includes("iPhone") || e.includes("iPad")) && (n = "iOS");
    const r = /Mobi|Android|iPhone|iPad/i.test(e);
    return {
      browser: t,
      os: n,
      isMobile: r,
      language: navigator.language || "en",
      screenWidth: window.innerWidth,
      timestamp: Date.now()
    };
  }
  function IF() {
    try {
      const e = localStorage.getItem(_p);
      return e ? JSON.parse(e) : [];
    } catch {
      return [];
    }
  }
  function Rc(e) {
    try {
      const t = [
        ...e
      ].sort((n, r) => r.createdAt - n.createdAt).slice(0, MF);
      localStorage.setItem(_p, JSON.stringify(t));
    } catch (t) {
      console.error("[VaultHistory] Failed to save:", t);
    }
  }
  function Nc(e) {
    return e.status === "burned" ? "burned" : Date.now() >= e.expiresAt ? "expired" : e.maxDownloads > 0 && e.downloadCount >= e.maxDownloads ? "exhausted" : "active";
  }
  LF = function() {
    const [e, t] = h.useState([]);
    h.useEffect(() => {
      const c = IF().map((d) => ({
        ...d,
        status: Nc(d)
      }));
      t(c);
    }, []), h.useEffect(() => {
      const c = setInterval(() => {
        t((d) => d.map((f) => ({
          ...f,
          status: Nc(f)
        })));
      }, 3e4);
      return () => clearInterval(c);
    }, []);
    const n = h.useCallback((c) => {
      const d = {
        ...c,
        id: `vh_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        device: OF(),
        status: "active"
      };
      return t((f) => {
        const p = f.filter((g) => !(g.accessCode === d.accessCode && g.action === d.action)), w = [
          d,
          ...p
        ];
        return Rc(w), w;
      }), d.id;
    }, []), r = h.useCallback((c, d, f) => {
      t((p) => {
        const w = p.map((g) => {
          if (g.accessCode === c && g.action === d) {
            const x = {
              ...g,
              ...f
            };
            return {
              ...x,
              status: Nc(x)
            };
          }
          return g;
        });
        return Rc(w), w;
      });
    }, []), s = h.useCallback((c) => {
      t((d) => {
        const f = d.filter((p) => p.id !== c);
        return Rc(f), f;
      });
    }, []), i = h.useCallback(() => {
      localStorage.removeItem(_p), t([]);
    }, []), o = e.filter((c) => c.status === "active"), a = e.filter((c) => c.action === "sent"), l = e.filter((c) => c.action === "received"), u = e.filter((c) => c.type === "clipboard");
    return {
      records: e,
      activeRecords: o,
      sentRecords: a,
      receivedRecords: l,
      clipboardRecords: u,
      addRecord: n,
      updateRecord: r,
      removeRecord: s,
      clearAll: i
    };
  };
  let Dc, Mc, uv, jF;
  Dc = "focusScope.autoFocusOnMount";
  Mc = "focusScope.autoFocusOnUnmount";
  uv = {
    bubbles: false,
    cancelable: true
  };
  jF = "FocusScope";
  eT = h.forwardRef((e, t) => {
    const { loop: n = false, trapped: r = false, onMountAutoFocus: s, onUnmountAutoFocus: i, ...o } = e, [a, l] = h.useState(null), u = mn(s), c = mn(i), d = h.useRef(null), f = Me(t, (g) => l(g)), p = h.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    h.useEffect(() => {
      if (r) {
        let g = function(v) {
          if (p.paused || !a) return;
          const b = v.target;
          a.contains(b) ? d.current = b : Gn(d.current, {
            select: true
          });
        }, x = function(v) {
          if (p.paused || !a) return;
          const b = v.relatedTarget;
          b !== null && (a.contains(b) || Gn(d.current, {
            select: true
          }));
        }, m = function(v) {
          if (document.activeElement === document.body) for (const T of v) T.removedNodes.length > 0 && Gn(a);
        };
        document.addEventListener("focusin", g), document.addEventListener("focusout", x);
        const y = new MutationObserver(m);
        return a && y.observe(a, {
          childList: true,
          subtree: true
        }), () => {
          document.removeEventListener("focusin", g), document.removeEventListener("focusout", x), y.disconnect();
        };
      }
    }, [
      r,
      a,
      p.paused
    ]), h.useEffect(() => {
      if (a) {
        dv.add(p);
        const g = document.activeElement;
        if (!a.contains(g)) {
          const m = new CustomEvent(Dc, uv);
          a.addEventListener(Dc, u), a.dispatchEvent(m), m.defaultPrevented || (VF($F(tT(a)), {
            select: true
          }), document.activeElement === g && Gn(a));
        }
        return () => {
          a.removeEventListener(Dc, u), setTimeout(() => {
            const m = new CustomEvent(Mc, uv);
            a.addEventListener(Mc, c), a.dispatchEvent(m), m.defaultPrevented || Gn(g ?? document.body, {
              select: true
            }), a.removeEventListener(Mc, c), dv.remove(p);
          }, 0);
        };
      }
    }, [
      a,
      u,
      c,
      p
    ]);
    const w = h.useCallback((g) => {
      if (!n && !r || p.paused) return;
      const x = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey, m = document.activeElement;
      if (x && m) {
        const y = g.currentTarget, [v, b] = FF(y);
        v && b ? !g.shiftKey && m === b ? (g.preventDefault(), n && Gn(v, {
          select: true
        })) : g.shiftKey && m === v && (g.preventDefault(), n && Gn(b, {
          select: true
        })) : m === y && g.preventDefault();
      }
    }, [
      n,
      r,
      p.paused
    ]);
    return S.jsx(ye.div, {
      tabIndex: -1,
      ...o,
      ref: f,
      onKeyDown: w
    });
  });
  eT.displayName = jF;
  function VF(e, { select: t = false } = {}) {
    const n = document.activeElement;
    for (const r of e) if (Gn(r, {
      select: t
    }), document.activeElement !== n) return;
  }
  function FF(e) {
    const t = tT(e), n = cv(t, e), r = cv(t.reverse(), e);
    return [
      n,
      r
    ];
  }
  function tT(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const s = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function cv(e, t) {
    for (const n of e) if (!zF(n, {
      upTo: t
    })) return n;
  }
  function zF(e, { upTo: t }) {
    if (getComputedStyle(e).visibility === "hidden") return true;
    for (; e; ) {
      if (t !== void 0 && e === t) return false;
      if (getComputedStyle(e).display === "none") return true;
      e = e.parentElement;
    }
    return false;
  }
  function BF(e) {
    return e instanceof HTMLInputElement && "select" in e;
  }
  function Gn(e, { select: t = false } = {}) {
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({
        preventScroll: true
      }), e !== n && BF(e) && t && e.select();
    }
  }
  var dv = UF();
  function UF() {
    let e = [];
    return {
      add(t) {
        const n = e[0];
        t !== n && n?.pause(), e = fv(e, t), e.unshift(t);
      },
      remove(t) {
        e = fv(e, t), e[0]?.resume();
      }
    };
  }
  function fv(e, t) {
    const n = [
      ...e
    ], r = n.indexOf(t);
    return r !== -1 && n.splice(r, 1), n;
  }
  function $F(e) {
    return e.filter((t) => t.tagName !== "A");
  }
  var Oc = 0;
  WF = function() {
    h.useEffect(() => {
      const e = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", e[0] ?? hv()), document.body.insertAdjacentElement("beforeend", e[1] ?? hv()), Oc++, () => {
        Oc === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Oc--;
      };
    }, []);
  };
  function hv() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
  }
  var an = function() {
    return an = Object.assign || function(t) {
      for (var n, r = 1, s = arguments.length; r < s; r++) {
        n = arguments[r];
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
      }
      return t;
    }, an.apply(this, arguments);
  };
  function nT(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
    return n;
  }
  function HF(e, t, n) {
    if (n || arguments.length === 2) for (var r = 0, s = t.length, i; r < s; r++) (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
    return e.concat(i || Array.prototype.slice.call(t));
  }
  var Ha = "right-scroll-bar-position", Ka = "width-before-scroll-bar", KF = "with-scroll-bars-hidden", QF = "--removed-body-scroll-bar-size";
  function Ic(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t), e;
  }
  function GF(e, t) {
    var n = h.useState(function() {
      return {
        value: e,
        callback: t,
        facade: {
          get current() {
            return n.value;
          },
          set current(r) {
            var s = n.value;
            s !== r && (n.value = r, n.callback(r, s));
          }
        }
      };
    })[0];
    return n.callback = t, n.facade;
  }
  var qF = typeof window < "u" ? h.useLayoutEffect : h.useEffect, pv = /* @__PURE__ */ new WeakMap();
  function ZF(e, t) {
    var n = GF(null, function(r) {
      return e.forEach(function(s) {
        return Ic(s, r);
      });
    });
    return qF(function() {
      var r = pv.get(n);
      if (r) {
        var s = new Set(r), i = new Set(e), o = n.current;
        s.forEach(function(a) {
          i.has(a) || Ic(a, null);
        }), i.forEach(function(a) {
          s.has(a) || Ic(a, o);
        });
      }
      pv.set(n, e);
    }, [
      e
    ]), n;
  }
  function YF(e) {
    return e;
  }
  function XF(e, t) {
    t === void 0 && (t = YF);
    var n = [], r = false, s = {
      read: function() {
        if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : e;
      },
      useMedium: function(i) {
        var o = t(i, r);
        return n.push(o), function() {
          n = n.filter(function(a) {
            return a !== o;
          });
        };
      },
      assignSyncMedium: function(i) {
        for (r = true; n.length; ) {
          var o = n;
          n = [], o.forEach(i);
        }
        n = {
          push: function(a) {
            return i(a);
          },
          filter: function() {
            return n;
          }
        };
      },
      assignMedium: function(i) {
        r = true;
        var o = [];
        if (n.length) {
          var a = n;
          n = [], a.forEach(i), o = n;
        }
        var l = function() {
          var c = o;
          o = [], c.forEach(i);
        }, u = function() {
          return Promise.resolve().then(l);
        };
        u(), n = {
          push: function(c) {
            o.push(c), u();
          },
          filter: function(c) {
            return o = o.filter(c), n;
          }
        };
      }
    };
    return s;
  }
  function JF(e) {
    e === void 0 && (e = {});
    var t = XF(null);
    return t.options = an({
      async: true,
      ssr: false
    }, e), t;
  }
  var rT = function(e) {
    var t = e.sideCar, n = nT(e, [
      "sideCar"
    ]);
    if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = t.read();
    if (!r) throw new Error("Sidecar medium not found");
    return h.createElement(r, an({}, n));
  };
  rT.isSideCarExport = true;
  function e4(e, t) {
    return e.useMedium(t), rT;
  }
  var sT = JF(), Lc = function() {
  }, Au = h.forwardRef(function(e, t) {
    var n = h.useRef(null), r = h.useState({
      onScrollCapture: Lc,
      onWheelCapture: Lc,
      onTouchMoveCapture: Lc
    }), s = r[0], i = r[1], o = e.forwardProps, a = e.children, l = e.className, u = e.removeScrollBar, c = e.enabled, d = e.shards, f = e.sideCar, p = e.noRelative, w = e.noIsolation, g = e.inert, x = e.allowPinchZoom, m = e.as, y = m === void 0 ? "div" : m, v = e.gapMode, b = nT(e, [
      "forwardProps",
      "children",
      "className",
      "removeScrollBar",
      "enabled",
      "shards",
      "sideCar",
      "noRelative",
      "noIsolation",
      "inert",
      "allowPinchZoom",
      "as",
      "gapMode"
    ]), T = f, C = ZF([
      n,
      t
    ]), E = an(an({}, b), s);
    return h.createElement(h.Fragment, null, c && h.createElement(T, {
      sideCar: sT,
      removeScrollBar: u,
      shards: d,
      noRelative: p,
      noIsolation: w,
      inert: g,
      setCallbacks: i,
      allowPinchZoom: !!x,
      lockRef: n,
      gapMode: v
    }), o ? h.cloneElement(h.Children.only(a), an(an({}, E), {
      ref: C
    })) : h.createElement(y, an({}, E, {
      className: l,
      ref: C
    }), a));
  });
  Au.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  Au.classNames = {
    fullWidth: Ka,
    zeroRight: Ha
  };
  var t4 = function() {
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
  };
  function n4() {
    if (!document) return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = t4();
    return t && e.setAttribute("nonce", t), e;
  }
  function r4(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
  }
  function s4(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e);
  }
  var i4 = function() {
    var e = 0, t = null;
    return {
      add: function(n) {
        e == 0 && (t = n4()) && (r4(t, n), s4(t)), e++;
      },
      remove: function() {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
      }
    };
  }, o4 = function() {
    var e = i4();
    return function(t, n) {
      h.useEffect(function() {
        return e.add(t), function() {
          e.remove();
        };
      }, [
        t && n
      ]);
    };
  }, iT = function() {
    var e = o4(), t = function(n) {
      var r = n.styles, s = n.dynamic;
      return e(r, s), null;
    };
    return t;
  }, a4 = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  }, jc = function(e) {
    return parseInt(e || "", 10) || 0;
  }, l4 = function(e) {
    var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], s = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [
      jc(n),
      jc(r),
      jc(s)
    ];
  }, u4 = function(e) {
    if (e === void 0 && (e = "margin"), typeof window > "u") return a4;
    var t = l4(e), n = document.documentElement.clientWidth, r = window.innerWidth;
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0])
    };
  }, c4 = iT(), js = "data-scroll-locked", d4 = function(e, t, n, r) {
    var s = e.left, i = e.top, o = e.right, a = e.gap;
    return n === void 0 && (n = "margin"), `
  .`.concat(KF, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(js, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
      t && "position: relative ".concat(r, ";"),
      n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
      n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
    ].filter(Boolean).join(""), `
  }
  
  .`).concat(Ha, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Ka, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Ha, " .").concat(Ha, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Ka, " .").concat(Ka, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(js, `] {
    `).concat(QF, ": ").concat(a, `px;
  }
`);
  }, mv = function() {
    var e = parseInt(document.body.getAttribute(js) || "0", 10);
    return isFinite(e) ? e : 0;
  }, f4 = function() {
    h.useEffect(function() {
      return document.body.setAttribute(js, (mv() + 1).toString()), function() {
        var e = mv() - 1;
        e <= 0 ? document.body.removeAttribute(js) : document.body.setAttribute(js, e.toString());
      };
    }, []);
  }, h4 = function(e) {
    var t = e.noRelative, n = e.noImportant, r = e.gapMode, s = r === void 0 ? "margin" : r;
    f4();
    var i = h.useMemo(function() {
      return u4(s);
    }, [
      s
    ]);
    return h.createElement(c4, {
      styles: d4(i, !t, s, n ? "" : "!important")
    });
  }, bf = false;
  if (typeof window < "u") try {
    var ba = Object.defineProperty({}, "passive", {
      get: function() {
        return bf = true, true;
      }
    });
    window.addEventListener("test", ba, ba), window.removeEventListener("test", ba, ba);
  } catch {
    bf = false;
  }
  var ns = bf ? {
    passive: false
  } : false, p4 = function(e) {
    return e.tagName === "TEXTAREA";
  }, oT = function(e, t) {
    if (!(e instanceof Element)) return false;
    var n = window.getComputedStyle(e);
    return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !p4(e) && n[t] === "visible");
  }, m4 = function(e) {
    return oT(e, "overflowY");
  }, g4 = function(e) {
    return oT(e, "overflowX");
  }, gv = function(e, t) {
    var n = t.ownerDocument, r = t;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var s = aT(e, r);
      if (s) {
        var i = lT(e, r), o = i[1], a = i[2];
        if (o > a) return true;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return false;
  }, y4 = function(e) {
    var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
    return [
      t,
      n,
      r
    ];
  }, v4 = function(e) {
    var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
    return [
      t,
      n,
      r
    ];
  }, aT = function(e, t) {
    return e === "v" ? m4(t) : g4(t);
  }, lT = function(e, t) {
    return e === "v" ? y4(t) : v4(t);
  }, w4 = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1;
  }, x4 = function(e, t, n, r, s) {
    var i = w4(e, window.getComputedStyle(t).direction), o = i * r, a = n.target, l = t.contains(a), u = false, c = o > 0, d = 0, f = 0;
    do {
      if (!a) break;
      var p = lT(e, a), w = p[0], g = p[1], x = p[2], m = g - x - i * w;
      (w || m) && aT(e, a) && (d += m, f += w);
      var y = a.parentNode;
      a = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
    } while (!l && a !== document.body || l && (t.contains(a) || t === a));
    return (c && Math.abs(d) < 1 || !c && Math.abs(f) < 1) && (u = true), u;
  }, Ta = function(e) {
    return "changedTouches" in e ? [
      e.changedTouches[0].clientX,
      e.changedTouches[0].clientY
    ] : [
      0,
      0
    ];
  }, yv = function(e) {
    return [
      e.deltaX,
      e.deltaY
    ];
  }, vv = function(e) {
    return e && "current" in e ? e.current : e;
  }, S4 = function(e, t) {
    return e[0] === t[0] && e[1] === t[1];
  }, b4 = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
  }, T4 = 0, rs = [];
  function C4(e) {
    var t = h.useRef([]), n = h.useRef([
      0,
      0
    ]), r = h.useRef(), s = h.useState(T4++)[0], i = h.useState(iT)[0], o = h.useRef(e);
    h.useEffect(function() {
      o.current = e;
    }, [
      e
    ]), h.useEffect(function() {
      if (e.inert) {
        document.body.classList.add("block-interactivity-".concat(s));
        var g = HF([
          e.lockRef.current
        ], (e.shards || []).map(vv), true).filter(Boolean);
        return g.forEach(function(x) {
          return x.classList.add("allow-interactivity-".concat(s));
        }), function() {
          document.body.classList.remove("block-interactivity-".concat(s)), g.forEach(function(x) {
            return x.classList.remove("allow-interactivity-".concat(s));
          });
        };
      }
    }, [
      e.inert,
      e.lockRef.current,
      e.shards
    ]);
    var a = h.useCallback(function(g, x) {
      if ("touches" in g && g.touches.length === 2 || g.type === "wheel" && g.ctrlKey) return !o.current.allowPinchZoom;
      var m = Ta(g), y = n.current, v = "deltaX" in g ? g.deltaX : y[0] - m[0], b = "deltaY" in g ? g.deltaY : y[1] - m[1], T, C = g.target, E = Math.abs(v) > Math.abs(b) ? "h" : "v";
      if ("touches" in g && E === "h" && C.type === "range") return false;
      var P = window.getSelection(), D = P && P.anchorNode, A = D ? D === C || D.contains(C) : false;
      if (A) return false;
      var M = gv(E, C);
      if (!M) return true;
      if (M ? T = E : (T = E === "v" ? "h" : "v", M = gv(E, C)), !M) return false;
      if (!r.current && "changedTouches" in g && (v || b) && (r.current = T), !T) return true;
      var j = r.current || T;
      return x4(j, x, g, j === "h" ? v : b);
    }, []), l = h.useCallback(function(g) {
      var x = g;
      if (!(!rs.length || rs[rs.length - 1] !== i)) {
        var m = "deltaY" in x ? yv(x) : Ta(x), y = t.current.filter(function(T) {
          return T.name === x.type && (T.target === x.target || x.target === T.shadowParent) && S4(T.delta, m);
        })[0];
        if (y && y.should) {
          x.cancelable && x.preventDefault();
          return;
        }
        if (!y) {
          var v = (o.current.shards || []).map(vv).filter(Boolean).filter(function(T) {
            return T.contains(x.target);
          }), b = v.length > 0 ? a(x, v[0]) : !o.current.noIsolation;
          b && x.cancelable && x.preventDefault();
        }
      }
    }, []), u = h.useCallback(function(g, x, m, y) {
      var v = {
        name: g,
        delta: x,
        target: m,
        should: y,
        shadowParent: E4(m)
      };
      t.current.push(v), setTimeout(function() {
        t.current = t.current.filter(function(b) {
          return b !== v;
        });
      }, 1);
    }, []), c = h.useCallback(function(g) {
      n.current = Ta(g), r.current = void 0;
    }, []), d = h.useCallback(function(g) {
      u(g.type, yv(g), g.target, a(g, e.lockRef.current));
    }, []), f = h.useCallback(function(g) {
      u(g.type, Ta(g), g.target, a(g, e.lockRef.current));
    }, []);
    h.useEffect(function() {
      return rs.push(i), e.setCallbacks({
        onScrollCapture: d,
        onWheelCapture: d,
        onTouchMoveCapture: f
      }), document.addEventListener("wheel", l, ns), document.addEventListener("touchmove", l, ns), document.addEventListener("touchstart", c, ns), function() {
        rs = rs.filter(function(g) {
          return g !== i;
        }), document.removeEventListener("wheel", l, ns), document.removeEventListener("touchmove", l, ns), document.removeEventListener("touchstart", c, ns);
      };
    }, []);
    var p = e.removeScrollBar, w = e.inert;
    return h.createElement(h.Fragment, null, w ? h.createElement(i, {
      styles: b4(s)
    }) : null, p ? h.createElement(h4, {
      noRelative: e.noRelative,
      gapMode: e.gapMode
    }) : null);
  }
  function E4(e) {
    for (var t = null; e !== null; ) e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
    return t;
  }
  const P4 = e4(sT, C4);
  uT = h.forwardRef(function(e, t) {
    return h.createElement(Au, an({}, e, {
      ref: t,
      sideCar: P4
    }));
  });
  uT.classNames = Au.classNames;
  let k4, ss, Ca, Ea, Vc, cT, _4, A4;
  k4 = function(e) {
    if (typeof document > "u") return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body;
  };
  ss = /* @__PURE__ */ new WeakMap();
  Ca = /* @__PURE__ */ new WeakMap();
  Ea = {};
  Vc = 0;
  cT = function(e) {
    return e && (e.host || cT(e.parentNode));
  };
  _4 = function(e, t) {
    return t.map(function(n) {
      if (e.contains(n)) return n;
      var r = cT(n);
      return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
    }).filter(function(n) {
      return !!n;
    });
  };
  A4 = function(e, t, n, r) {
    var s = _4(t, Array.isArray(e) ? e : [
      e
    ]);
    Ea[n] || (Ea[n] = /* @__PURE__ */ new WeakMap());
    var i = Ea[n], o = [], a = /* @__PURE__ */ new Set(), l = new Set(s), u = function(d) {
      !d || a.has(d) || (a.add(d), u(d.parentNode));
    };
    s.forEach(u);
    var c = function(d) {
      !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
        if (a.has(f)) c(f);
        else try {
          var p = f.getAttribute(r), w = p !== null && p !== "false", g = (ss.get(f) || 0) + 1, x = (i.get(f) || 0) + 1;
          ss.set(f, g), i.set(f, x), o.push(f), g === 1 && w && Ca.set(f, true), x === 1 && f.setAttribute(n, "true"), w || f.setAttribute(r, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", f, m);
        }
      });
    };
    return c(t), a.clear(), Vc++, function() {
      o.forEach(function(d) {
        var f = ss.get(d) - 1, p = i.get(d) - 1;
        ss.set(d, f), i.set(d, p), f || (Ca.has(d) || d.removeAttribute(r), Ca.delete(d)), p || d.removeAttribute(n);
      }), Vc--, Vc || (ss = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), Ea = {});
    };
  };
  R4 = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [
      e
    ]), s = k4(e);
    return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live], script"))), A4(r, s, n, "aria-hidden")) : function() {
      return null;
    };
  };
  function N4(e) {
    const t = D4(e), n = h.forwardRef((r, s) => {
      const { children: i, ...o } = r, a = h.Children.toArray(i), l = a.find(O4);
      if (l) {
        const u = l.props.children, c = a.map((d) => d === l ? h.Children.count(u) > 1 ? h.Children.only(null) : h.isValidElement(u) ? u.props.children : null : d);
        return S.jsx(t, {
          ...o,
          ref: s,
          children: h.isValidElement(u) ? h.cloneElement(u, void 0, c) : null
        });
      }
      return S.jsx(t, {
        ...o,
        ref: s,
        children: i
      });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  function D4(e) {
    const t = h.forwardRef((n, r) => {
      const { children: s, ...i } = n;
      if (h.isValidElement(s)) {
        const o = L4(s), a = I4(i, s.props);
        return s.type !== h.Fragment && (a.ref = r ? zo(r, o) : o), h.cloneElement(s, a);
      }
      return h.Children.count(s) > 1 ? h.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var M4 = Symbol("radix.slottable");
  function O4(e) {
    return h.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === M4;
  }
  function I4(e, t) {
    const n = {
      ...t
    };
    for (const r in t) {
      const s = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
        const l = i(...a);
        return s(...a), l;
      } : s && (n[r] = s) : r === "style" ? n[r] = {
        ...s,
        ...i
      } : r === "className" && (n[r] = [
        s,
        i
      ].filter(Boolean).join(" "));
    }
    return {
      ...e,
      ...n
    };
  }
  function L4(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var Ru = "Dialog", [dT] = ii(Ru), [j4, tn] = dT(Ru), fT = (e) => {
    const { __scopeDialog: t, children: n, open: r, defaultOpen: s, onOpenChange: i, modal: o = true } = e, a = h.useRef(null), l = h.useRef(null), [u, c] = Rh({
      prop: r,
      defaultProp: s ?? false,
      onChange: i,
      caller: Ru
    });
    return S.jsx(j4, {
      scope: t,
      triggerRef: a,
      contentRef: l,
      contentId: cc(),
      titleId: cc(),
      descriptionId: cc(),
      open: u,
      onOpenChange: c,
      onOpenToggle: h.useCallback(() => c((d) => !d), [
        c
      ]),
      modal: o,
      children: n
    });
  };
  fT.displayName = Ru;
  var hT = "DialogTrigger", pT = h.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e, s = tn(hT, n), i = Me(t, s.triggerRef);
    return S.jsx(ye.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": s.open,
      "aria-controls": s.contentId,
      "data-state": Np(s.open),
      ...r,
      ref: i,
      onClick: ae(e.onClick, s.onOpenToggle)
    });
  });
  pT.displayName = hT;
  var Ap = "DialogPortal", [V4, mT] = dT(Ap, {
    forceMount: void 0
  }), gT = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: s } = e, i = tn(Ap, t);
    return S.jsx(V4, {
      scope: t,
      forceMount: n,
      children: h.Children.map(r, (o) => S.jsx(oi, {
        present: n || i.open,
        children: S.jsx(Ah, {
          asChild: true,
          container: s,
          children: o
        })
      }))
    });
  };
  gT.displayName = Ap;
  var $l = "DialogOverlay", yT = h.forwardRef((e, t) => {
    const n = mT($l, e.__scopeDialog), { forceMount: r = n.forceMount, ...s } = e, i = tn($l, e.__scopeDialog);
    return i.modal ? S.jsx(oi, {
      present: r || i.open,
      children: S.jsx(z4, {
        ...s,
        ref: t
      })
    }) : null;
  });
  yT.displayName = $l;
  var F4 = N4("DialogOverlay.RemoveScroll"), z4 = h.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e, s = tn($l, n);
    return S.jsx(uT, {
      as: F4,
      allowPinchZoom: true,
      shards: [
        s.contentRef
      ],
      children: S.jsx(ye.div, {
        "data-state": Np(s.open),
        ...r,
        ref: t,
        style: {
          pointerEvents: "auto",
          ...r.style
        }
      })
    });
  }), Yr = "DialogContent", vT = h.forwardRef((e, t) => {
    const n = mT(Yr, e.__scopeDialog), { forceMount: r = n.forceMount, ...s } = e, i = tn(Yr, e.__scopeDialog);
    return S.jsx(oi, {
      present: r || i.open,
      children: i.modal ? S.jsx(B4, {
        ...s,
        ref: t
      }) : S.jsx(U4, {
        ...s,
        ref: t
      })
    });
  });
  vT.displayName = Yr;
  var B4 = h.forwardRef((e, t) => {
    const n = tn(Yr, e.__scopeDialog), r = h.useRef(null), s = Me(t, n.contentRef, r);
    return h.useEffect(() => {
      const i = r.current;
      if (i) return R4(i);
    }, []), S.jsx(wT, {
      ...e,
      ref: s,
      trapFocus: n.open,
      disableOutsidePointerEvents: true,
      onCloseAutoFocus: ae(e.onCloseAutoFocus, (i) => {
        i.preventDefault(), n.triggerRef.current?.focus();
      }),
      onPointerDownOutside: ae(e.onPointerDownOutside, (i) => {
        const o = i.detail.originalEvent, a = o.button === 0 && o.ctrlKey === true;
        (o.button === 2 || a) && i.preventDefault();
      }),
      onFocusOutside: ae(e.onFocusOutside, (i) => i.preventDefault())
    });
  }), U4 = h.forwardRef((e, t) => {
    const n = tn(Yr, e.__scopeDialog), r = h.useRef(false), s = h.useRef(false);
    return S.jsx(wT, {
      ...e,
      ref: t,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      onCloseAutoFocus: (i) => {
        e.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = false, s.current = false;
      },
      onInteractOutside: (i) => {
        e.onInteractOutside?.(i), i.defaultPrevented || (r.current = true, i.detail.originalEvent.type === "pointerdown" && (s.current = true));
        const o = i.target;
        n.triggerRef.current?.contains(o) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault();
      }
    });
  }), wT = h.forwardRef((e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: i, ...o } = e, a = tn(Yr, n), l = h.useRef(null), u = Me(t, l);
    return WF(), S.jsxs(S.Fragment, {
      children: [
        S.jsx(eT, {
          asChild: true,
          loop: true,
          trapped: r,
          onMountAutoFocus: s,
          onUnmountAutoFocus: i,
          children: S.jsx(lu, {
            role: "dialog",
            id: a.contentId,
            "aria-describedby": a.descriptionId,
            "aria-labelledby": a.titleId,
            "data-state": Np(a.open),
            ...o,
            ref: u,
            onDismiss: () => a.onOpenChange(false)
          })
        }),
        S.jsxs(S.Fragment, {
          children: [
            S.jsx($4, {
              titleId: a.titleId
            }),
            S.jsx(H4, {
              contentRef: l,
              descriptionId: a.descriptionId
            })
          ]
        })
      ]
    });
  }), Rp = "DialogTitle", xT = h.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e, s = tn(Rp, n);
    return S.jsx(ye.h2, {
      id: s.titleId,
      ...r,
      ref: t
    });
  });
  xT.displayName = Rp;
  var ST = "DialogDescription", bT = h.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e, s = tn(ST, n);
    return S.jsx(ye.p, {
      id: s.descriptionId,
      ...r,
      ref: t
    });
  });
  bT.displayName = ST;
  var TT = "DialogClose", CT = h.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e, s = tn(TT, n);
    return S.jsx(ye.button, {
      type: "button",
      ...r,
      ref: t,
      onClick: ae(e.onClick, () => s.onOpenChange(false))
    });
  });
  CT.displayName = TT;
  function Np(e) {
    return e ? "open" : "closed";
  }
  var ET = "DialogTitleWarning", [H3, PT] = Ik(ET, {
    contentName: Yr,
    titleName: Rp,
    docsSlug: "dialog"
  }), $4 = ({ titleId: e }) => {
    const t = PT(ET), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return h.useEffect(() => {
      e && (document.getElementById(e) || console.error(n));
    }, [
      n,
      e
    ]), null;
  }, W4 = "DialogDescriptionWarning", H4 = ({ contentRef: e, descriptionId: t }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${PT(W4).contentName}}.`;
    return h.useEffect(() => {
      const s = e.current?.getAttribute("aria-describedby");
      t && s && (document.getElementById(t) || console.warn(r));
    }, [
      r,
      e,
      t
    ]), null;
  }, K4 = fT, Q4 = pT, G4 = gT, kT = yT, _T = vT, AT = xT, RT = bT, q4 = CT;
  let Y4, X4, NT;
  Z4 = K4;
  Y4 = Q4;
  X4 = G4;
  NT = h.forwardRef(({ className: e, ...t }, n) => S.jsx(kT, {
    ref: n,
    className: ct("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", e),
    ...t
  }));
  NT.displayName = kT.displayName;
  DT = h.forwardRef(({ className: e, children: t, ...n }, r) => S.jsxs(X4, {
    children: [
      S.jsx(NT, {}),
      S.jsxs(_T, {
        ref: r,
        className: ct("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", e),
        ...n,
        children: [
          t,
          S.jsxs(q4, {
            className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
            children: [
              S.jsx(Rx, {
                className: "h-4 w-4"
              }),
              S.jsx("span", {
                className: "sr-only",
                children: "Close"
              })
            ]
          })
        ]
      })
    ]
  }));
  DT.displayName = _T.displayName;
  MT = ({ className: e, ...t }) => S.jsx("div", {
    className: ct("flex flex-col space-y-1.5 text-center sm:text-left", e),
    ...t
  });
  MT.displayName = "DialogHeader";
  OT = h.forwardRef(({ className: e, ...t }, n) => S.jsx(AT, {
    ref: n,
    className: ct("text-lg font-semibold leading-none tracking-tight", e),
    ...t
  }));
  OT.displayName = AT.displayName;
  IT = h.forwardRef(({ className: e, ...t }, n) => S.jsx(RT, {
    ref: n,
    className: ct("text-sm text-muted-foreground", e),
    ...t
  }));
  IT.displayName = RT.displayName;
  const Pa = (e) => {
    if (e < 24) return `${e}h`;
    const t = Math.floor(e / 24), n = e % 24;
    return n === 0 ? `${t}d` : `${t}d ${n}h`;
  }, J4 = ({ status: e }) => {
    const t = {
      idle: "bg-zinc-600",
      syncing: "bg-amber-400",
      live: "bg-emerald-500"
    }, n = {
      idle: "Draft",
      syncing: "Syncing\u2026",
      live: "Live"
    };
    return S.jsxs("div", {
      className: "flex items-center gap-2",
      children: [
        S.jsxs("div", {
          className: "relative flex h-2 w-2",
          children: [
            e !== "idle" && S.jsx("span", {
              className: `animate-ping absolute inline-flex h-full w-full rounded-full opacity-60 ${t[e]}`
            }),
            S.jsx("span", {
              className: `relative inline-flex rounded-full h-2 w-2 ${t[e]}`
            })
          ]
        }),
        S.jsx("span", {
          className: `text-[11px] font-mono uppercase tracking-wider ${e === "live" ? "text-emerald-400" : e === "syncing" ? "text-amber-400" : "text-zinc-500"}`,
          children: n[e]
        })
      ]
    });
  };
  function Tf() {
    const { toast: e } = _h(), { play: t } = UI(), { addRecord: n } = LF(), [r, s] = h.useState("draft"), [i, o] = h.useState(""), [a, l] = h.useState(true), [u, c] = h.useState(false), [d, f] = h.useState(false), [p, w] = h.useState([
      1
    ]), [g, x] = h.useState(false), [m, y] = h.useState(null), [v, b] = h.useState(null), [T, C] = h.useState(false), E = h.useRef(null), P = h.useRef(false), D = h.useRef(null), A = h.useRef(i);
    A.current = i;
    const M = gF(), j = yF(), { data: Q } = vF(m?.lookupId ?? "", r === "live" && !!m?.lookupId);
    h.useEffect(() => {
      if (r !== "live" || !Q?.encryptedClipboardText || !m || P.current) return;
      (async () => {
        try {
          const $ = await kF(Q.encryptedClipboardText, m.key);
          $ !== A.current && (o($), b(/* @__PURE__ */ new Date()), t("pop"));
        } catch ($) {
          console.error("Decryption sync failed", $);
        }
      })();
    }, [
      Q,
      r,
      m
    ]);
    const L = h.useCallback((I) => {
      o(I), P.current = true, D.current && clearTimeout(D.current), D.current = setTimeout(() => {
        P.current = false;
      }, 600), r === "live" && m && (C(true), E.current && clearTimeout(E.current), E.current = setTimeout(async () => {
        try {
          const $ = await lv(I, m.key);
          await j.mutateAsync({
            lookupId: m.lookupId,
            encryptedClipboardText: $,
            wrappedKey: m.wrappedKey
          }), b(/* @__PURE__ */ new Date());
        } catch ($) {
          console.error("Upload failed", $);
        } finally {
          C(false);
        }
      }, 600));
    }, [
      r,
      m,
      j
    ]), Z = async () => {
      if (!i.trim()) {
        e({
          variant: "destructive",
          title: "Empty content",
          description: "Add some text first."
        });
        return;
      }
      c(true), t("click");
      try {
        const I = await wF(), $ = NF(), le = await DF(I, $.pin), rt = await lv(i, I), qe = await Xb([], I);
        await M.mutateAsync({
          expiresIn: p[0],
          maxDownloads: 100,
          encryptedMetadata: qe,
          lookupId: $.lookupId,
          wrappedKey: le,
          files: [],
          encryptedClipboardText: rt
        }), y({
          ...$,
          key: I,
          wrappedKey: le
        }), s("live"), b(/* @__PURE__ */ new Date()), t("success"), n({
          type: "clipboard",
          action: "sent",
          accessCode: $.fullCode,
          fileNames: [],
          fileCount: 0,
          totalSize: new TextEncoder().encode(i).byteLength,
          hasClipboard: true,
          clipboardPreview: i.trim().slice(0, 80),
          createdAt: Date.now(),
          expiresAt: Date.now() + p[0] * 36e5,
          maxDownloads: 100,
          downloadCount: 0
        }), e({
          title: "Live link active",
          description: `Share PIN ${$.fullCode.slice(0, 3)}-${$.fullCode.slice(3)}`,
          className: "bg-emerald-950 border-emerald-500/50 text-emerald-200"
        });
      } catch (I) {
        console.error(I), e({
          variant: "destructive",
          title: "Failed",
          description: "Could not establish secure link."
        });
      } finally {
        c(false);
      }
    }, W = async (I) => {
      await navigator.clipboard.writeText(I), f(true), setTimeout(() => f(false), 2e3), e({
        title: "Copied!"
      });
    }, B = () => {
      s("draft"), y(null), o(""), t("off"), e({
        title: "Session ended",
        description: "Keys purged locally."
      });
    }, k = r === "draft" ? "idle" : T || u ? "syncing" : "live", O = m ? `${m.fullCode.slice(0, 3)}-${m.fullCode.slice(3)}` : null;
    return S.jsxs("div", {
      className: "min-h-screen bg-[#1C1C1E] text-zinc-100 flex flex-col font-sans selection:bg-emerald-500/30",
      children: [
        S.jsx("div", {
          className: "fixed inset-0 pointer-events-none overflow-hidden",
          children: S.jsx("div", {
            className: "absolute top-[-20%] left-1/2 -translate-x-1/2 w-[600px] h-[400px] bg-emerald-500/4 rounded-full blur-[130px]"
          })
        }),
        S.jsx("header", {
          className: `sticky top-0 z-30 transition-all duration-500 border-b ${r === "live" ? "bg-[#1C1C1E]/90 border-emerald-500/25 backdrop-blur-xl" : "bg-[#1C1C1E]/80 border-white/5 backdrop-blur-xl"}`,
          children: S.jsxs("div", {
            className: "max-w-3xl mx-auto px-4 h-14 flex items-center justify-between gap-3",
            children: [
              S.jsx($P, {
                href: "/",
                children: S.jsxs("button", {
                  className: "flex items-center gap-2 text-zinc-400 hover:text-white transition-colors",
                  children: [
                    S.jsx(I_, {
                      className: "w-4 h-4 flex-shrink-0"
                    }),
                    S.jsxs("div", {
                      className: "hidden sm:flex items-center gap-1.5",
                      children: [
                        S.jsx("div", {
                          className: "w-6 h-6 rounded-lg bg-emerald-500/15 border border-emerald-500/30 flex items-center justify-center",
                          children: S.jsx(yg, {
                            className: "w-3.5 h-3.5 text-emerald-400"
                          })
                        }),
                        S.jsxs("span", {
                          className: "text-sm font-bold tracking-tight font-mono",
                          children: [
                            "VAULT",
                            S.jsx("span", {
                              className: "text-emerald-400",
                              children: "BRIDGE"
                            })
                          ]
                        })
                      ]
                    }),
                    S.jsx("span", {
                      className: "sm:hidden text-sm font-semibold",
                      children: "Back"
                    })
                  ]
                })
              }),
              S.jsx("div", {
                className: "flex-1 flex justify-center",
                children: S.jsx(J4, {
                  status: k
                })
              }),
              S.jsx(Ai, {
                mode: "wait",
                children: r === "live" && m ? S.jsxs(ft.div, {
                  initial: {
                    opacity: 0,
                    x: 10
                  },
                  animate: {
                    opacity: 1,
                    x: 0
                  },
                  exit: {
                    opacity: 0,
                    x: 10
                  },
                  className: "flex items-center gap-2",
                  children: [
                    S.jsxs("button", {
                      onClick: () => W(m.fullCode),
                      className: "flex items-center gap-2 px-3 py-1.5 rounded-xl bg-zinc-800/60 border border-zinc-700/50 hover:border-emerald-500/40 transition-all group",
                      children: [
                        S.jsx("span", {
                          className: "font-mono font-bold text-sm text-white tracking-widest",
                          children: O
                        }),
                        d ? S.jsx(pg, {
                          className: "w-3.5 h-3.5 text-emerald-400"
                        }) : S.jsx(ac, {
                          className: "w-3.5 h-3.5 text-zinc-500 group-hover:text-emerald-400 transition-colors"
                        })
                      ]
                    }),
                    S.jsxs(Z4, {
                      children: [
                        S.jsx(Y4, {
                          asChild: true,
                          children: S.jsx(Cn, {
                            size: "icon",
                            variant: "ghost",
                            className: "w-8 h-8 text-zinc-400 hover:text-white hover:bg-zinc-800",
                            children: S.jsx(B_, {
                              className: "w-4 h-4"
                            })
                          })
                        }),
                        S.jsxs(DT, {
                          className: "sm:max-w-xs bg-[#1C1C1E] border-zinc-800 text-zinc-100 rounded-2xl p-6",
                          children: [
                            S.jsxs(MT, {
                              children: [
                                S.jsx(OT, {
                                  className: "text-center",
                                  children: "Scan to Connect"
                                }),
                                S.jsx(IT, {
                                  className: "text-center text-zinc-500 text-sm",
                                  children: "Scan with your phone camera to open this clipboard instantly."
                                })
                              ]
                            }),
                            S.jsx("div", {
                              className: "flex justify-center p-4 bg-white rounded-xl mt-2",
                              children: S.jsx(ub, {
                                value: `${window.location.origin}/access#code=${m.fullCode}`,
                                size: 160
                              })
                            }),
                            S.jsx("p", {
                              className: "text-center text-sm font-mono font-bold text-emerald-400 tracking-widest mt-3",
                              children: O
                            })
                          ]
                        })
                      ]
                    }),
                    S.jsx(Cn, {
                      size: "sm",
                      variant: "ghost",
                      onClick: B,
                      className: "h-8 px-2.5 text-red-400/70 hover:text-red-300 hover:bg-red-950/30",
                      title: "End session",
                      children: S.jsx(z_, {
                        className: "w-3.5 h-3.5"
                      })
                    })
                  ]
                }, "live-controls") : S.jsx(ft.div, {
                  initial: {
                    opacity: 0
                  },
                  animate: {
                    opacity: 1
                  },
                  exit: {
                    opacity: 0
                  },
                  children: S.jsxs(Cn, {
                    size: "sm",
                    variant: "ghost",
                    onClick: () => x((I) => !I),
                    className: `h-8 px-3 text-xs font-medium transition-colors ${g ? "text-emerald-400 bg-emerald-500/10" : "text-zinc-400 hover:text-white hover:bg-zinc-800"}`,
                    children: [
                      S.jsx(mg, {
                        className: "w-3.5 h-3.5 mr-1.5"
                      }),
                      Pa(p[0])
                    ]
                  })
                }, "settings-toggle")
              })
            ]
          })
        }),
        S.jsxs("main", {
          className: "flex-1 flex flex-col max-w-3xl w-full mx-auto px-4 pb-4 pt-3 gap-3",
          children: [
            S.jsx(Ai, {
              children: r === "draft" && S.jsxs(ft.div, {
                initial: {
                  opacity: 0,
                  y: -8
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                exit: {
                  opacity: 0,
                  height: 0
                },
                className: "flex items-center justify-between",
                children: [
                  S.jsxs("div", {
                    children: [
                      S.jsx("h1", {
                        className: "text-xl font-bold text-zinc-100 tracking-tight",
                        children: "Encrypted Clipboard"
                      }),
                      S.jsx("p", {
                        className: "text-xs text-zinc-500 mt-0.5",
                        children: "Paste text \u2192 share PIN \u2192 syncs everywhere"
                      })
                    ]
                  }),
                  S.jsxs("div", {
                    className: "flex items-center gap-1 text-[10px] font-mono text-zinc-600",
                    children: [
                      S.jsx(lc, {
                        className: "w-3 h-3"
                      }),
                      " AES-256"
                    ]
                  })
                ]
              })
            }),
            S.jsx(Ai, {
              children: g && r === "draft" && S.jsx(ft.div, {
                initial: {
                  opacity: 0,
                  height: 0
                },
                animate: {
                  opacity: 1,
                  height: "auto"
                },
                exit: {
                  opacity: 0,
                  height: 0
                },
                className: "overflow-hidden",
                children: S.jsxs("div", {
                  className: "bg-zinc-900/60 border border-zinc-800/60 rounded-2xl p-4 space-y-4",
                  children: [
                    S.jsxs("div", {
                      className: "flex items-center justify-between",
                      children: [
                        S.jsxs("span", {
                          className: "text-sm font-semibold text-zinc-300 flex items-center gap-2",
                          children: [
                            S.jsx(mg, {
                              className: "w-4 h-4 text-emerald-400"
                            }),
                            " Auto-destruct"
                          ]
                        }),
                        S.jsx("span", {
                          className: "text-sm font-mono text-emerald-400 font-bold bg-emerald-500/10 px-2.5 py-0.5 rounded-lg",
                          children: Pa(p[0])
                        })
                      ]
                    }),
                    S.jsx(kb, {
                      value: p,
                      onValueChange: w,
                      max: 24,
                      step: 1,
                      min: 1,
                      className: "py-1"
                    }),
                    S.jsx("div", {
                      className: "flex flex-wrap gap-2",
                      children: [
                        {
                          icon: U_,
                          label: "AES-256"
                        },
                        {
                          icon: V_,
                          label: "Zero-Knowledge"
                        },
                        {
                          icon: gg,
                          label: "E2E Encrypted"
                        }
                      ].map(({ icon: I, label: $ }) => S.jsxs("div", {
                        className: "flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-[10px] font-mono tracking-wider uppercase border bg-emerald-500/10 text-emerald-400 border-emerald-500/20",
                        children: [
                          S.jsx(I, {
                            className: "w-3 h-3"
                          }),
                          " ",
                          $
                        ]
                      }, $))
                    })
                  ]
                })
              })
            }),
            S.jsxs(ft.div, {
              layout: true,
              className: `flex-1 flex flex-col rounded-2xl border overflow-hidden transition-all duration-500 ${r === "live" ? "border-emerald-500/30 bg-zinc-900/50 shadow-[0_0_40px_rgba(16,185,129,0.04)]" : "border-zinc-800/60 bg-zinc-900/50"}`,
              style: {
                minHeight: "calc(100vh - 260px)"
              },
              children: [
                S.jsxs("div", {
                  className: "flex items-center justify-between px-3 py-2.5 border-b border-white/[0.04] bg-black/10",
                  children: [
                    S.jsx("div", {
                      children: r === "live" && v && S.jsx("span", {
                        className: "text-[10px] font-mono text-zinc-600",
                        children: v.toLocaleTimeString()
                      })
                    }),
                    S.jsxs("div", {
                      className: "flex items-center gap-0.5",
                      children: [
                        i.length > 0 && S.jsxs("span", {
                          className: "text-[10px] font-mono text-zinc-600 mr-1.5",
                          children: [
                            i.length.toLocaleString(),
                            " ch"
                          ]
                        }),
                        S.jsx(Cn, {
                          size: "sm",
                          variant: "ghost",
                          className: "h-7 w-7 p-0 hover:bg-zinc-800 text-zinc-500 hover:text-zinc-300",
                          onClick: () => l((I) => !I),
                          children: a ? S.jsx(gg, {
                            className: "w-3.5 h-3.5"
                          }) : S.jsx(j_, {
                            className: "w-3.5 h-3.5"
                          })
                        }),
                        S.jsx(Cn, {
                          size: "sm",
                          variant: "ghost",
                          className: "h-7 w-7 p-0 hover:bg-zinc-800 text-zinc-500 hover:text-zinc-300",
                          onClick: () => W(i),
                          disabled: !i,
                          children: S.jsx(ac, {
                            className: "w-3.5 h-3.5"
                          })
                        }),
                        i && r === "draft" && S.jsx(Cn, {
                          size: "sm",
                          variant: "ghost",
                          className: "h-7 w-7 p-0 hover:bg-red-500/10 text-zinc-600 hover:text-red-400",
                          onClick: () => o(""),
                          children: S.jsx($_, {
                            className: "w-3.5 h-3.5"
                          })
                        })
                      ]
                    })
                  ]
                }),
                S.jsxs("div", {
                  className: "relative flex-1",
                  children: [
                    S.jsx(cb, {
                      className: `absolute inset-0 w-full h-full bg-transparent border-0 resize-none px-5 py-4 text-[15px] leading-relaxed focus-visible:ring-0 placeholder:text-zinc-700 custom-scrollbar ${a ? "text-zinc-200" : "text-security-disc"}`,
                      style: a ? void 0 : {
                        WebkitTextSecurity: "disc"
                      },
                      placeholder: r === "draft" ? "Paste or type anything here\u2026" : "Typing syncs to all connected devices in real-time\u2026",
                      value: i,
                      onChange: (I) => L(I.target.value),
                      spellCheck: false,
                      autoFocus: true
                    }),
                    !i && r === "draft" && S.jsxs("div", {
                      className: "absolute inset-0 flex flex-col items-center justify-center pointer-events-none opacity-20",
                      children: [
                        S.jsx("div", {
                          className: "w-16 h-16 rounded-2xl bg-emerald-500/10 border border-emerald-500/20 flex items-center justify-center mb-3",
                          children: S.jsx(yg, {
                            className: "w-8 h-8 text-emerald-500/60"
                          })
                        }),
                        S.jsx("p", {
                          className: "text-xs font-mono text-zinc-500 uppercase tracking-widest",
                          children: "Ready for input"
                        })
                      ]
                    })
                  ]
                })
              ]
            }),
            S.jsx(Ai, {
              mode: "wait",
              children: r === "draft" ? S.jsxs(ft.div, {
                initial: {
                  opacity: 0,
                  y: 8
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                exit: {
                  opacity: 0,
                  y: 8
                },
                children: [
                  S.jsx(Cn, {
                    onClick: Z,
                    disabled: !i.trim() || u,
                    className: "w-full text-base font-bold rounded-2xl bg-emerald-500 hover:bg-emerald-400 text-black transition-all active:scale-[0.98] disabled:opacity-30 disabled:cursor-not-allowed shadow-lg shadow-emerald-900/20",
                    style: {
                      height: "52px"
                    },
                    children: u ? S.jsxs(S.Fragment, {
                      children: [
                        S.jsx(Ax, {
                          className: "w-4 h-4 animate-spin mr-2"
                        }),
                        "Creating secure link\u2026"
                      ]
                    }) : S.jsxs(S.Fragment, {
                      children: [
                        S.jsx(W_, {
                          className: "w-4 h-4 mr-2"
                        }),
                        "Go Live & Share"
                      ]
                    })
                  }),
                  S.jsxs("p", {
                    className: "text-center text-[11px] text-zinc-600 mt-2 font-mono",
                    children: [
                      S.jsx(lc, {
                        className: "w-2.5 h-2.5 inline mr-1"
                      }),
                      "End-to-end encrypted \xB7 ",
                      Pa(p[0]),
                      " expiry \xB7 No logs"
                    ]
                  })
                ]
              }, "go-live") : S.jsxs(ft.div, {
                initial: {
                  opacity: 0,
                  y: 8
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                exit: {
                  opacity: 0,
                  y: 8
                },
                className: "space-y-3",
                children: [
                  S.jsx("div", {
                    className: "bg-zinc-900/60 border border-emerald-500/20 rounded-2xl p-4",
                    children: S.jsxs("div", {
                      className: "flex items-center justify-between gap-3",
                      children: [
                        S.jsxs("div", {
                          className: "flex-1 min-w-0",
                          children: [
                            S.jsx("p", {
                              className: "text-xs text-zinc-500 font-mono uppercase tracking-wider mb-1",
                              children: "Share this PIN to connect"
                            }),
                            S.jsxs("div", {
                              className: "flex items-center gap-3",
                              children: [
                                S.jsx("span", {
                                  className: "text-3xl font-mono font-black text-white tracking-widest drop-shadow-[0_0_10px_rgba(16,185,129,0.4)]",
                                  children: O
                                }),
                                S.jsx("button", {
                                  onClick: () => W(m.fullCode),
                                  className: "p-2 rounded-lg bg-zinc-800 hover:bg-zinc-700 transition-colors",
                                  children: d ? S.jsx(pg, {
                                    className: "w-4 h-4 text-emerald-400"
                                  }) : S.jsx(ac, {
                                    className: "w-4 h-4 text-zinc-400"
                                  })
                                })
                              ]
                            })
                          ]
                        }),
                        S.jsxs("div", {
                          className: "flex flex-col items-end gap-2",
                          children: [
                            S.jsxs("div", {
                              className: "flex items-center gap-1.5 text-[10px] text-emerald-400 font-mono bg-emerald-500/10 border border-emerald-500/20 px-2 py-1 rounded-lg",
                              children: [
                                S.jsx("span", {
                                  className: "w-1.5 h-1.5 rounded-full bg-emerald-400 animate-pulse"
                                }),
                                " Live"
                              ]
                            }),
                            v && S.jsx("p", {
                              className: "text-[10px] text-zinc-600 font-mono",
                              children: v.toLocaleTimeString()
                            })
                          ]
                        })
                      ]
                    })
                  }),
                  S.jsxs("p", {
                    className: "text-center text-[11px] text-zinc-600 font-mono",
                    children: [
                      S.jsx(lc, {
                        className: "w-2.5 h-2.5 inline mr-1"
                      }),
                      "Syncing every 3s \xB7 Expires in ",
                      Pa(p[0]),
                      " \xB7 Zero-knowledge"
                    ]
                  })
                ]
              }, "live-status")
            })
          ]
        })
      ]
    });
  }
  const e3 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Tf
  }, Symbol.toStringTag, {
    value: "Module"
  })), t3 = h.lazy(() => Ve(() => import("./home-DBivV2ad.js"), __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]))), n3 = h.lazy(() => Ve(() => import("./upload-Di8Jr_bk.js"), __vite__mapDeps([16,17,5,18,19,11,9,20,6,21,7,22]))), r3 = h.lazy(() => Ve(() => import("./access-DLWkLg5b.js").then(async (m) => {
    await m.__tla;
    return m;
  }).then((e) => e.a), __vite__mapDeps([23,1,21,6,24,17,2,3,4,5,7,8,9,10,11,12,25,26,27,14,28]))), wv = h.lazy(() => Ve(() => import("./download-CRssWmit.js"), __vite__mapDeps([29,1,5,6,28,10,12,26,18]))), s3 = h.lazy(() => Ve(() => import("./success-BlqpmSDc.js"), __vite__mapDeps([30,1,19,6,10,5,8,25,12]))), i3 = h.lazy(() => Ve(() => import("./not-found-6UtAG3mA.js"), [])), o3 = h.lazy(() => Ve(() => import("./how-it-works-B7OIuHOp.js"), __vite__mapDeps([31,13,19,3,5,12,9,22,4]))), a3 = h.lazy(() => Ve(() => import("./terms-BiGkH4JX.js"), __vite__mapDeps([32,11,4]))), l3 = h.lazy(() => Ve(() => import("./privacy-BBlWl2bT.js"), __vite__mapDeps([33,4,28]))), u3 = h.lazy(() => Ve(() => import("./get-it-mailed-C8WnGYHM.js"), __vite__mapDeps([34,1,12,27,20,15,6,21,22,11,18]))), c3 = h.lazy(() => Ve(() => import("./security-D5r_9RUv.js"), __vite__mapDeps([35,14]))), d3 = h.lazy(() => Ve(() => import("./privacy-manifesto-DgEr79lm.js"), [])), f3 = h.lazy(() => Ve(() => import("./roadmap-CKyOPHLT.js"), __vite__mapDeps([36,24]))), h3 = h.lazy(() => Ve(() => import("./seo-landing-RoUYaZYW.js"), __vite__mapDeps([37,22]))), p3 = h.lazy(() => Ve(() => import("./blogs-DDyIGZsB.js"), __vite__mapDeps([38,22]))), m3 = h.lazy(() => Ve(() => import("./blog-post-CFVG9N5Y.js"), []));
  function g3() {
    return S.jsx("div", {
      className: "flex items-center justify-center min-h-screen bg-black/90 text-primary",
      children: S.jsx(F_, {
        className: "w-10 h-10 animate-spin"
      })
    });
  }
  function y3() {
    ON();
    const [e] = xh();
    return e === "/clipboard" || e === "/clipboard/" ? S.jsx(Tf, {}) : S.jsxs(WP, {
      children: [
        S.jsx(Fe, {
          path: "/clipboard",
          children: S.jsx(Tf, {})
        }),
        S.jsx(Fe, {
          path: "/",
          component: t3
        }),
        S.jsx(Fe, {
          path: "/upload",
          component: n3
        }),
        S.jsx(Fe, {
          path: "/access",
          component: r3
        }),
        S.jsx(Fe, {
          path: "/download/:id",
          component: wv
        }),
        S.jsx(Fe, {
          path: "/v/:id",
          component: wv
        }),
        S.jsx(Fe, {
          path: "/success/:id",
          component: s3
        }),
        S.jsx(Fe, {
          path: "/how-it-works",
          component: o3
        }),
        S.jsx(Fe, {
          path: "/get-it-mailed",
          component: u3
        }),
        S.jsx(Fe, {
          path: "/terms",
          component: a3
        }),
        S.jsx(Fe, {
          path: "/privacy",
          component: l3
        }),
        S.jsx(Fe, {
          path: "/security",
          component: c3
        }),
        S.jsx(Fe, {
          path: "/privacy-manifesto",
          component: d3
        }),
        S.jsx(Fe, {
          path: "/roadmap",
          component: f3
        }),
        S.jsx(Fe, {
          path: "/blog",
          component: p3
        }),
        S.jsx(Fe, {
          path: "/blog/:slug",
          component: m3
        }),
        Object.keys(SS()).map((t) => S.jsx(Fe, {
          path: t,
          component: h3
        }, t)),
        S.jsx(Fe, {
          component: i3
        })
      ]
    });
  }
  function v3({ onMount: e }) {
    return h.useEffect(() => {
      e();
    }, [
      e
    ]), null;
  }
  function w3() {
    return S.jsxs(ft.div, {
      initial: {
        opacity: 1
      },
      exit: {
        opacity: 0,
        scale: 1.05,
        filter: "blur(10px)"
      },
      transition: {
        duration: 0.8,
        ease: "easeInOut"
      },
      className: "fixed inset-0 z-[99999] bg-[#09090b] flex flex-col items-center justify-center pointer-events-none overflow-hidden",
      children: [
        S.jsx("div", {
          className: "absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(16,185,129,0.05)_0%,transparent_60%)] pointer-events-none"
        }),
        S.jsxs(ft.div, {
          initial: {
            scale: 0.9,
            opacity: 0,
            y: 10
          },
          animate: {
            scale: 1,
            opacity: 1,
            y: 0
          },
          transition: {
            duration: 0.6,
            ease: "easeOut"
          },
          className: "flex flex-col items-center relative z-10",
          children: [
            S.jsxs(ft.div, {
              animate: {
                scale: [
                  1,
                  1.05,
                  1
                ],
                boxShadow: [
                  "0 0 0 0 rgba(16, 185, 129, 0.2)",
                  "0 0 0 20px rgba(16, 185, 129, 0)",
                  "0 0 0 0 rgba(16, 185, 129, 0)"
                ]
              },
              transition: {
                duration: 2,
                repeat: 1 / 0,
                ease: "easeInOut"
              },
              className: "w-20 h-20 sm:w-24 sm:h-24 rounded-2xl bg-primary/10 border border-primary/30 flex items-center justify-center shadow-[0_0_40px_rgba(16,185,129,0.1)] relative overflow-hidden",
              children: [
                S.jsx(ft.div, {
                  animate: {
                    left: [
                      "-100%",
                      "200%"
                    ]
                  },
                  transition: {
                    duration: 2.5,
                    repeat: 1 / 0,
                    ease: "easeInOut",
                    delay: 0.5
                  },
                  className: "absolute top-0 w-1/2 h-full bg-gradient-to-r from-transparent via-white/20 to-transparent skew-x-[-20deg]"
                }),
                S.jsx("img", {
                  src: "/icon-192x192.png",
                  alt: "VaultBridge",
                  className: "w-12 h-12 sm:w-16 sm:h-16 object-contain relative z-10"
                })
              ]
            }),
            S.jsxs(ft.h1, {
              initial: {
                opacity: 0,
                y: 10
              },
              animate: {
                opacity: 1,
                y: 0
              },
              transition: {
                delay: 0.3,
                duration: 0.5
              },
              className: "mt-6 text-2xl sm:text-3xl font-bold tracking-tight text-white font-['Inter',system-ui,sans-serif]",
              children: [
                "VAULT",
                S.jsx("span", {
                  className: "text-primary",
                  children: "BRIDGE"
                })
              ]
            }),
            S.jsx(ft.p, {
              initial: {
                opacity: 0
              },
              animate: {
                opacity: 1
              },
              transition: {
                delay: 0.6,
                duration: 0.5
              },
              className: "mt-2 text-zinc-500 text-sm tracking-widest uppercase font-medium",
              children: "Secure File Sharing"
            }),
            S.jsx("div", {
              className: "mt-8 w-40 h-1 bg-white/5 rounded-full overflow-hidden",
              children: S.jsx(ft.div, {
                initial: {
                  x: "-100%"
                },
                animate: {
                  x: "100%"
                },
                transition: {
                  duration: 1.2,
                  repeat: 1 / 0,
                  ease: "easeInOut"
                },
                className: "w-1/2 h-full bg-primary rounded-full"
              })
            })
          ]
        })
      ]
    });
  }
  function x3() {
    const [e, t] = h.useState(true), [n, r] = h.useState(false), [s, i] = h.useState(false);
    return aI(), h.useEffect(() => {
      const o = setTimeout(() => r(true), 500);
      return () => clearTimeout(o);
    }, []), h.useEffect(() => {
      n && s && t(false);
    }, [
      n,
      s
    ]), h.useEffect(() => {
      e || (window.requestIdleCallback || ((a) => setTimeout(a, 1e3)))(() => {
        setTimeout(() => {
          (async () => {
            try {
              await Promise.all([
                Ve(() => import("./upload-Di8Jr_bk.js"), __vite__mapDeps([16,17,5,18,19,11,9,20,6,21,7,22])),
                Ve(() => import("./access-DLWkLg5b.js").then(async (m) => {
                  await m.__tla;
                  return m;
                }).then((l) => l.a), __vite__mapDeps([23,1,21,6,24,17,2,3,4,5,7,8,9,10,11,12,25,26,27,14,28])),
                Ve(() => Promise.resolve().then(() => e3), void 0)
              ]), console.log("VaultBridge: Heavy routes pre-fetched in background.");
            } catch {
            }
          })();
        }, 5e3);
      });
    }, [
      e
    ]), S.jsx(mk, {
      client: Ak,
      children: S.jsxs(gN, {
        children: [
          S.jsx(PA, {}),
          S.jsxs(_N, {
            children: [
              S.jsx(Ai, {
                children: e && S.jsx(w3, {}, "splash")
              }),
              S.jsx("div", {
                className: "min-h-screen bg-black text-white",
                style: {
                  opacity: e ? 0 : 1,
                  pointerEvents: e ? "none" : "auto",
                  transition: "opacity 0.6s ease-out",
                  position: e ? "fixed" : "relative",
                  width: "100%",
                  height: e ? "100vh" : "auto",
                  overflow: e ? "hidden" : "visible"
                },
                children: S.jsxs(h.Suspense, {
                  fallback: S.jsx(g3, {}),
                  children: [
                    S.jsx(v3, {
                      onMount: () => i(true)
                    }),
                    S.jsx(y3, {})
                  ]
                })
              })
            ]
          })
        ]
      })
    });
  }
  class S3 {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set(), this.deferredInstallPrompt = null, this.updateVH = () => {
        const t = window.innerHeight * 0.01;
        document.documentElement.style.setProperty("--vh", `${t}px`);
      }, this.handleResize = () => {
        const t = window.innerWidth, n = {
          ...this.state,
          isMobile: t < 768,
          isTablet: t >= 768 && t < 1024,
          orientation: window.innerHeight > t ? "portrait" : "landscape"
        };
        this.updateState(n);
      }, this.state = this.getInitialState(), this.initListeners();
    }
    getInitialState() {
      if (typeof window > "u") return {
        isMobile: false,
        isTablet: false,
        isTouch: false,
        isPWA: false,
        isIOS: false,
        isAndroid: false,
        orientation: "portrait"
      };
      const t = navigator.userAgent, n = window.innerWidth;
      return {
        isMobile: n < 768,
        isTablet: n >= 768 && n < 1024,
        isTouch: "ontouchstart" in window || navigator.maxTouchPoints > 0,
        isPWA: window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone === true,
        isIOS: /iPad|iPhone|iPod/.test(t),
        isAndroid: /Android/.test(t),
        orientation: window.innerHeight > window.innerWidth ? "portrait" : "landscape"
      };
    }
    initListeners() {
      if (!(typeof window > "u")) {
        if (window.addEventListener("resize", this.handleResize), window.addEventListener("orientationchange", this.handleResize), "getBattery" in navigator && navigator.getBattery().then((t) => {
          this.updateBattery(t), t.addEventListener("levelchange", () => this.updateBattery(t)), t.addEventListener("chargingchange", () => this.updateBattery(t));
        }), "connection" in navigator) {
          const t = navigator.connection;
          this.updateNetwork(t), t.addEventListener("change", () => this.updateNetwork(t));
        }
        window.addEventListener("beforeinstallprompt", (t) => {
          t.preventDefault(), this.deferredInstallPrompt = t;
        }), this.updateVH(), window.addEventListener("resize", this.updateVH);
      }
    }
    updateBattery(t) {
      this.updateState({
        ...this.state,
        battery: {
          level: t.level,
          charging: t.charging
        }
      });
    }
    updateNetwork(t) {
      this.updateState({
        ...this.state,
        network: {
          type: t.type,
          effectiveType: t.effectiveType
        }
      });
    }
    updateState(t) {
      this.state = t, this.notifyListeners();
    }
    notifyListeners() {
      this.listeners.forEach((t) => t(this.state));
    }
    subscribe(t) {
      return this.listeners.add(t), t(this.state), () => this.listeners.delete(t);
    }
    getState() {
      return this.state;
    }
    vibrate(t = 10) {
      typeof navigator < "u" && navigator.vibrate && navigator.vibrate(t);
    }
    async share(t) {
      if (typeof navigator < "u" && navigator.share) try {
        return await navigator.share(t), true;
      } catch (n) {
        return n?.name === "AbortError" || console.error("Share failed:", n), false;
      }
      return false;
    }
    canShare() {
      return typeof navigator < "u" && !!navigator.share;
    }
    async promptInstall() {
      if (!this.deferredInstallPrompt) return false;
      try {
        this.deferredInstallPrompt.prompt();
        const { outcome: t } = await this.deferredInstallPrompt.userChoice;
        return this.deferredInstallPrompt = null, t === "accepted";
      } catch {
        return false;
      }
    }
    canInstall() {
      return !!this.deferredInstallPrompt;
    }
    async copyToClipboard(t) {
      try {
        if (navigator.clipboard?.writeText) return await navigator.clipboard.writeText(t), true;
        const n = document.createElement("textarea");
        n.value = t, n.style.position = "fixed", n.style.opacity = "0", document.body.appendChild(n), n.select();
        const r = document.execCommand("copy");
        return document.body.removeChild(n), r;
      } catch {
        return false;
      }
    }
    isSlowConnection() {
      return this.state.network?.effectiveType ? [
        "slow-2g",
        "2g"
      ].includes(this.state.network.effectiveType) : false;
    }
    isLowBattery() {
      return this.state.battery ? this.state.battery.level < 0.15 && !this.state.battery.charging : false;
    }
    preventOverscroll(t) {
      t.addEventListener("touchmove", (n) => {
        t.scrollHeight <= t.clientHeight && n.preventDefault();
      }, {
        passive: false
      });
    }
  }
  const b3 = new S3();
  typeof window < "u" && (window.__mobileSDK = b3);
  "serviceWorker" in navigator && navigator.serviceWorker.getRegistrations().then((e) => {
    for (const t of e) t.unregister().then(() => {
      console.log("SW unregistered successfully");
    });
  });
  Mw(document.getElementById("root")).render(S.jsx(x3, {}));
})();
export {
  WF as $,
  Ai as A,
  Cn as B,
  L_ as C,
  Z4 as D,
  gg as E,
  ii as F,
  V_ as G,
  tx as H,
  cc as I,
  ae as J,
  Me as K,
  $P as L,
  vI as M,
  Rh as N,
  mn as O,
  ye as P,
  zo as Q,
  Ax as R,
  U_ as S,
  P3 as T,
  GR as U,
  tS as V,
  oi as W,
  Rx as X,
  Ah as Y,
  R4 as Z,
  nx as _,
  __tla,
  xh as a,
  uT as a0,
  eT as a1,
  lu as a2,
  qR as a3,
  ZR as a4,
  ct as a5,
  Ve as a6,
  vF as a7,
  yF as a8,
  ac as a9,
  zn as aA,
  Ke as aB,
  vt as aC,
  D2 as aD,
  Hh as aE,
  CS as aF,
  N3 as aG,
  mo as aH,
  Kh as aI,
  Kg as aJ,
  A3 as aK,
  bS as aL,
  R3 as aM,
  T3 as aN,
  xv as aO,
  cb as aa,
  kF as ab,
  lv as ac,
  B3 as ad,
  V3 as ae,
  F3 as af,
  z3 as ag,
  LF as ah,
  W3 as ai,
  bF as aj,
  PF as ak,
  SF as al,
  $_ as am,
  xN as an,
  ub as ao,
  C3 as ap,
  I3 as aq,
  $3 as ar,
  U3 as as,
  ge as at,
  pr as au,
  j2 as av,
  Gs as aw,
  JS as ax,
  qD as ay,
  YD as az,
  pg as b,
  Ue as c,
  lc as d,
  F_ as e,
  _h as f,
  gF as g,
  L3 as h,
  j3 as i,
  S as j,
  I_ as k,
  mg as l,
  ft as m,
  kb as n,
  DT as o,
  MT as p,
  OT as q,
  h as r,
  IT as s,
  wF as t,
  UI as u,
  _F as v,
  Xb as w,
  NF as x,
  DF as y,
  xF as z
};
