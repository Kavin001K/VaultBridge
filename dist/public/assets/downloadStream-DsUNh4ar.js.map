{"version":3,"file":"downloadStream-DsUNh4ar.js","sources":["../../../client/src/lib/downloadStream.ts"],"sourcesContent":["/**\n * Streamed Download Utility for VaultBridge\n * ==========================================\n * \n * Coordinates between main thread and Service Worker for\n * memory-efficient large file downloads via streaming decryption.\n * \n * Features:\n * - Service Worker registration and health checks\n * - Download progress tracking\n * - Fallback to in-memory download if SW unavailable\n * - Proper key export for SW communication\n * \n * @version 2.0.0\n */\n\nimport { exportKey } from './crypto';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ChunkInfo {\n    /** Signed URL for downloading this chunk */\n    downloadUrl: string;\n    /** Chunk index (0-based) */\n    index: number;\n}\n\nexport interface FileMetadata {\n    /** File name for download */\n    name: string;\n    /** File size in bytes */\n    size: number;\n    /** MIME type */\n    type: string;\n    /** Client file ID */\n    fileId: string;\n    /** Whether file is compressed */\n    isCompressed?: boolean;\n}\n\nexport interface DownloadProgress {\n    /** File ID */\n    fileId: string;\n    /** Progress percentage (0-100) */\n    progress: number;\n    /** Number of chunks processed */\n    processedChunks: number;\n    /** Total number of chunks */\n    totalChunks: number;\n    /** File name */\n    fileName?: string;\n}\n\nexport interface StreamDownloadResult {\n    /** Whether download was initiated successfully */\n    success: boolean;\n    /** Method used (streamed or memory) */\n    method: 'streamed' | 'memory' | 'failed';\n    /** Error message if failed */\n    error?: string;\n}\n\n// ============================================================================\n// SERVICE WORKER MANAGEMENT\n// ============================================================================\n\n/**\n * Check if Service Worker is available and active\n */\nexport function isServiceWorkerAvailable(): boolean {\n    return 'serviceWorker' in navigator &&\n        navigator.serviceWorker.controller !== null;\n}\n\n/**\n * Register the VaultBridge Service Worker\n */\nexport async function registerServiceWorker(): Promise<ServiceWorkerRegistration | null> {\n    if (!('serviceWorker' in navigator)) {\n        console.warn('[StreamDownload] Service Workers not supported');\n        return null;\n    }\n\n    try {\n        const registration = await navigator.serviceWorker.register('/sw.js', {\n            scope: '/'\n        });\n\n        console.log('[StreamDownload] Service Worker registered:', registration.scope);\n\n        // Wait for the Service Worker to be ready\n        await navigator.serviceWorker.ready;\n\n        return registration;\n    } catch (error) {\n        console.error('[StreamDownload] Service Worker registration failed:', error);\n        return null;\n    }\n}\n\n/**\n * Check Service Worker health with ping/pong\n */\nexport async function checkServiceWorkerHealth(): Promise<boolean> {\n    if (!navigator.serviceWorker.controller) {\n        return false;\n    }\n\n    return new Promise((resolve) => {\n        const timeout = setTimeout(() => resolve(false), 2000);\n\n        const handler = (event: MessageEvent) => {\n            if (event.data?.type === 'PONG') {\n                clearTimeout(timeout);\n                navigator.serviceWorker.removeEventListener('message', handler);\n                resolve(true);\n            }\n        };\n\n        navigator.serviceWorker.addEventListener('message', handler);\n        navigator.serviceWorker.controller!.postMessage({ type: 'PING' });\n    });\n}\n\n// ============================================================================\n// STREAM DOWNLOAD\n// ============================================================================\n\n/**\n * Initiate a streamed download via Service Worker\n * \n * @param fileId - Unique file identifier\n * @param key - CryptoKey for decryption\n * @param chunks - Array of chunk information\n * @param metadata - File metadata\n * @param onProgress - Optional progress callback\n * @returns Promise<StreamDownloadResult>\n */\nexport async function initiateStreamDownload(\n    fileId: string,\n    key: CryptoKey,\n    chunks: ChunkInfo[],\n    metadata: FileMetadata,\n    onProgress?: (progress: DownloadProgress) => void\n): Promise<StreamDownloadResult> {\n    // Check SW availability\n    if (!isServiceWorkerAvailable()) {\n        console.warn('[StreamDownload] Service Worker not available, cannot stream');\n        return {\n            success: false,\n            method: 'failed',\n            error: 'Service Worker not available'\n        };\n    }\n\n    try {\n        // Export the key to base64 for SW (CryptoKey can be cloned but base64 is safer)\n        const keyBase64 = await exportKey(key);\n\n        // Set up progress listener before registering download\n        const progressHandler = (event: MessageEvent) => {\n            const data = event.data;\n\n            if (data?.fileId === fileId) {\n                switch (data.type) {\n                    case 'DOWNLOAD_PROGRESS':\n                        onProgress?.({\n                            fileId: data.fileId,\n                            progress: data.progress,\n                            processedChunks: data.processedChunks,\n                            totalChunks: data.totalChunks,\n                            fileName: data.fileName\n                        });\n                        break;\n\n                    case 'DOWNLOAD_COMPLETE':\n                        console.log(`[StreamDownload] Download complete: ${data.fileName}`);\n                        navigator.serviceWorker.removeEventListener('message', progressHandler);\n                        break;\n\n                    case 'DOWNLOAD_ERROR':\n                        console.error(`[StreamDownload] Download error: ${data.error}`);\n                        navigator.serviceWorker.removeEventListener('message', progressHandler);\n                        break;\n                }\n            }\n        };\n\n        navigator.serviceWorker.addEventListener('message', progressHandler);\n\n        // Register download with Service Worker\n        navigator.serviceWorker.controller!.postMessage({\n            type: 'REGISTER_DOWNLOAD',\n            fileId,\n            keyBase64,\n            chunks: chunks.map(c => ({\n                downloadUrl: c.downloadUrl,\n                index: c.index\n            })),\n            metadata: {\n                name: metadata.name,\n                size: metadata.size,\n                type: metadata.type,\n                fileId: metadata.fileId\n            },\n            isCompressed: metadata.isCompressed || false\n        });\n\n        // Wait for registration confirmation\n        await new Promise<void>((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('Download registration timeout'));\n            }, 5000);\n\n            const confirmHandler = (event: MessageEvent) => {\n                if (event.data?.type === 'DOWNLOAD_REGISTERED' && event.data.fileId === fileId) {\n                    clearTimeout(timeout);\n                    navigator.serviceWorker.removeEventListener('message', confirmHandler);\n                    resolve();\n                }\n            };\n\n            navigator.serviceWorker.addEventListener('message', confirmHandler);\n        });\n\n        // Small delay to ensure SW is ready\n        await new Promise(resolve => setTimeout(resolve, 100));\n\n        // Trigger download by navigating to the stream URL\n        // Use an invisible iframe to avoid leaving the page\n        const iframe = document.createElement('iframe');\n        iframe.style.cssText = 'position:absolute;width:0;height:0;border:none;visibility:hidden;';\n        iframe.src = `/stream-download/${fileId}`;\n        document.body.appendChild(iframe);\n\n        // Set up completion/error handling\n        const downloadComplete = new Promise<void>((resolve, reject) => {\n            const handler = (event: MessageEvent) => {\n                if (event.data?.fileId !== fileId) return;\n\n                if (event.data.type === 'DOWNLOAD_COMPLETE') {\n                    navigator.serviceWorker.removeEventListener('message', handler);\n                    resolve();\n                } else if (event.data.type === 'DOWNLOAD_ERROR') {\n                    navigator.serviceWorker.removeEventListener('message', handler);\n                    reject(new Error(event.data.error));\n                }\n            };\n\n            navigator.serviceWorker.addEventListener('message', handler);\n\n            // Timeout for very large files (2 hours max)\n            setTimeout(() => {\n                navigator.serviceWorker.removeEventListener('message', handler);\n                resolve(); // Don't reject on timeout, download might still be working\n            }, 2 * 60 * 60 * 1000);\n        });\n\n        // Wait for completion\n        await downloadComplete;\n\n        // Cleanup iframe\n        if (document.body.contains(iframe)) {\n            document.body.removeChild(iframe);\n        }\n\n        return {\n            success: true,\n            method: 'streamed'\n        };\n\n    } catch (error) {\n        console.error('[StreamDownload] Stream download failed:', error);\n        return {\n            success: false,\n            method: 'failed',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        };\n    }\n}\n\n/**\n * Cancel an ongoing stream download\n */\nexport function cancelStreamDownload(fileId: string): void {\n    if (navigator.serviceWorker.controller) {\n        navigator.serviceWorker.controller.postMessage({\n            type: 'CANCEL_DOWNLOAD',\n            fileId\n        });\n    }\n}\n\n// ============================================================================\n// THRESHOLD HELPERS\n// ============================================================================\n\n/**\n * Minimum file size to use streamed download (10MB)\n * Below this, in-memory download is more efficient\n */\nexport const STREAM_DOWNLOAD_THRESHOLD = 10 * 1024 * 1024;\n\n/**\n * Check if a file should use streamed download\n */\nexport function shouldUseStreamedDownload(fileSize: number): boolean {\n    if (!isServiceWorkerAvailable()) {\n        return false;\n    }\n\n    return fileSize > STREAM_DOWNLOAD_THRESHOLD;\n}\n\n/**\n * Get download method recommendation\n */\nexport function getDownloadRecommendation(fileSize: number): {\n    method: 'streamed' | 'memory';\n    reason: string;\n} {\n    if (!isServiceWorkerAvailable()) {\n        return {\n            method: 'memory',\n            reason: 'Service Worker not available'\n        };\n    }\n\n    if (fileSize <= STREAM_DOWNLOAD_THRESHOLD) {\n        return {\n            method: 'memory',\n            reason: 'Small file, in-memory download is faster'\n        };\n    }\n\n    return {\n        method: 'streamed',\n        reason: 'Large file, streaming prevents memory issues'\n    };\n}\n"],"names":["isServiceWorkerAvailable","initiateStreamDownload","fileId","key","chunks","metadata","onProgress","keyBase64","exportKey","progressHandler","event","data","c","resolve","reject","timeout","confirmHandler","iframe","handler","error","STREAM_DOWNLOAD_THRESHOLD","shouldUseStreamedDownload","fileSize"],"mappings":"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"}